
FreeRTOS_Driver.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00005100  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000132  00800060  00005100  00005194  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          000002fb  00800192  00800192  000052c6  2**0
                  ALLOC
  3 .stab         0000606c  00000000  00000000  000052c8  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      000031f4  00000000  00000000  0000b334  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 00000180  00000000  00000000  0000e528  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_pubnames 000001d1  00000000  00000000  0000e6a8  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   00002010  00000000  00000000  0000e879  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 00001161  00000000  00000000  00010889  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   00001003  00000000  00000000  000119ea  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  000001a0  00000000  00000000  000129f0  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    000002be  00000000  00000000  00012b90  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    0000090e  00000000  00000000  00012e4e  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 00000050  00000000  00000000  0001375c  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
       4:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      18:	0c 94 78 1c 	jmp	0x38f0	; 0x38f0 <__vector_6>
      1c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
      54:	11 24       	eor	r1, r1
      56:	1f be       	out	0x3f, r1	; 63
      58:	cf e5       	ldi	r28, 0x5F	; 95
      5a:	d4 e0       	ldi	r29, 0x04	; 4
      5c:	de bf       	out	0x3e, r29	; 62
      5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
      60:	11 e0       	ldi	r17, 0x01	; 1
      62:	a0 e6       	ldi	r26, 0x60	; 96
      64:	b0 e0       	ldi	r27, 0x00	; 0
      66:	e0 e0       	ldi	r30, 0x00	; 0
      68:	f1 e5       	ldi	r31, 0x51	; 81
      6a:	02 c0       	rjmp	.+4      	; 0x70 <.do_copy_data_start>

0000006c <.do_copy_data_loop>:
      6c:	05 90       	lpm	r0, Z+
      6e:	0d 92       	st	X+, r0

00000070 <.do_copy_data_start>:
      70:	a2 39       	cpi	r26, 0x92	; 146
      72:	b1 07       	cpc	r27, r17
      74:	d9 f7       	brne	.-10     	; 0x6c <.do_copy_data_loop>

00000076 <__do_clear_bss>:
      76:	14 e0       	ldi	r17, 0x04	; 4
      78:	a2 e9       	ldi	r26, 0x92	; 146
      7a:	b1 e0       	ldi	r27, 0x01	; 1
      7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
      7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
      80:	ad 38       	cpi	r26, 0x8D	; 141
      82:	b1 07       	cpc	r27, r17
      84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
      86:	0e 94 b8 18 	call	0x3170	; 0x3170 <main>
      8a:	0c 94 7e 28 	jmp	0x50fc	; 0x50fc <_exit>

0000008e <__bad_interrupt>:
      8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <__fixunssfsi>:
      92:	ef 92       	push	r14
      94:	ff 92       	push	r15
      96:	0f 93       	push	r16
      98:	1f 93       	push	r17
      9a:	7b 01       	movw	r14, r22
      9c:	8c 01       	movw	r16, r24
      9e:	20 e0       	ldi	r18, 0x00	; 0
      a0:	30 e0       	ldi	r19, 0x00	; 0
      a2:	40 e0       	ldi	r20, 0x00	; 0
      a4:	5f e4       	ldi	r21, 0x4F	; 79
      a6:	0e 94 49 03 	call	0x692	; 0x692 <__gesf2>
      aa:	88 23       	and	r24, r24
      ac:	8c f0       	brlt	.+34     	; 0xd0 <__fixunssfsi+0x3e>
      ae:	c8 01       	movw	r24, r16
      b0:	b7 01       	movw	r22, r14
      b2:	20 e0       	ldi	r18, 0x00	; 0
      b4:	30 e0       	ldi	r19, 0x00	; 0
      b6:	40 e0       	ldi	r20, 0x00	; 0
      b8:	5f e4       	ldi	r21, 0x4F	; 79
      ba:	0e 94 c1 01 	call	0x382	; 0x382 <__subsf3>
      be:	0e 94 07 04 	call	0x80e	; 0x80e <__fixsfsi>
      c2:	9b 01       	movw	r18, r22
      c4:	ac 01       	movw	r20, r24
      c6:	20 50       	subi	r18, 0x00	; 0
      c8:	30 40       	sbci	r19, 0x00	; 0
      ca:	40 40       	sbci	r20, 0x00	; 0
      cc:	50 48       	sbci	r21, 0x80	; 128
      ce:	06 c0       	rjmp	.+12     	; 0xdc <__fixunssfsi+0x4a>
      d0:	c8 01       	movw	r24, r16
      d2:	b7 01       	movw	r22, r14
      d4:	0e 94 07 04 	call	0x80e	; 0x80e <__fixsfsi>
      d8:	9b 01       	movw	r18, r22
      da:	ac 01       	movw	r20, r24
      dc:	b9 01       	movw	r22, r18
      de:	ca 01       	movw	r24, r20
      e0:	1f 91       	pop	r17
      e2:	0f 91       	pop	r16
      e4:	ff 90       	pop	r15
      e6:	ef 90       	pop	r14
      e8:	08 95       	ret

000000ea <_fpadd_parts>:
      ea:	a0 e0       	ldi	r26, 0x00	; 0
      ec:	b0 e0       	ldi	r27, 0x00	; 0
      ee:	eb e7       	ldi	r30, 0x7B	; 123
      f0:	f0 e0       	ldi	r31, 0x00	; 0
      f2:	0c 94 28 28 	jmp	0x5050	; 0x5050 <__prologue_saves__>
      f6:	dc 01       	movw	r26, r24
      f8:	2b 01       	movw	r4, r22
      fa:	fa 01       	movw	r30, r20
      fc:	9c 91       	ld	r25, X
      fe:	92 30       	cpi	r25, 0x02	; 2
     100:	08 f4       	brcc	.+2      	; 0x104 <_fpadd_parts+0x1a>
     102:	39 c1       	rjmp	.+626    	; 0x376 <_fpadd_parts+0x28c>
     104:	eb 01       	movw	r28, r22
     106:	88 81       	ld	r24, Y
     108:	82 30       	cpi	r24, 0x02	; 2
     10a:	08 f4       	brcc	.+2      	; 0x10e <_fpadd_parts+0x24>
     10c:	33 c1       	rjmp	.+614    	; 0x374 <_fpadd_parts+0x28a>
     10e:	94 30       	cpi	r25, 0x04	; 4
     110:	69 f4       	brne	.+26     	; 0x12c <_fpadd_parts+0x42>
     112:	84 30       	cpi	r24, 0x04	; 4
     114:	09 f0       	breq	.+2      	; 0x118 <_fpadd_parts+0x2e>
     116:	2f c1       	rjmp	.+606    	; 0x376 <_fpadd_parts+0x28c>
     118:	11 96       	adiw	r26, 0x01	; 1
     11a:	9c 91       	ld	r25, X
     11c:	11 97       	sbiw	r26, 0x01	; 1
     11e:	89 81       	ldd	r24, Y+1	; 0x01
     120:	98 17       	cp	r25, r24
     122:	09 f4       	brne	.+2      	; 0x126 <_fpadd_parts+0x3c>
     124:	28 c1       	rjmp	.+592    	; 0x376 <_fpadd_parts+0x28c>
     126:	a6 e8       	ldi	r26, 0x86	; 134
     128:	b0 e0       	ldi	r27, 0x00	; 0
     12a:	25 c1       	rjmp	.+586    	; 0x376 <_fpadd_parts+0x28c>
     12c:	84 30       	cpi	r24, 0x04	; 4
     12e:	09 f4       	brne	.+2      	; 0x132 <_fpadd_parts+0x48>
     130:	21 c1       	rjmp	.+578    	; 0x374 <_fpadd_parts+0x28a>
     132:	82 30       	cpi	r24, 0x02	; 2
     134:	a9 f4       	brne	.+42     	; 0x160 <_fpadd_parts+0x76>
     136:	92 30       	cpi	r25, 0x02	; 2
     138:	09 f0       	breq	.+2      	; 0x13c <_fpadd_parts+0x52>
     13a:	1d c1       	rjmp	.+570    	; 0x376 <_fpadd_parts+0x28c>
     13c:	9a 01       	movw	r18, r20
     13e:	ad 01       	movw	r20, r26
     140:	88 e0       	ldi	r24, 0x08	; 8
     142:	ea 01       	movw	r28, r20
     144:	09 90       	ld	r0, Y+
     146:	ae 01       	movw	r20, r28
     148:	e9 01       	movw	r28, r18
     14a:	09 92       	st	Y+, r0
     14c:	9e 01       	movw	r18, r28
     14e:	81 50       	subi	r24, 0x01	; 1
     150:	c1 f7       	brne	.-16     	; 0x142 <_fpadd_parts+0x58>
     152:	e2 01       	movw	r28, r4
     154:	89 81       	ldd	r24, Y+1	; 0x01
     156:	11 96       	adiw	r26, 0x01	; 1
     158:	9c 91       	ld	r25, X
     15a:	89 23       	and	r24, r25
     15c:	81 83       	std	Z+1, r24	; 0x01
     15e:	08 c1       	rjmp	.+528    	; 0x370 <_fpadd_parts+0x286>
     160:	92 30       	cpi	r25, 0x02	; 2
     162:	09 f4       	brne	.+2      	; 0x166 <_fpadd_parts+0x7c>
     164:	07 c1       	rjmp	.+526    	; 0x374 <_fpadd_parts+0x28a>
     166:	12 96       	adiw	r26, 0x02	; 2
     168:	2d 90       	ld	r2, X+
     16a:	3c 90       	ld	r3, X
     16c:	13 97       	sbiw	r26, 0x03	; 3
     16e:	eb 01       	movw	r28, r22
     170:	8a 81       	ldd	r24, Y+2	; 0x02
     172:	9b 81       	ldd	r25, Y+3	; 0x03
     174:	14 96       	adiw	r26, 0x04	; 4
     176:	ad 90       	ld	r10, X+
     178:	bd 90       	ld	r11, X+
     17a:	cd 90       	ld	r12, X+
     17c:	dc 90       	ld	r13, X
     17e:	17 97       	sbiw	r26, 0x07	; 7
     180:	ec 80       	ldd	r14, Y+4	; 0x04
     182:	fd 80       	ldd	r15, Y+5	; 0x05
     184:	0e 81       	ldd	r16, Y+6	; 0x06
     186:	1f 81       	ldd	r17, Y+7	; 0x07
     188:	91 01       	movw	r18, r2
     18a:	28 1b       	sub	r18, r24
     18c:	39 0b       	sbc	r19, r25
     18e:	b9 01       	movw	r22, r18
     190:	37 ff       	sbrs	r19, 7
     192:	04 c0       	rjmp	.+8      	; 0x19c <_fpadd_parts+0xb2>
     194:	66 27       	eor	r22, r22
     196:	77 27       	eor	r23, r23
     198:	62 1b       	sub	r22, r18
     19a:	73 0b       	sbc	r23, r19
     19c:	60 32       	cpi	r22, 0x20	; 32
     19e:	71 05       	cpc	r23, r1
     1a0:	0c f0       	brlt	.+2      	; 0x1a4 <_fpadd_parts+0xba>
     1a2:	61 c0       	rjmp	.+194    	; 0x266 <_fpadd_parts+0x17c>
     1a4:	12 16       	cp	r1, r18
     1a6:	13 06       	cpc	r1, r19
     1a8:	6c f5       	brge	.+90     	; 0x204 <_fpadd_parts+0x11a>
     1aa:	37 01       	movw	r6, r14
     1ac:	48 01       	movw	r8, r16
     1ae:	06 2e       	mov	r0, r22
     1b0:	04 c0       	rjmp	.+8      	; 0x1ba <_fpadd_parts+0xd0>
     1b2:	96 94       	lsr	r9
     1b4:	87 94       	ror	r8
     1b6:	77 94       	ror	r7
     1b8:	67 94       	ror	r6
     1ba:	0a 94       	dec	r0
     1bc:	d2 f7       	brpl	.-12     	; 0x1b2 <_fpadd_parts+0xc8>
     1be:	21 e0       	ldi	r18, 0x01	; 1
     1c0:	30 e0       	ldi	r19, 0x00	; 0
     1c2:	40 e0       	ldi	r20, 0x00	; 0
     1c4:	50 e0       	ldi	r21, 0x00	; 0
     1c6:	04 c0       	rjmp	.+8      	; 0x1d0 <_fpadd_parts+0xe6>
     1c8:	22 0f       	add	r18, r18
     1ca:	33 1f       	adc	r19, r19
     1cc:	44 1f       	adc	r20, r20
     1ce:	55 1f       	adc	r21, r21
     1d0:	6a 95       	dec	r22
     1d2:	d2 f7       	brpl	.-12     	; 0x1c8 <_fpadd_parts+0xde>
     1d4:	21 50       	subi	r18, 0x01	; 1
     1d6:	30 40       	sbci	r19, 0x00	; 0
     1d8:	40 40       	sbci	r20, 0x00	; 0
     1da:	50 40       	sbci	r21, 0x00	; 0
     1dc:	2e 21       	and	r18, r14
     1de:	3f 21       	and	r19, r15
     1e0:	40 23       	and	r20, r16
     1e2:	51 23       	and	r21, r17
     1e4:	21 15       	cp	r18, r1
     1e6:	31 05       	cpc	r19, r1
     1e8:	41 05       	cpc	r20, r1
     1ea:	51 05       	cpc	r21, r1
     1ec:	21 f0       	breq	.+8      	; 0x1f6 <_fpadd_parts+0x10c>
     1ee:	21 e0       	ldi	r18, 0x01	; 1
     1f0:	30 e0       	ldi	r19, 0x00	; 0
     1f2:	40 e0       	ldi	r20, 0x00	; 0
     1f4:	50 e0       	ldi	r21, 0x00	; 0
     1f6:	79 01       	movw	r14, r18
     1f8:	8a 01       	movw	r16, r20
     1fa:	e6 28       	or	r14, r6
     1fc:	f7 28       	or	r15, r7
     1fe:	08 29       	or	r16, r8
     200:	19 29       	or	r17, r9
     202:	3c c0       	rjmp	.+120    	; 0x27c <_fpadd_parts+0x192>
     204:	23 2b       	or	r18, r19
     206:	d1 f1       	breq	.+116    	; 0x27c <_fpadd_parts+0x192>
     208:	26 0e       	add	r2, r22
     20a:	37 1e       	adc	r3, r23
     20c:	35 01       	movw	r6, r10
     20e:	46 01       	movw	r8, r12
     210:	06 2e       	mov	r0, r22
     212:	04 c0       	rjmp	.+8      	; 0x21c <_fpadd_parts+0x132>
     214:	96 94       	lsr	r9
     216:	87 94       	ror	r8
     218:	77 94       	ror	r7
     21a:	67 94       	ror	r6
     21c:	0a 94       	dec	r0
     21e:	d2 f7       	brpl	.-12     	; 0x214 <_fpadd_parts+0x12a>
     220:	21 e0       	ldi	r18, 0x01	; 1
     222:	30 e0       	ldi	r19, 0x00	; 0
     224:	40 e0       	ldi	r20, 0x00	; 0
     226:	50 e0       	ldi	r21, 0x00	; 0
     228:	04 c0       	rjmp	.+8      	; 0x232 <_fpadd_parts+0x148>
     22a:	22 0f       	add	r18, r18
     22c:	33 1f       	adc	r19, r19
     22e:	44 1f       	adc	r20, r20
     230:	55 1f       	adc	r21, r21
     232:	6a 95       	dec	r22
     234:	d2 f7       	brpl	.-12     	; 0x22a <_fpadd_parts+0x140>
     236:	21 50       	subi	r18, 0x01	; 1
     238:	30 40       	sbci	r19, 0x00	; 0
     23a:	40 40       	sbci	r20, 0x00	; 0
     23c:	50 40       	sbci	r21, 0x00	; 0
     23e:	2a 21       	and	r18, r10
     240:	3b 21       	and	r19, r11
     242:	4c 21       	and	r20, r12
     244:	5d 21       	and	r21, r13
     246:	21 15       	cp	r18, r1
     248:	31 05       	cpc	r19, r1
     24a:	41 05       	cpc	r20, r1
     24c:	51 05       	cpc	r21, r1
     24e:	21 f0       	breq	.+8      	; 0x258 <_fpadd_parts+0x16e>
     250:	21 e0       	ldi	r18, 0x01	; 1
     252:	30 e0       	ldi	r19, 0x00	; 0
     254:	40 e0       	ldi	r20, 0x00	; 0
     256:	50 e0       	ldi	r21, 0x00	; 0
     258:	59 01       	movw	r10, r18
     25a:	6a 01       	movw	r12, r20
     25c:	a6 28       	or	r10, r6
     25e:	b7 28       	or	r11, r7
     260:	c8 28       	or	r12, r8
     262:	d9 28       	or	r13, r9
     264:	0b c0       	rjmp	.+22     	; 0x27c <_fpadd_parts+0x192>
     266:	82 15       	cp	r24, r2
     268:	93 05       	cpc	r25, r3
     26a:	2c f0       	brlt	.+10     	; 0x276 <_fpadd_parts+0x18c>
     26c:	1c 01       	movw	r2, r24
     26e:	aa 24       	eor	r10, r10
     270:	bb 24       	eor	r11, r11
     272:	65 01       	movw	r12, r10
     274:	03 c0       	rjmp	.+6      	; 0x27c <_fpadd_parts+0x192>
     276:	ee 24       	eor	r14, r14
     278:	ff 24       	eor	r15, r15
     27a:	87 01       	movw	r16, r14
     27c:	11 96       	adiw	r26, 0x01	; 1
     27e:	9c 91       	ld	r25, X
     280:	d2 01       	movw	r26, r4
     282:	11 96       	adiw	r26, 0x01	; 1
     284:	8c 91       	ld	r24, X
     286:	98 17       	cp	r25, r24
     288:	09 f4       	brne	.+2      	; 0x28c <_fpadd_parts+0x1a2>
     28a:	45 c0       	rjmp	.+138    	; 0x316 <_fpadd_parts+0x22c>
     28c:	99 23       	and	r25, r25
     28e:	39 f0       	breq	.+14     	; 0x29e <_fpadd_parts+0x1b4>
     290:	a8 01       	movw	r20, r16
     292:	97 01       	movw	r18, r14
     294:	2a 19       	sub	r18, r10
     296:	3b 09       	sbc	r19, r11
     298:	4c 09       	sbc	r20, r12
     29a:	5d 09       	sbc	r21, r13
     29c:	06 c0       	rjmp	.+12     	; 0x2aa <_fpadd_parts+0x1c0>
     29e:	a6 01       	movw	r20, r12
     2a0:	95 01       	movw	r18, r10
     2a2:	2e 19       	sub	r18, r14
     2a4:	3f 09       	sbc	r19, r15
     2a6:	40 0b       	sbc	r20, r16
     2a8:	51 0b       	sbc	r21, r17
     2aa:	57 fd       	sbrc	r21, 7
     2ac:	08 c0       	rjmp	.+16     	; 0x2be <_fpadd_parts+0x1d4>
     2ae:	11 82       	std	Z+1, r1	; 0x01
     2b0:	33 82       	std	Z+3, r3	; 0x03
     2b2:	22 82       	std	Z+2, r2	; 0x02
     2b4:	24 83       	std	Z+4, r18	; 0x04
     2b6:	35 83       	std	Z+5, r19	; 0x05
     2b8:	46 83       	std	Z+6, r20	; 0x06
     2ba:	57 83       	std	Z+7, r21	; 0x07
     2bc:	1d c0       	rjmp	.+58     	; 0x2f8 <_fpadd_parts+0x20e>
     2be:	81 e0       	ldi	r24, 0x01	; 1
     2c0:	81 83       	std	Z+1, r24	; 0x01
     2c2:	33 82       	std	Z+3, r3	; 0x03
     2c4:	22 82       	std	Z+2, r2	; 0x02
     2c6:	88 27       	eor	r24, r24
     2c8:	99 27       	eor	r25, r25
     2ca:	dc 01       	movw	r26, r24
     2cc:	82 1b       	sub	r24, r18
     2ce:	93 0b       	sbc	r25, r19
     2d0:	a4 0b       	sbc	r26, r20
     2d2:	b5 0b       	sbc	r27, r21
     2d4:	84 83       	std	Z+4, r24	; 0x04
     2d6:	95 83       	std	Z+5, r25	; 0x05
     2d8:	a6 83       	std	Z+6, r26	; 0x06
     2da:	b7 83       	std	Z+7, r27	; 0x07
     2dc:	0d c0       	rjmp	.+26     	; 0x2f8 <_fpadd_parts+0x20e>
     2de:	22 0f       	add	r18, r18
     2e0:	33 1f       	adc	r19, r19
     2e2:	44 1f       	adc	r20, r20
     2e4:	55 1f       	adc	r21, r21
     2e6:	24 83       	std	Z+4, r18	; 0x04
     2e8:	35 83       	std	Z+5, r19	; 0x05
     2ea:	46 83       	std	Z+6, r20	; 0x06
     2ec:	57 83       	std	Z+7, r21	; 0x07
     2ee:	82 81       	ldd	r24, Z+2	; 0x02
     2f0:	93 81       	ldd	r25, Z+3	; 0x03
     2f2:	01 97       	sbiw	r24, 0x01	; 1
     2f4:	93 83       	std	Z+3, r25	; 0x03
     2f6:	82 83       	std	Z+2, r24	; 0x02
     2f8:	24 81       	ldd	r18, Z+4	; 0x04
     2fa:	35 81       	ldd	r19, Z+5	; 0x05
     2fc:	46 81       	ldd	r20, Z+6	; 0x06
     2fe:	57 81       	ldd	r21, Z+7	; 0x07
     300:	da 01       	movw	r26, r20
     302:	c9 01       	movw	r24, r18
     304:	01 97       	sbiw	r24, 0x01	; 1
     306:	a1 09       	sbc	r26, r1
     308:	b1 09       	sbc	r27, r1
     30a:	8f 5f       	subi	r24, 0xFF	; 255
     30c:	9f 4f       	sbci	r25, 0xFF	; 255
     30e:	af 4f       	sbci	r26, 0xFF	; 255
     310:	bf 43       	sbci	r27, 0x3F	; 63
     312:	28 f3       	brcs	.-54     	; 0x2de <_fpadd_parts+0x1f4>
     314:	0b c0       	rjmp	.+22     	; 0x32c <_fpadd_parts+0x242>
     316:	91 83       	std	Z+1, r25	; 0x01
     318:	33 82       	std	Z+3, r3	; 0x03
     31a:	22 82       	std	Z+2, r2	; 0x02
     31c:	ea 0c       	add	r14, r10
     31e:	fb 1c       	adc	r15, r11
     320:	0c 1d       	adc	r16, r12
     322:	1d 1d       	adc	r17, r13
     324:	e4 82       	std	Z+4, r14	; 0x04
     326:	f5 82       	std	Z+5, r15	; 0x05
     328:	06 83       	std	Z+6, r16	; 0x06
     32a:	17 83       	std	Z+7, r17	; 0x07
     32c:	83 e0       	ldi	r24, 0x03	; 3
     32e:	80 83       	st	Z, r24
     330:	24 81       	ldd	r18, Z+4	; 0x04
     332:	35 81       	ldd	r19, Z+5	; 0x05
     334:	46 81       	ldd	r20, Z+6	; 0x06
     336:	57 81       	ldd	r21, Z+7	; 0x07
     338:	57 ff       	sbrs	r21, 7
     33a:	1a c0       	rjmp	.+52     	; 0x370 <_fpadd_parts+0x286>
     33c:	c9 01       	movw	r24, r18
     33e:	aa 27       	eor	r26, r26
     340:	97 fd       	sbrc	r25, 7
     342:	a0 95       	com	r26
     344:	ba 2f       	mov	r27, r26
     346:	81 70       	andi	r24, 0x01	; 1
     348:	90 70       	andi	r25, 0x00	; 0
     34a:	a0 70       	andi	r26, 0x00	; 0
     34c:	b0 70       	andi	r27, 0x00	; 0
     34e:	56 95       	lsr	r21
     350:	47 95       	ror	r20
     352:	37 95       	ror	r19
     354:	27 95       	ror	r18
     356:	82 2b       	or	r24, r18
     358:	93 2b       	or	r25, r19
     35a:	a4 2b       	or	r26, r20
     35c:	b5 2b       	or	r27, r21
     35e:	84 83       	std	Z+4, r24	; 0x04
     360:	95 83       	std	Z+5, r25	; 0x05
     362:	a6 83       	std	Z+6, r26	; 0x06
     364:	b7 83       	std	Z+7, r27	; 0x07
     366:	82 81       	ldd	r24, Z+2	; 0x02
     368:	93 81       	ldd	r25, Z+3	; 0x03
     36a:	01 96       	adiw	r24, 0x01	; 1
     36c:	93 83       	std	Z+3, r25	; 0x03
     36e:	82 83       	std	Z+2, r24	; 0x02
     370:	df 01       	movw	r26, r30
     372:	01 c0       	rjmp	.+2      	; 0x376 <_fpadd_parts+0x28c>
     374:	d2 01       	movw	r26, r4
     376:	cd 01       	movw	r24, r26
     378:	cd b7       	in	r28, 0x3d	; 61
     37a:	de b7       	in	r29, 0x3e	; 62
     37c:	e2 e1       	ldi	r30, 0x12	; 18
     37e:	0c 94 44 28 	jmp	0x5088	; 0x5088 <__epilogue_restores__>

00000382 <__subsf3>:
     382:	a0 e2       	ldi	r26, 0x20	; 32
     384:	b0 e0       	ldi	r27, 0x00	; 0
     386:	e7 ec       	ldi	r30, 0xC7	; 199
     388:	f1 e0       	ldi	r31, 0x01	; 1
     38a:	0c 94 34 28 	jmp	0x5068	; 0x5068 <__prologue_saves__+0x18>
     38e:	69 83       	std	Y+1, r22	; 0x01
     390:	7a 83       	std	Y+2, r23	; 0x02
     392:	8b 83       	std	Y+3, r24	; 0x03
     394:	9c 83       	std	Y+4, r25	; 0x04
     396:	2d 83       	std	Y+5, r18	; 0x05
     398:	3e 83       	std	Y+6, r19	; 0x06
     39a:	4f 83       	std	Y+7, r20	; 0x07
     39c:	58 87       	std	Y+8, r21	; 0x08
     39e:	e9 e0       	ldi	r30, 0x09	; 9
     3a0:	ee 2e       	mov	r14, r30
     3a2:	f1 2c       	mov	r15, r1
     3a4:	ec 0e       	add	r14, r28
     3a6:	fd 1e       	adc	r15, r29
     3a8:	ce 01       	movw	r24, r28
     3aa:	01 96       	adiw	r24, 0x01	; 1
     3ac:	b7 01       	movw	r22, r14
     3ae:	0e 94 7f 05 	call	0xafe	; 0xafe <__unpack_f>
     3b2:	8e 01       	movw	r16, r28
     3b4:	0f 5e       	subi	r16, 0xEF	; 239
     3b6:	1f 4f       	sbci	r17, 0xFF	; 255
     3b8:	ce 01       	movw	r24, r28
     3ba:	05 96       	adiw	r24, 0x05	; 5
     3bc:	b8 01       	movw	r22, r16
     3be:	0e 94 7f 05 	call	0xafe	; 0xafe <__unpack_f>
     3c2:	8a 89       	ldd	r24, Y+18	; 0x12
     3c4:	91 e0       	ldi	r25, 0x01	; 1
     3c6:	89 27       	eor	r24, r25
     3c8:	8a 8b       	std	Y+18, r24	; 0x12
     3ca:	c7 01       	movw	r24, r14
     3cc:	b8 01       	movw	r22, r16
     3ce:	ae 01       	movw	r20, r28
     3d0:	47 5e       	subi	r20, 0xE7	; 231
     3d2:	5f 4f       	sbci	r21, 0xFF	; 255
     3d4:	0e 94 75 00 	call	0xea	; 0xea <_fpadd_parts>
     3d8:	0e 94 aa 04 	call	0x954	; 0x954 <__pack_f>
     3dc:	a0 96       	adiw	r28, 0x20	; 32
     3de:	e6 e0       	ldi	r30, 0x06	; 6
     3e0:	0c 94 50 28 	jmp	0x50a0	; 0x50a0 <__epilogue_restores__+0x18>

000003e4 <__addsf3>:
     3e4:	a0 e2       	ldi	r26, 0x20	; 32
     3e6:	b0 e0       	ldi	r27, 0x00	; 0
     3e8:	e8 ef       	ldi	r30, 0xF8	; 248
     3ea:	f1 e0       	ldi	r31, 0x01	; 1
     3ec:	0c 94 34 28 	jmp	0x5068	; 0x5068 <__prologue_saves__+0x18>
     3f0:	69 83       	std	Y+1, r22	; 0x01
     3f2:	7a 83       	std	Y+2, r23	; 0x02
     3f4:	8b 83       	std	Y+3, r24	; 0x03
     3f6:	9c 83       	std	Y+4, r25	; 0x04
     3f8:	2d 83       	std	Y+5, r18	; 0x05
     3fa:	3e 83       	std	Y+6, r19	; 0x06
     3fc:	4f 83       	std	Y+7, r20	; 0x07
     3fe:	58 87       	std	Y+8, r21	; 0x08
     400:	f9 e0       	ldi	r31, 0x09	; 9
     402:	ef 2e       	mov	r14, r31
     404:	f1 2c       	mov	r15, r1
     406:	ec 0e       	add	r14, r28
     408:	fd 1e       	adc	r15, r29
     40a:	ce 01       	movw	r24, r28
     40c:	01 96       	adiw	r24, 0x01	; 1
     40e:	b7 01       	movw	r22, r14
     410:	0e 94 7f 05 	call	0xafe	; 0xafe <__unpack_f>
     414:	8e 01       	movw	r16, r28
     416:	0f 5e       	subi	r16, 0xEF	; 239
     418:	1f 4f       	sbci	r17, 0xFF	; 255
     41a:	ce 01       	movw	r24, r28
     41c:	05 96       	adiw	r24, 0x05	; 5
     41e:	b8 01       	movw	r22, r16
     420:	0e 94 7f 05 	call	0xafe	; 0xafe <__unpack_f>
     424:	c7 01       	movw	r24, r14
     426:	b8 01       	movw	r22, r16
     428:	ae 01       	movw	r20, r28
     42a:	47 5e       	subi	r20, 0xE7	; 231
     42c:	5f 4f       	sbci	r21, 0xFF	; 255
     42e:	0e 94 75 00 	call	0xea	; 0xea <_fpadd_parts>
     432:	0e 94 aa 04 	call	0x954	; 0x954 <__pack_f>
     436:	a0 96       	adiw	r28, 0x20	; 32
     438:	e6 e0       	ldi	r30, 0x06	; 6
     43a:	0c 94 50 28 	jmp	0x50a0	; 0x50a0 <__epilogue_restores__+0x18>

0000043e <__mulsf3>:
     43e:	a0 e2       	ldi	r26, 0x20	; 32
     440:	b0 e0       	ldi	r27, 0x00	; 0
     442:	e5 e2       	ldi	r30, 0x25	; 37
     444:	f2 e0       	ldi	r31, 0x02	; 2
     446:	0c 94 28 28 	jmp	0x5050	; 0x5050 <__prologue_saves__>
     44a:	69 83       	std	Y+1, r22	; 0x01
     44c:	7a 83       	std	Y+2, r23	; 0x02
     44e:	8b 83       	std	Y+3, r24	; 0x03
     450:	9c 83       	std	Y+4, r25	; 0x04
     452:	2d 83       	std	Y+5, r18	; 0x05
     454:	3e 83       	std	Y+6, r19	; 0x06
     456:	4f 83       	std	Y+7, r20	; 0x07
     458:	58 87       	std	Y+8, r21	; 0x08
     45a:	ce 01       	movw	r24, r28
     45c:	01 96       	adiw	r24, 0x01	; 1
     45e:	be 01       	movw	r22, r28
     460:	67 5f       	subi	r22, 0xF7	; 247
     462:	7f 4f       	sbci	r23, 0xFF	; 255
     464:	0e 94 7f 05 	call	0xafe	; 0xafe <__unpack_f>
     468:	ce 01       	movw	r24, r28
     46a:	05 96       	adiw	r24, 0x05	; 5
     46c:	be 01       	movw	r22, r28
     46e:	6f 5e       	subi	r22, 0xEF	; 239
     470:	7f 4f       	sbci	r23, 0xFF	; 255
     472:	0e 94 7f 05 	call	0xafe	; 0xafe <__unpack_f>
     476:	99 85       	ldd	r25, Y+9	; 0x09
     478:	92 30       	cpi	r25, 0x02	; 2
     47a:	88 f0       	brcs	.+34     	; 0x49e <__stack+0x3f>
     47c:	89 89       	ldd	r24, Y+17	; 0x11
     47e:	82 30       	cpi	r24, 0x02	; 2
     480:	c8 f0       	brcs	.+50     	; 0x4b4 <__stack+0x55>
     482:	94 30       	cpi	r25, 0x04	; 4
     484:	19 f4       	brne	.+6      	; 0x48c <__stack+0x2d>
     486:	82 30       	cpi	r24, 0x02	; 2
     488:	51 f4       	brne	.+20     	; 0x49e <__stack+0x3f>
     48a:	04 c0       	rjmp	.+8      	; 0x494 <__stack+0x35>
     48c:	84 30       	cpi	r24, 0x04	; 4
     48e:	29 f4       	brne	.+10     	; 0x49a <__stack+0x3b>
     490:	92 30       	cpi	r25, 0x02	; 2
     492:	81 f4       	brne	.+32     	; 0x4b4 <__stack+0x55>
     494:	86 e8       	ldi	r24, 0x86	; 134
     496:	90 e0       	ldi	r25, 0x00	; 0
     498:	c6 c0       	rjmp	.+396    	; 0x626 <__stack+0x1c7>
     49a:	92 30       	cpi	r25, 0x02	; 2
     49c:	49 f4       	brne	.+18     	; 0x4b0 <__stack+0x51>
     49e:	20 e0       	ldi	r18, 0x00	; 0
     4a0:	9a 85       	ldd	r25, Y+10	; 0x0a
     4a2:	8a 89       	ldd	r24, Y+18	; 0x12
     4a4:	98 13       	cpse	r25, r24
     4a6:	21 e0       	ldi	r18, 0x01	; 1
     4a8:	2a 87       	std	Y+10, r18	; 0x0a
     4aa:	ce 01       	movw	r24, r28
     4ac:	09 96       	adiw	r24, 0x09	; 9
     4ae:	bb c0       	rjmp	.+374    	; 0x626 <__stack+0x1c7>
     4b0:	82 30       	cpi	r24, 0x02	; 2
     4b2:	49 f4       	brne	.+18     	; 0x4c6 <__stack+0x67>
     4b4:	20 e0       	ldi	r18, 0x00	; 0
     4b6:	9a 85       	ldd	r25, Y+10	; 0x0a
     4b8:	8a 89       	ldd	r24, Y+18	; 0x12
     4ba:	98 13       	cpse	r25, r24
     4bc:	21 e0       	ldi	r18, 0x01	; 1
     4be:	2a 8b       	std	Y+18, r18	; 0x12
     4c0:	ce 01       	movw	r24, r28
     4c2:	41 96       	adiw	r24, 0x11	; 17
     4c4:	b0 c0       	rjmp	.+352    	; 0x626 <__stack+0x1c7>
     4c6:	2d 84       	ldd	r2, Y+13	; 0x0d
     4c8:	3e 84       	ldd	r3, Y+14	; 0x0e
     4ca:	4f 84       	ldd	r4, Y+15	; 0x0f
     4cc:	58 88       	ldd	r5, Y+16	; 0x10
     4ce:	6d 88       	ldd	r6, Y+21	; 0x15
     4d0:	7e 88       	ldd	r7, Y+22	; 0x16
     4d2:	8f 88       	ldd	r8, Y+23	; 0x17
     4d4:	98 8c       	ldd	r9, Y+24	; 0x18
     4d6:	ee 24       	eor	r14, r14
     4d8:	ff 24       	eor	r15, r15
     4da:	87 01       	movw	r16, r14
     4dc:	aa 24       	eor	r10, r10
     4de:	bb 24       	eor	r11, r11
     4e0:	65 01       	movw	r12, r10
     4e2:	40 e0       	ldi	r20, 0x00	; 0
     4e4:	50 e0       	ldi	r21, 0x00	; 0
     4e6:	60 e0       	ldi	r22, 0x00	; 0
     4e8:	70 e0       	ldi	r23, 0x00	; 0
     4ea:	e0 e0       	ldi	r30, 0x00	; 0
     4ec:	f0 e0       	ldi	r31, 0x00	; 0
     4ee:	c1 01       	movw	r24, r2
     4f0:	81 70       	andi	r24, 0x01	; 1
     4f2:	90 70       	andi	r25, 0x00	; 0
     4f4:	89 2b       	or	r24, r25
     4f6:	e9 f0       	breq	.+58     	; 0x532 <__stack+0xd3>
     4f8:	e6 0c       	add	r14, r6
     4fa:	f7 1c       	adc	r15, r7
     4fc:	08 1d       	adc	r16, r8
     4fe:	19 1d       	adc	r17, r9
     500:	9a 01       	movw	r18, r20
     502:	ab 01       	movw	r20, r22
     504:	2a 0d       	add	r18, r10
     506:	3b 1d       	adc	r19, r11
     508:	4c 1d       	adc	r20, r12
     50a:	5d 1d       	adc	r21, r13
     50c:	80 e0       	ldi	r24, 0x00	; 0
     50e:	90 e0       	ldi	r25, 0x00	; 0
     510:	a0 e0       	ldi	r26, 0x00	; 0
     512:	b0 e0       	ldi	r27, 0x00	; 0
     514:	e6 14       	cp	r14, r6
     516:	f7 04       	cpc	r15, r7
     518:	08 05       	cpc	r16, r8
     51a:	19 05       	cpc	r17, r9
     51c:	20 f4       	brcc	.+8      	; 0x526 <__stack+0xc7>
     51e:	81 e0       	ldi	r24, 0x01	; 1
     520:	90 e0       	ldi	r25, 0x00	; 0
     522:	a0 e0       	ldi	r26, 0x00	; 0
     524:	b0 e0       	ldi	r27, 0x00	; 0
     526:	ba 01       	movw	r22, r20
     528:	a9 01       	movw	r20, r18
     52a:	48 0f       	add	r20, r24
     52c:	59 1f       	adc	r21, r25
     52e:	6a 1f       	adc	r22, r26
     530:	7b 1f       	adc	r23, r27
     532:	aa 0c       	add	r10, r10
     534:	bb 1c       	adc	r11, r11
     536:	cc 1c       	adc	r12, r12
     538:	dd 1c       	adc	r13, r13
     53a:	97 fe       	sbrs	r9, 7
     53c:	08 c0       	rjmp	.+16     	; 0x54e <__stack+0xef>
     53e:	81 e0       	ldi	r24, 0x01	; 1
     540:	90 e0       	ldi	r25, 0x00	; 0
     542:	a0 e0       	ldi	r26, 0x00	; 0
     544:	b0 e0       	ldi	r27, 0x00	; 0
     546:	a8 2a       	or	r10, r24
     548:	b9 2a       	or	r11, r25
     54a:	ca 2a       	or	r12, r26
     54c:	db 2a       	or	r13, r27
     54e:	31 96       	adiw	r30, 0x01	; 1
     550:	e0 32       	cpi	r30, 0x20	; 32
     552:	f1 05       	cpc	r31, r1
     554:	49 f0       	breq	.+18     	; 0x568 <__stack+0x109>
     556:	66 0c       	add	r6, r6
     558:	77 1c       	adc	r7, r7
     55a:	88 1c       	adc	r8, r8
     55c:	99 1c       	adc	r9, r9
     55e:	56 94       	lsr	r5
     560:	47 94       	ror	r4
     562:	37 94       	ror	r3
     564:	27 94       	ror	r2
     566:	c3 cf       	rjmp	.-122    	; 0x4ee <__stack+0x8f>
     568:	fa 85       	ldd	r31, Y+10	; 0x0a
     56a:	ea 89       	ldd	r30, Y+18	; 0x12
     56c:	2b 89       	ldd	r18, Y+19	; 0x13
     56e:	3c 89       	ldd	r19, Y+20	; 0x14
     570:	8b 85       	ldd	r24, Y+11	; 0x0b
     572:	9c 85       	ldd	r25, Y+12	; 0x0c
     574:	28 0f       	add	r18, r24
     576:	39 1f       	adc	r19, r25
     578:	2e 5f       	subi	r18, 0xFE	; 254
     57a:	3f 4f       	sbci	r19, 0xFF	; 255
     57c:	17 c0       	rjmp	.+46     	; 0x5ac <__stack+0x14d>
     57e:	ca 01       	movw	r24, r20
     580:	81 70       	andi	r24, 0x01	; 1
     582:	90 70       	andi	r25, 0x00	; 0
     584:	89 2b       	or	r24, r25
     586:	61 f0       	breq	.+24     	; 0x5a0 <__stack+0x141>
     588:	16 95       	lsr	r17
     58a:	07 95       	ror	r16
     58c:	f7 94       	ror	r15
     58e:	e7 94       	ror	r14
     590:	80 e0       	ldi	r24, 0x00	; 0
     592:	90 e0       	ldi	r25, 0x00	; 0
     594:	a0 e0       	ldi	r26, 0x00	; 0
     596:	b0 e8       	ldi	r27, 0x80	; 128
     598:	e8 2a       	or	r14, r24
     59a:	f9 2a       	or	r15, r25
     59c:	0a 2b       	or	r16, r26
     59e:	1b 2b       	or	r17, r27
     5a0:	76 95       	lsr	r23
     5a2:	67 95       	ror	r22
     5a4:	57 95       	ror	r21
     5a6:	47 95       	ror	r20
     5a8:	2f 5f       	subi	r18, 0xFF	; 255
     5aa:	3f 4f       	sbci	r19, 0xFF	; 255
     5ac:	77 fd       	sbrc	r23, 7
     5ae:	e7 cf       	rjmp	.-50     	; 0x57e <__stack+0x11f>
     5b0:	0c c0       	rjmp	.+24     	; 0x5ca <__stack+0x16b>
     5b2:	44 0f       	add	r20, r20
     5b4:	55 1f       	adc	r21, r21
     5b6:	66 1f       	adc	r22, r22
     5b8:	77 1f       	adc	r23, r23
     5ba:	17 fd       	sbrc	r17, 7
     5bc:	41 60       	ori	r20, 0x01	; 1
     5be:	ee 0c       	add	r14, r14
     5c0:	ff 1c       	adc	r15, r15
     5c2:	00 1f       	adc	r16, r16
     5c4:	11 1f       	adc	r17, r17
     5c6:	21 50       	subi	r18, 0x01	; 1
     5c8:	30 40       	sbci	r19, 0x00	; 0
     5ca:	40 30       	cpi	r20, 0x00	; 0
     5cc:	90 e0       	ldi	r25, 0x00	; 0
     5ce:	59 07       	cpc	r21, r25
     5d0:	90 e0       	ldi	r25, 0x00	; 0
     5d2:	69 07       	cpc	r22, r25
     5d4:	90 e4       	ldi	r25, 0x40	; 64
     5d6:	79 07       	cpc	r23, r25
     5d8:	60 f3       	brcs	.-40     	; 0x5b2 <__stack+0x153>
     5da:	2b 8f       	std	Y+27, r18	; 0x1b
     5dc:	3c 8f       	std	Y+28, r19	; 0x1c
     5de:	db 01       	movw	r26, r22
     5e0:	ca 01       	movw	r24, r20
     5e2:	8f 77       	andi	r24, 0x7F	; 127
     5e4:	90 70       	andi	r25, 0x00	; 0
     5e6:	a0 70       	andi	r26, 0x00	; 0
     5e8:	b0 70       	andi	r27, 0x00	; 0
     5ea:	80 34       	cpi	r24, 0x40	; 64
     5ec:	91 05       	cpc	r25, r1
     5ee:	a1 05       	cpc	r26, r1
     5f0:	b1 05       	cpc	r27, r1
     5f2:	61 f4       	brne	.+24     	; 0x60c <__stack+0x1ad>
     5f4:	47 fd       	sbrc	r20, 7
     5f6:	0a c0       	rjmp	.+20     	; 0x60c <__stack+0x1ad>
     5f8:	e1 14       	cp	r14, r1
     5fa:	f1 04       	cpc	r15, r1
     5fc:	01 05       	cpc	r16, r1
     5fe:	11 05       	cpc	r17, r1
     600:	29 f0       	breq	.+10     	; 0x60c <__stack+0x1ad>
     602:	40 5c       	subi	r20, 0xC0	; 192
     604:	5f 4f       	sbci	r21, 0xFF	; 255
     606:	6f 4f       	sbci	r22, 0xFF	; 255
     608:	7f 4f       	sbci	r23, 0xFF	; 255
     60a:	40 78       	andi	r20, 0x80	; 128
     60c:	1a 8e       	std	Y+26, r1	; 0x1a
     60e:	fe 17       	cp	r31, r30
     610:	11 f0       	breq	.+4      	; 0x616 <__stack+0x1b7>
     612:	81 e0       	ldi	r24, 0x01	; 1
     614:	8a 8f       	std	Y+26, r24	; 0x1a
     616:	4d 8f       	std	Y+29, r20	; 0x1d
     618:	5e 8f       	std	Y+30, r21	; 0x1e
     61a:	6f 8f       	std	Y+31, r22	; 0x1f
     61c:	78 a3       	std	Y+32, r23	; 0x20
     61e:	83 e0       	ldi	r24, 0x03	; 3
     620:	89 8f       	std	Y+25, r24	; 0x19
     622:	ce 01       	movw	r24, r28
     624:	49 96       	adiw	r24, 0x19	; 25
     626:	0e 94 aa 04 	call	0x954	; 0x954 <__pack_f>
     62a:	a0 96       	adiw	r28, 0x20	; 32
     62c:	e2 e1       	ldi	r30, 0x12	; 18
     62e:	0c 94 44 28 	jmp	0x5088	; 0x5088 <__epilogue_restores__>

00000632 <__gtsf2>:
     632:	a8 e1       	ldi	r26, 0x18	; 24
     634:	b0 e0       	ldi	r27, 0x00	; 0
     636:	ef e1       	ldi	r30, 0x1F	; 31
     638:	f3 e0       	ldi	r31, 0x03	; 3
     63a:	0c 94 34 28 	jmp	0x5068	; 0x5068 <__prologue_saves__+0x18>
     63e:	69 83       	std	Y+1, r22	; 0x01
     640:	7a 83       	std	Y+2, r23	; 0x02
     642:	8b 83       	std	Y+3, r24	; 0x03
     644:	9c 83       	std	Y+4, r25	; 0x04
     646:	2d 83       	std	Y+5, r18	; 0x05
     648:	3e 83       	std	Y+6, r19	; 0x06
     64a:	4f 83       	std	Y+7, r20	; 0x07
     64c:	58 87       	std	Y+8, r21	; 0x08
     64e:	89 e0       	ldi	r24, 0x09	; 9
     650:	e8 2e       	mov	r14, r24
     652:	f1 2c       	mov	r15, r1
     654:	ec 0e       	add	r14, r28
     656:	fd 1e       	adc	r15, r29
     658:	ce 01       	movw	r24, r28
     65a:	01 96       	adiw	r24, 0x01	; 1
     65c:	b7 01       	movw	r22, r14
     65e:	0e 94 7f 05 	call	0xafe	; 0xafe <__unpack_f>
     662:	8e 01       	movw	r16, r28
     664:	0f 5e       	subi	r16, 0xEF	; 239
     666:	1f 4f       	sbci	r17, 0xFF	; 255
     668:	ce 01       	movw	r24, r28
     66a:	05 96       	adiw	r24, 0x05	; 5
     66c:	b8 01       	movw	r22, r16
     66e:	0e 94 7f 05 	call	0xafe	; 0xafe <__unpack_f>
     672:	89 85       	ldd	r24, Y+9	; 0x09
     674:	82 30       	cpi	r24, 0x02	; 2
     676:	40 f0       	brcs	.+16     	; 0x688 <__gtsf2+0x56>
     678:	89 89       	ldd	r24, Y+17	; 0x11
     67a:	82 30       	cpi	r24, 0x02	; 2
     67c:	28 f0       	brcs	.+10     	; 0x688 <__gtsf2+0x56>
     67e:	c7 01       	movw	r24, r14
     680:	b8 01       	movw	r22, r16
     682:	0e 94 f7 05 	call	0xbee	; 0xbee <__fpcmp_parts_f>
     686:	01 c0       	rjmp	.+2      	; 0x68a <__gtsf2+0x58>
     688:	8f ef       	ldi	r24, 0xFF	; 255
     68a:	68 96       	adiw	r28, 0x18	; 24
     68c:	e6 e0       	ldi	r30, 0x06	; 6
     68e:	0c 94 50 28 	jmp	0x50a0	; 0x50a0 <__epilogue_restores__+0x18>

00000692 <__gesf2>:
     692:	a8 e1       	ldi	r26, 0x18	; 24
     694:	b0 e0       	ldi	r27, 0x00	; 0
     696:	ef e4       	ldi	r30, 0x4F	; 79
     698:	f3 e0       	ldi	r31, 0x03	; 3
     69a:	0c 94 34 28 	jmp	0x5068	; 0x5068 <__prologue_saves__+0x18>
     69e:	69 83       	std	Y+1, r22	; 0x01
     6a0:	7a 83       	std	Y+2, r23	; 0x02
     6a2:	8b 83       	std	Y+3, r24	; 0x03
     6a4:	9c 83       	std	Y+4, r25	; 0x04
     6a6:	2d 83       	std	Y+5, r18	; 0x05
     6a8:	3e 83       	std	Y+6, r19	; 0x06
     6aa:	4f 83       	std	Y+7, r20	; 0x07
     6ac:	58 87       	std	Y+8, r21	; 0x08
     6ae:	89 e0       	ldi	r24, 0x09	; 9
     6b0:	e8 2e       	mov	r14, r24
     6b2:	f1 2c       	mov	r15, r1
     6b4:	ec 0e       	add	r14, r28
     6b6:	fd 1e       	adc	r15, r29
     6b8:	ce 01       	movw	r24, r28
     6ba:	01 96       	adiw	r24, 0x01	; 1
     6bc:	b7 01       	movw	r22, r14
     6be:	0e 94 7f 05 	call	0xafe	; 0xafe <__unpack_f>
     6c2:	8e 01       	movw	r16, r28
     6c4:	0f 5e       	subi	r16, 0xEF	; 239
     6c6:	1f 4f       	sbci	r17, 0xFF	; 255
     6c8:	ce 01       	movw	r24, r28
     6ca:	05 96       	adiw	r24, 0x05	; 5
     6cc:	b8 01       	movw	r22, r16
     6ce:	0e 94 7f 05 	call	0xafe	; 0xafe <__unpack_f>
     6d2:	89 85       	ldd	r24, Y+9	; 0x09
     6d4:	82 30       	cpi	r24, 0x02	; 2
     6d6:	40 f0       	brcs	.+16     	; 0x6e8 <__gesf2+0x56>
     6d8:	89 89       	ldd	r24, Y+17	; 0x11
     6da:	82 30       	cpi	r24, 0x02	; 2
     6dc:	28 f0       	brcs	.+10     	; 0x6e8 <__gesf2+0x56>
     6de:	c7 01       	movw	r24, r14
     6e0:	b8 01       	movw	r22, r16
     6e2:	0e 94 f7 05 	call	0xbee	; 0xbee <__fpcmp_parts_f>
     6e6:	01 c0       	rjmp	.+2      	; 0x6ea <__gesf2+0x58>
     6e8:	8f ef       	ldi	r24, 0xFF	; 255
     6ea:	68 96       	adiw	r28, 0x18	; 24
     6ec:	e6 e0       	ldi	r30, 0x06	; 6
     6ee:	0c 94 50 28 	jmp	0x50a0	; 0x50a0 <__epilogue_restores__+0x18>

000006f2 <__ltsf2>:
     6f2:	a8 e1       	ldi	r26, 0x18	; 24
     6f4:	b0 e0       	ldi	r27, 0x00	; 0
     6f6:	ef e7       	ldi	r30, 0x7F	; 127
     6f8:	f3 e0       	ldi	r31, 0x03	; 3
     6fa:	0c 94 34 28 	jmp	0x5068	; 0x5068 <__prologue_saves__+0x18>
     6fe:	69 83       	std	Y+1, r22	; 0x01
     700:	7a 83       	std	Y+2, r23	; 0x02
     702:	8b 83       	std	Y+3, r24	; 0x03
     704:	9c 83       	std	Y+4, r25	; 0x04
     706:	2d 83       	std	Y+5, r18	; 0x05
     708:	3e 83       	std	Y+6, r19	; 0x06
     70a:	4f 83       	std	Y+7, r20	; 0x07
     70c:	58 87       	std	Y+8, r21	; 0x08
     70e:	89 e0       	ldi	r24, 0x09	; 9
     710:	e8 2e       	mov	r14, r24
     712:	f1 2c       	mov	r15, r1
     714:	ec 0e       	add	r14, r28
     716:	fd 1e       	adc	r15, r29
     718:	ce 01       	movw	r24, r28
     71a:	01 96       	adiw	r24, 0x01	; 1
     71c:	b7 01       	movw	r22, r14
     71e:	0e 94 7f 05 	call	0xafe	; 0xafe <__unpack_f>
     722:	8e 01       	movw	r16, r28
     724:	0f 5e       	subi	r16, 0xEF	; 239
     726:	1f 4f       	sbci	r17, 0xFF	; 255
     728:	ce 01       	movw	r24, r28
     72a:	05 96       	adiw	r24, 0x05	; 5
     72c:	b8 01       	movw	r22, r16
     72e:	0e 94 7f 05 	call	0xafe	; 0xafe <__unpack_f>
     732:	89 85       	ldd	r24, Y+9	; 0x09
     734:	82 30       	cpi	r24, 0x02	; 2
     736:	40 f0       	brcs	.+16     	; 0x748 <__ltsf2+0x56>
     738:	89 89       	ldd	r24, Y+17	; 0x11
     73a:	82 30       	cpi	r24, 0x02	; 2
     73c:	28 f0       	brcs	.+10     	; 0x748 <__ltsf2+0x56>
     73e:	c7 01       	movw	r24, r14
     740:	b8 01       	movw	r22, r16
     742:	0e 94 f7 05 	call	0xbee	; 0xbee <__fpcmp_parts_f>
     746:	01 c0       	rjmp	.+2      	; 0x74a <__ltsf2+0x58>
     748:	81 e0       	ldi	r24, 0x01	; 1
     74a:	68 96       	adiw	r28, 0x18	; 24
     74c:	e6 e0       	ldi	r30, 0x06	; 6
     74e:	0c 94 50 28 	jmp	0x50a0	; 0x50a0 <__epilogue_restores__+0x18>

00000752 <__floatsisf>:
     752:	a8 e0       	ldi	r26, 0x08	; 8
     754:	b0 e0       	ldi	r27, 0x00	; 0
     756:	ef ea       	ldi	r30, 0xAF	; 175
     758:	f3 e0       	ldi	r31, 0x03	; 3
     75a:	0c 94 31 28 	jmp	0x5062	; 0x5062 <__prologue_saves__+0x12>
     75e:	9b 01       	movw	r18, r22
     760:	ac 01       	movw	r20, r24
     762:	83 e0       	ldi	r24, 0x03	; 3
     764:	89 83       	std	Y+1, r24	; 0x01
     766:	da 01       	movw	r26, r20
     768:	c9 01       	movw	r24, r18
     76a:	88 27       	eor	r24, r24
     76c:	b7 fd       	sbrc	r27, 7
     76e:	83 95       	inc	r24
     770:	99 27       	eor	r25, r25
     772:	aa 27       	eor	r26, r26
     774:	bb 27       	eor	r27, r27
     776:	b8 2e       	mov	r11, r24
     778:	21 15       	cp	r18, r1
     77a:	31 05       	cpc	r19, r1
     77c:	41 05       	cpc	r20, r1
     77e:	51 05       	cpc	r21, r1
     780:	19 f4       	brne	.+6      	; 0x788 <__floatsisf+0x36>
     782:	82 e0       	ldi	r24, 0x02	; 2
     784:	89 83       	std	Y+1, r24	; 0x01
     786:	3a c0       	rjmp	.+116    	; 0x7fc <__floatsisf+0xaa>
     788:	88 23       	and	r24, r24
     78a:	a9 f0       	breq	.+42     	; 0x7b6 <__floatsisf+0x64>
     78c:	20 30       	cpi	r18, 0x00	; 0
     78e:	80 e0       	ldi	r24, 0x00	; 0
     790:	38 07       	cpc	r19, r24
     792:	80 e0       	ldi	r24, 0x00	; 0
     794:	48 07       	cpc	r20, r24
     796:	80 e8       	ldi	r24, 0x80	; 128
     798:	58 07       	cpc	r21, r24
     79a:	29 f4       	brne	.+10     	; 0x7a6 <__floatsisf+0x54>
     79c:	60 e0       	ldi	r22, 0x00	; 0
     79e:	70 e0       	ldi	r23, 0x00	; 0
     7a0:	80 e0       	ldi	r24, 0x00	; 0
     7a2:	9f ec       	ldi	r25, 0xCF	; 207
     7a4:	30 c0       	rjmp	.+96     	; 0x806 <__floatsisf+0xb4>
     7a6:	ee 24       	eor	r14, r14
     7a8:	ff 24       	eor	r15, r15
     7aa:	87 01       	movw	r16, r14
     7ac:	e2 1a       	sub	r14, r18
     7ae:	f3 0a       	sbc	r15, r19
     7b0:	04 0b       	sbc	r16, r20
     7b2:	15 0b       	sbc	r17, r21
     7b4:	02 c0       	rjmp	.+4      	; 0x7ba <__floatsisf+0x68>
     7b6:	79 01       	movw	r14, r18
     7b8:	8a 01       	movw	r16, r20
     7ba:	8e e1       	ldi	r24, 0x1E	; 30
     7bc:	c8 2e       	mov	r12, r24
     7be:	d1 2c       	mov	r13, r1
     7c0:	dc 82       	std	Y+4, r13	; 0x04
     7c2:	cb 82       	std	Y+3, r12	; 0x03
     7c4:	ed 82       	std	Y+5, r14	; 0x05
     7c6:	fe 82       	std	Y+6, r15	; 0x06
     7c8:	0f 83       	std	Y+7, r16	; 0x07
     7ca:	18 87       	std	Y+8, r17	; 0x08
     7cc:	c8 01       	movw	r24, r16
     7ce:	b7 01       	movw	r22, r14
     7d0:	0e 94 5b 04 	call	0x8b6	; 0x8b6 <__clzsi2>
     7d4:	01 97       	sbiw	r24, 0x01	; 1
     7d6:	18 16       	cp	r1, r24
     7d8:	19 06       	cpc	r1, r25
     7da:	84 f4       	brge	.+32     	; 0x7fc <__floatsisf+0xaa>
     7dc:	08 2e       	mov	r0, r24
     7de:	04 c0       	rjmp	.+8      	; 0x7e8 <__floatsisf+0x96>
     7e0:	ee 0c       	add	r14, r14
     7e2:	ff 1c       	adc	r15, r15
     7e4:	00 1f       	adc	r16, r16
     7e6:	11 1f       	adc	r17, r17
     7e8:	0a 94       	dec	r0
     7ea:	d2 f7       	brpl	.-12     	; 0x7e0 <__floatsisf+0x8e>
     7ec:	ed 82       	std	Y+5, r14	; 0x05
     7ee:	fe 82       	std	Y+6, r15	; 0x06
     7f0:	0f 83       	std	Y+7, r16	; 0x07
     7f2:	18 87       	std	Y+8, r17	; 0x08
     7f4:	c8 1a       	sub	r12, r24
     7f6:	d9 0a       	sbc	r13, r25
     7f8:	dc 82       	std	Y+4, r13	; 0x04
     7fa:	cb 82       	std	Y+3, r12	; 0x03
     7fc:	ba 82       	std	Y+2, r11	; 0x02
     7fe:	ce 01       	movw	r24, r28
     800:	01 96       	adiw	r24, 0x01	; 1
     802:	0e 94 aa 04 	call	0x954	; 0x954 <__pack_f>
     806:	28 96       	adiw	r28, 0x08	; 8
     808:	e9 e0       	ldi	r30, 0x09	; 9
     80a:	0c 94 4d 28 	jmp	0x509a	; 0x509a <__epilogue_restores__+0x12>

0000080e <__fixsfsi>:
     80e:	ac e0       	ldi	r26, 0x0C	; 12
     810:	b0 e0       	ldi	r27, 0x00	; 0
     812:	ed e0       	ldi	r30, 0x0D	; 13
     814:	f4 e0       	ldi	r31, 0x04	; 4
     816:	0c 94 38 28 	jmp	0x5070	; 0x5070 <__prologue_saves__+0x20>
     81a:	69 83       	std	Y+1, r22	; 0x01
     81c:	7a 83       	std	Y+2, r23	; 0x02
     81e:	8b 83       	std	Y+3, r24	; 0x03
     820:	9c 83       	std	Y+4, r25	; 0x04
     822:	ce 01       	movw	r24, r28
     824:	01 96       	adiw	r24, 0x01	; 1
     826:	be 01       	movw	r22, r28
     828:	6b 5f       	subi	r22, 0xFB	; 251
     82a:	7f 4f       	sbci	r23, 0xFF	; 255
     82c:	0e 94 7f 05 	call	0xafe	; 0xafe <__unpack_f>
     830:	8d 81       	ldd	r24, Y+5	; 0x05
     832:	82 30       	cpi	r24, 0x02	; 2
     834:	61 f1       	breq	.+88     	; 0x88e <__fixsfsi+0x80>
     836:	82 30       	cpi	r24, 0x02	; 2
     838:	50 f1       	brcs	.+84     	; 0x88e <__fixsfsi+0x80>
     83a:	84 30       	cpi	r24, 0x04	; 4
     83c:	21 f4       	brne	.+8      	; 0x846 <__fixsfsi+0x38>
     83e:	8e 81       	ldd	r24, Y+6	; 0x06
     840:	88 23       	and	r24, r24
     842:	51 f1       	breq	.+84     	; 0x898 <__fixsfsi+0x8a>
     844:	2e c0       	rjmp	.+92     	; 0x8a2 <__fixsfsi+0x94>
     846:	2f 81       	ldd	r18, Y+7	; 0x07
     848:	38 85       	ldd	r19, Y+8	; 0x08
     84a:	37 fd       	sbrc	r19, 7
     84c:	20 c0       	rjmp	.+64     	; 0x88e <__fixsfsi+0x80>
     84e:	6e 81       	ldd	r22, Y+6	; 0x06
     850:	2f 31       	cpi	r18, 0x1F	; 31
     852:	31 05       	cpc	r19, r1
     854:	1c f0       	brlt	.+6      	; 0x85c <__fixsfsi+0x4e>
     856:	66 23       	and	r22, r22
     858:	f9 f0       	breq	.+62     	; 0x898 <__fixsfsi+0x8a>
     85a:	23 c0       	rjmp	.+70     	; 0x8a2 <__fixsfsi+0x94>
     85c:	8e e1       	ldi	r24, 0x1E	; 30
     85e:	90 e0       	ldi	r25, 0x00	; 0
     860:	82 1b       	sub	r24, r18
     862:	93 0b       	sbc	r25, r19
     864:	29 85       	ldd	r18, Y+9	; 0x09
     866:	3a 85       	ldd	r19, Y+10	; 0x0a
     868:	4b 85       	ldd	r20, Y+11	; 0x0b
     86a:	5c 85       	ldd	r21, Y+12	; 0x0c
     86c:	04 c0       	rjmp	.+8      	; 0x876 <__fixsfsi+0x68>
     86e:	56 95       	lsr	r21
     870:	47 95       	ror	r20
     872:	37 95       	ror	r19
     874:	27 95       	ror	r18
     876:	8a 95       	dec	r24
     878:	d2 f7       	brpl	.-12     	; 0x86e <__fixsfsi+0x60>
     87a:	66 23       	and	r22, r22
     87c:	b1 f0       	breq	.+44     	; 0x8aa <__fixsfsi+0x9c>
     87e:	50 95       	com	r21
     880:	40 95       	com	r20
     882:	30 95       	com	r19
     884:	21 95       	neg	r18
     886:	3f 4f       	sbci	r19, 0xFF	; 255
     888:	4f 4f       	sbci	r20, 0xFF	; 255
     88a:	5f 4f       	sbci	r21, 0xFF	; 255
     88c:	0e c0       	rjmp	.+28     	; 0x8aa <__fixsfsi+0x9c>
     88e:	20 e0       	ldi	r18, 0x00	; 0
     890:	30 e0       	ldi	r19, 0x00	; 0
     892:	40 e0       	ldi	r20, 0x00	; 0
     894:	50 e0       	ldi	r21, 0x00	; 0
     896:	09 c0       	rjmp	.+18     	; 0x8aa <__fixsfsi+0x9c>
     898:	2f ef       	ldi	r18, 0xFF	; 255
     89a:	3f ef       	ldi	r19, 0xFF	; 255
     89c:	4f ef       	ldi	r20, 0xFF	; 255
     89e:	5f e7       	ldi	r21, 0x7F	; 127
     8a0:	04 c0       	rjmp	.+8      	; 0x8aa <__fixsfsi+0x9c>
     8a2:	20 e0       	ldi	r18, 0x00	; 0
     8a4:	30 e0       	ldi	r19, 0x00	; 0
     8a6:	40 e0       	ldi	r20, 0x00	; 0
     8a8:	50 e8       	ldi	r21, 0x80	; 128
     8aa:	b9 01       	movw	r22, r18
     8ac:	ca 01       	movw	r24, r20
     8ae:	2c 96       	adiw	r28, 0x0c	; 12
     8b0:	e2 e0       	ldi	r30, 0x02	; 2
     8b2:	0c 94 54 28 	jmp	0x50a8	; 0x50a8 <__epilogue_restores__+0x20>

000008b6 <__clzsi2>:
     8b6:	ef 92       	push	r14
     8b8:	ff 92       	push	r15
     8ba:	0f 93       	push	r16
     8bc:	1f 93       	push	r17
     8be:	7b 01       	movw	r14, r22
     8c0:	8c 01       	movw	r16, r24
     8c2:	80 e0       	ldi	r24, 0x00	; 0
     8c4:	e8 16       	cp	r14, r24
     8c6:	80 e0       	ldi	r24, 0x00	; 0
     8c8:	f8 06       	cpc	r15, r24
     8ca:	81 e0       	ldi	r24, 0x01	; 1
     8cc:	08 07       	cpc	r16, r24
     8ce:	80 e0       	ldi	r24, 0x00	; 0
     8d0:	18 07       	cpc	r17, r24
     8d2:	88 f4       	brcc	.+34     	; 0x8f6 <__clzsi2+0x40>
     8d4:	8f ef       	ldi	r24, 0xFF	; 255
     8d6:	e8 16       	cp	r14, r24
     8d8:	f1 04       	cpc	r15, r1
     8da:	01 05       	cpc	r16, r1
     8dc:	11 05       	cpc	r17, r1
     8de:	31 f0       	breq	.+12     	; 0x8ec <__clzsi2+0x36>
     8e0:	28 f0       	brcs	.+10     	; 0x8ec <__clzsi2+0x36>
     8e2:	88 e0       	ldi	r24, 0x08	; 8
     8e4:	90 e0       	ldi	r25, 0x00	; 0
     8e6:	a0 e0       	ldi	r26, 0x00	; 0
     8e8:	b0 e0       	ldi	r27, 0x00	; 0
     8ea:	17 c0       	rjmp	.+46     	; 0x91a <__clzsi2+0x64>
     8ec:	80 e0       	ldi	r24, 0x00	; 0
     8ee:	90 e0       	ldi	r25, 0x00	; 0
     8f0:	a0 e0       	ldi	r26, 0x00	; 0
     8f2:	b0 e0       	ldi	r27, 0x00	; 0
     8f4:	12 c0       	rjmp	.+36     	; 0x91a <__clzsi2+0x64>
     8f6:	80 e0       	ldi	r24, 0x00	; 0
     8f8:	e8 16       	cp	r14, r24
     8fa:	80 e0       	ldi	r24, 0x00	; 0
     8fc:	f8 06       	cpc	r15, r24
     8fe:	80 e0       	ldi	r24, 0x00	; 0
     900:	08 07       	cpc	r16, r24
     902:	81 e0       	ldi	r24, 0x01	; 1
     904:	18 07       	cpc	r17, r24
     906:	28 f0       	brcs	.+10     	; 0x912 <__clzsi2+0x5c>
     908:	88 e1       	ldi	r24, 0x18	; 24
     90a:	90 e0       	ldi	r25, 0x00	; 0
     90c:	a0 e0       	ldi	r26, 0x00	; 0
     90e:	b0 e0       	ldi	r27, 0x00	; 0
     910:	04 c0       	rjmp	.+8      	; 0x91a <__clzsi2+0x64>
     912:	80 e1       	ldi	r24, 0x10	; 16
     914:	90 e0       	ldi	r25, 0x00	; 0
     916:	a0 e0       	ldi	r26, 0x00	; 0
     918:	b0 e0       	ldi	r27, 0x00	; 0
     91a:	20 e2       	ldi	r18, 0x20	; 32
     91c:	30 e0       	ldi	r19, 0x00	; 0
     91e:	40 e0       	ldi	r20, 0x00	; 0
     920:	50 e0       	ldi	r21, 0x00	; 0
     922:	28 1b       	sub	r18, r24
     924:	39 0b       	sbc	r19, r25
     926:	4a 0b       	sbc	r20, r26
     928:	5b 0b       	sbc	r21, r27
     92a:	04 c0       	rjmp	.+8      	; 0x934 <__clzsi2+0x7e>
     92c:	16 95       	lsr	r17
     92e:	07 95       	ror	r16
     930:	f7 94       	ror	r15
     932:	e7 94       	ror	r14
     934:	8a 95       	dec	r24
     936:	d2 f7       	brpl	.-12     	; 0x92c <__clzsi2+0x76>
     938:	f7 01       	movw	r30, r14
     93a:	e2 57       	subi	r30, 0x72	; 114
     93c:	ff 4f       	sbci	r31, 0xFF	; 255
     93e:	80 81       	ld	r24, Z
     940:	28 1b       	sub	r18, r24
     942:	31 09       	sbc	r19, r1
     944:	41 09       	sbc	r20, r1
     946:	51 09       	sbc	r21, r1
     948:	c9 01       	movw	r24, r18
     94a:	1f 91       	pop	r17
     94c:	0f 91       	pop	r16
     94e:	ff 90       	pop	r15
     950:	ef 90       	pop	r14
     952:	08 95       	ret

00000954 <__pack_f>:
     954:	df 92       	push	r13
     956:	ef 92       	push	r14
     958:	ff 92       	push	r15
     95a:	0f 93       	push	r16
     95c:	1f 93       	push	r17
     95e:	fc 01       	movw	r30, r24
     960:	e4 80       	ldd	r14, Z+4	; 0x04
     962:	f5 80       	ldd	r15, Z+5	; 0x05
     964:	06 81       	ldd	r16, Z+6	; 0x06
     966:	17 81       	ldd	r17, Z+7	; 0x07
     968:	d1 80       	ldd	r13, Z+1	; 0x01
     96a:	80 81       	ld	r24, Z
     96c:	82 30       	cpi	r24, 0x02	; 2
     96e:	48 f4       	brcc	.+18     	; 0x982 <__pack_f+0x2e>
     970:	80 e0       	ldi	r24, 0x00	; 0
     972:	90 e0       	ldi	r25, 0x00	; 0
     974:	a0 e1       	ldi	r26, 0x10	; 16
     976:	b0 e0       	ldi	r27, 0x00	; 0
     978:	e8 2a       	or	r14, r24
     97a:	f9 2a       	or	r15, r25
     97c:	0a 2b       	or	r16, r26
     97e:	1b 2b       	or	r17, r27
     980:	a5 c0       	rjmp	.+330    	; 0xacc <__pack_f+0x178>
     982:	84 30       	cpi	r24, 0x04	; 4
     984:	09 f4       	brne	.+2      	; 0x988 <__pack_f+0x34>
     986:	9f c0       	rjmp	.+318    	; 0xac6 <__pack_f+0x172>
     988:	82 30       	cpi	r24, 0x02	; 2
     98a:	21 f4       	brne	.+8      	; 0x994 <__pack_f+0x40>
     98c:	ee 24       	eor	r14, r14
     98e:	ff 24       	eor	r15, r15
     990:	87 01       	movw	r16, r14
     992:	05 c0       	rjmp	.+10     	; 0x99e <__pack_f+0x4a>
     994:	e1 14       	cp	r14, r1
     996:	f1 04       	cpc	r15, r1
     998:	01 05       	cpc	r16, r1
     99a:	11 05       	cpc	r17, r1
     99c:	19 f4       	brne	.+6      	; 0x9a4 <__pack_f+0x50>
     99e:	e0 e0       	ldi	r30, 0x00	; 0
     9a0:	f0 e0       	ldi	r31, 0x00	; 0
     9a2:	96 c0       	rjmp	.+300    	; 0xad0 <__pack_f+0x17c>
     9a4:	62 81       	ldd	r22, Z+2	; 0x02
     9a6:	73 81       	ldd	r23, Z+3	; 0x03
     9a8:	9f ef       	ldi	r25, 0xFF	; 255
     9aa:	62 38       	cpi	r22, 0x82	; 130
     9ac:	79 07       	cpc	r23, r25
     9ae:	0c f0       	brlt	.+2      	; 0x9b2 <__pack_f+0x5e>
     9b0:	5b c0       	rjmp	.+182    	; 0xa68 <__pack_f+0x114>
     9b2:	22 e8       	ldi	r18, 0x82	; 130
     9b4:	3f ef       	ldi	r19, 0xFF	; 255
     9b6:	26 1b       	sub	r18, r22
     9b8:	37 0b       	sbc	r19, r23
     9ba:	2a 31       	cpi	r18, 0x1A	; 26
     9bc:	31 05       	cpc	r19, r1
     9be:	2c f0       	brlt	.+10     	; 0x9ca <__pack_f+0x76>
     9c0:	20 e0       	ldi	r18, 0x00	; 0
     9c2:	30 e0       	ldi	r19, 0x00	; 0
     9c4:	40 e0       	ldi	r20, 0x00	; 0
     9c6:	50 e0       	ldi	r21, 0x00	; 0
     9c8:	2a c0       	rjmp	.+84     	; 0xa1e <__pack_f+0xca>
     9ca:	b8 01       	movw	r22, r16
     9cc:	a7 01       	movw	r20, r14
     9ce:	02 2e       	mov	r0, r18
     9d0:	04 c0       	rjmp	.+8      	; 0x9da <__pack_f+0x86>
     9d2:	76 95       	lsr	r23
     9d4:	67 95       	ror	r22
     9d6:	57 95       	ror	r21
     9d8:	47 95       	ror	r20
     9da:	0a 94       	dec	r0
     9dc:	d2 f7       	brpl	.-12     	; 0x9d2 <__pack_f+0x7e>
     9de:	81 e0       	ldi	r24, 0x01	; 1
     9e0:	90 e0       	ldi	r25, 0x00	; 0
     9e2:	a0 e0       	ldi	r26, 0x00	; 0
     9e4:	b0 e0       	ldi	r27, 0x00	; 0
     9e6:	04 c0       	rjmp	.+8      	; 0x9f0 <__pack_f+0x9c>
     9e8:	88 0f       	add	r24, r24
     9ea:	99 1f       	adc	r25, r25
     9ec:	aa 1f       	adc	r26, r26
     9ee:	bb 1f       	adc	r27, r27
     9f0:	2a 95       	dec	r18
     9f2:	d2 f7       	brpl	.-12     	; 0x9e8 <__pack_f+0x94>
     9f4:	01 97       	sbiw	r24, 0x01	; 1
     9f6:	a1 09       	sbc	r26, r1
     9f8:	b1 09       	sbc	r27, r1
     9fa:	8e 21       	and	r24, r14
     9fc:	9f 21       	and	r25, r15
     9fe:	a0 23       	and	r26, r16
     a00:	b1 23       	and	r27, r17
     a02:	00 97       	sbiw	r24, 0x00	; 0
     a04:	a1 05       	cpc	r26, r1
     a06:	b1 05       	cpc	r27, r1
     a08:	21 f0       	breq	.+8      	; 0xa12 <__pack_f+0xbe>
     a0a:	81 e0       	ldi	r24, 0x01	; 1
     a0c:	90 e0       	ldi	r25, 0x00	; 0
     a0e:	a0 e0       	ldi	r26, 0x00	; 0
     a10:	b0 e0       	ldi	r27, 0x00	; 0
     a12:	9a 01       	movw	r18, r20
     a14:	ab 01       	movw	r20, r22
     a16:	28 2b       	or	r18, r24
     a18:	39 2b       	or	r19, r25
     a1a:	4a 2b       	or	r20, r26
     a1c:	5b 2b       	or	r21, r27
     a1e:	da 01       	movw	r26, r20
     a20:	c9 01       	movw	r24, r18
     a22:	8f 77       	andi	r24, 0x7F	; 127
     a24:	90 70       	andi	r25, 0x00	; 0
     a26:	a0 70       	andi	r26, 0x00	; 0
     a28:	b0 70       	andi	r27, 0x00	; 0
     a2a:	80 34       	cpi	r24, 0x40	; 64
     a2c:	91 05       	cpc	r25, r1
     a2e:	a1 05       	cpc	r26, r1
     a30:	b1 05       	cpc	r27, r1
     a32:	39 f4       	brne	.+14     	; 0xa42 <__pack_f+0xee>
     a34:	27 ff       	sbrs	r18, 7
     a36:	09 c0       	rjmp	.+18     	; 0xa4a <__pack_f+0xf6>
     a38:	20 5c       	subi	r18, 0xC0	; 192
     a3a:	3f 4f       	sbci	r19, 0xFF	; 255
     a3c:	4f 4f       	sbci	r20, 0xFF	; 255
     a3e:	5f 4f       	sbci	r21, 0xFF	; 255
     a40:	04 c0       	rjmp	.+8      	; 0xa4a <__pack_f+0xf6>
     a42:	21 5c       	subi	r18, 0xC1	; 193
     a44:	3f 4f       	sbci	r19, 0xFF	; 255
     a46:	4f 4f       	sbci	r20, 0xFF	; 255
     a48:	5f 4f       	sbci	r21, 0xFF	; 255
     a4a:	e0 e0       	ldi	r30, 0x00	; 0
     a4c:	f0 e0       	ldi	r31, 0x00	; 0
     a4e:	20 30       	cpi	r18, 0x00	; 0
     a50:	a0 e0       	ldi	r26, 0x00	; 0
     a52:	3a 07       	cpc	r19, r26
     a54:	a0 e0       	ldi	r26, 0x00	; 0
     a56:	4a 07       	cpc	r20, r26
     a58:	a0 e4       	ldi	r26, 0x40	; 64
     a5a:	5a 07       	cpc	r21, r26
     a5c:	10 f0       	brcs	.+4      	; 0xa62 <__pack_f+0x10e>
     a5e:	e1 e0       	ldi	r30, 0x01	; 1
     a60:	f0 e0       	ldi	r31, 0x00	; 0
     a62:	79 01       	movw	r14, r18
     a64:	8a 01       	movw	r16, r20
     a66:	27 c0       	rjmp	.+78     	; 0xab6 <__pack_f+0x162>
     a68:	60 38       	cpi	r22, 0x80	; 128
     a6a:	71 05       	cpc	r23, r1
     a6c:	64 f5       	brge	.+88     	; 0xac6 <__pack_f+0x172>
     a6e:	fb 01       	movw	r30, r22
     a70:	e1 58       	subi	r30, 0x81	; 129
     a72:	ff 4f       	sbci	r31, 0xFF	; 255
     a74:	d8 01       	movw	r26, r16
     a76:	c7 01       	movw	r24, r14
     a78:	8f 77       	andi	r24, 0x7F	; 127
     a7a:	90 70       	andi	r25, 0x00	; 0
     a7c:	a0 70       	andi	r26, 0x00	; 0
     a7e:	b0 70       	andi	r27, 0x00	; 0
     a80:	80 34       	cpi	r24, 0x40	; 64
     a82:	91 05       	cpc	r25, r1
     a84:	a1 05       	cpc	r26, r1
     a86:	b1 05       	cpc	r27, r1
     a88:	39 f4       	brne	.+14     	; 0xa98 <__pack_f+0x144>
     a8a:	e7 fe       	sbrs	r14, 7
     a8c:	0d c0       	rjmp	.+26     	; 0xaa8 <__pack_f+0x154>
     a8e:	80 e4       	ldi	r24, 0x40	; 64
     a90:	90 e0       	ldi	r25, 0x00	; 0
     a92:	a0 e0       	ldi	r26, 0x00	; 0
     a94:	b0 e0       	ldi	r27, 0x00	; 0
     a96:	04 c0       	rjmp	.+8      	; 0xaa0 <__pack_f+0x14c>
     a98:	8f e3       	ldi	r24, 0x3F	; 63
     a9a:	90 e0       	ldi	r25, 0x00	; 0
     a9c:	a0 e0       	ldi	r26, 0x00	; 0
     a9e:	b0 e0       	ldi	r27, 0x00	; 0
     aa0:	e8 0e       	add	r14, r24
     aa2:	f9 1e       	adc	r15, r25
     aa4:	0a 1f       	adc	r16, r26
     aa6:	1b 1f       	adc	r17, r27
     aa8:	17 ff       	sbrs	r17, 7
     aaa:	05 c0       	rjmp	.+10     	; 0xab6 <__pack_f+0x162>
     aac:	16 95       	lsr	r17
     aae:	07 95       	ror	r16
     ab0:	f7 94       	ror	r15
     ab2:	e7 94       	ror	r14
     ab4:	31 96       	adiw	r30, 0x01	; 1
     ab6:	87 e0       	ldi	r24, 0x07	; 7
     ab8:	16 95       	lsr	r17
     aba:	07 95       	ror	r16
     abc:	f7 94       	ror	r15
     abe:	e7 94       	ror	r14
     ac0:	8a 95       	dec	r24
     ac2:	d1 f7       	brne	.-12     	; 0xab8 <__pack_f+0x164>
     ac4:	05 c0       	rjmp	.+10     	; 0xad0 <__pack_f+0x17c>
     ac6:	ee 24       	eor	r14, r14
     ac8:	ff 24       	eor	r15, r15
     aca:	87 01       	movw	r16, r14
     acc:	ef ef       	ldi	r30, 0xFF	; 255
     ace:	f0 e0       	ldi	r31, 0x00	; 0
     ad0:	6e 2f       	mov	r22, r30
     ad2:	67 95       	ror	r22
     ad4:	66 27       	eor	r22, r22
     ad6:	67 95       	ror	r22
     ad8:	90 2f       	mov	r25, r16
     ada:	9f 77       	andi	r25, 0x7F	; 127
     adc:	d7 94       	ror	r13
     ade:	dd 24       	eor	r13, r13
     ae0:	d7 94       	ror	r13
     ae2:	8e 2f       	mov	r24, r30
     ae4:	86 95       	lsr	r24
     ae6:	49 2f       	mov	r20, r25
     ae8:	46 2b       	or	r20, r22
     aea:	58 2f       	mov	r21, r24
     aec:	5d 29       	or	r21, r13
     aee:	b7 01       	movw	r22, r14
     af0:	ca 01       	movw	r24, r20
     af2:	1f 91       	pop	r17
     af4:	0f 91       	pop	r16
     af6:	ff 90       	pop	r15
     af8:	ef 90       	pop	r14
     afa:	df 90       	pop	r13
     afc:	08 95       	ret

00000afe <__unpack_f>:
     afe:	fc 01       	movw	r30, r24
     b00:	db 01       	movw	r26, r22
     b02:	40 81       	ld	r20, Z
     b04:	51 81       	ldd	r21, Z+1	; 0x01
     b06:	22 81       	ldd	r18, Z+2	; 0x02
     b08:	62 2f       	mov	r22, r18
     b0a:	6f 77       	andi	r22, 0x7F	; 127
     b0c:	70 e0       	ldi	r23, 0x00	; 0
     b0e:	22 1f       	adc	r18, r18
     b10:	22 27       	eor	r18, r18
     b12:	22 1f       	adc	r18, r18
     b14:	93 81       	ldd	r25, Z+3	; 0x03
     b16:	89 2f       	mov	r24, r25
     b18:	88 0f       	add	r24, r24
     b1a:	82 2b       	or	r24, r18
     b1c:	28 2f       	mov	r18, r24
     b1e:	30 e0       	ldi	r19, 0x00	; 0
     b20:	99 1f       	adc	r25, r25
     b22:	99 27       	eor	r25, r25
     b24:	99 1f       	adc	r25, r25
     b26:	11 96       	adiw	r26, 0x01	; 1
     b28:	9c 93       	st	X, r25
     b2a:	11 97       	sbiw	r26, 0x01	; 1
     b2c:	21 15       	cp	r18, r1
     b2e:	31 05       	cpc	r19, r1
     b30:	a9 f5       	brne	.+106    	; 0xb9c <__unpack_f+0x9e>
     b32:	41 15       	cp	r20, r1
     b34:	51 05       	cpc	r21, r1
     b36:	61 05       	cpc	r22, r1
     b38:	71 05       	cpc	r23, r1
     b3a:	11 f4       	brne	.+4      	; 0xb40 <__unpack_f+0x42>
     b3c:	82 e0       	ldi	r24, 0x02	; 2
     b3e:	37 c0       	rjmp	.+110    	; 0xbae <__unpack_f+0xb0>
     b40:	82 e8       	ldi	r24, 0x82	; 130
     b42:	9f ef       	ldi	r25, 0xFF	; 255
     b44:	13 96       	adiw	r26, 0x03	; 3
     b46:	9c 93       	st	X, r25
     b48:	8e 93       	st	-X, r24
     b4a:	12 97       	sbiw	r26, 0x02	; 2
     b4c:	9a 01       	movw	r18, r20
     b4e:	ab 01       	movw	r20, r22
     b50:	67 e0       	ldi	r22, 0x07	; 7
     b52:	22 0f       	add	r18, r18
     b54:	33 1f       	adc	r19, r19
     b56:	44 1f       	adc	r20, r20
     b58:	55 1f       	adc	r21, r21
     b5a:	6a 95       	dec	r22
     b5c:	d1 f7       	brne	.-12     	; 0xb52 <__unpack_f+0x54>
     b5e:	83 e0       	ldi	r24, 0x03	; 3
     b60:	8c 93       	st	X, r24
     b62:	0d c0       	rjmp	.+26     	; 0xb7e <__unpack_f+0x80>
     b64:	22 0f       	add	r18, r18
     b66:	33 1f       	adc	r19, r19
     b68:	44 1f       	adc	r20, r20
     b6a:	55 1f       	adc	r21, r21
     b6c:	12 96       	adiw	r26, 0x02	; 2
     b6e:	8d 91       	ld	r24, X+
     b70:	9c 91       	ld	r25, X
     b72:	13 97       	sbiw	r26, 0x03	; 3
     b74:	01 97       	sbiw	r24, 0x01	; 1
     b76:	13 96       	adiw	r26, 0x03	; 3
     b78:	9c 93       	st	X, r25
     b7a:	8e 93       	st	-X, r24
     b7c:	12 97       	sbiw	r26, 0x02	; 2
     b7e:	20 30       	cpi	r18, 0x00	; 0
     b80:	80 e0       	ldi	r24, 0x00	; 0
     b82:	38 07       	cpc	r19, r24
     b84:	80 e0       	ldi	r24, 0x00	; 0
     b86:	48 07       	cpc	r20, r24
     b88:	80 e4       	ldi	r24, 0x40	; 64
     b8a:	58 07       	cpc	r21, r24
     b8c:	58 f3       	brcs	.-42     	; 0xb64 <__unpack_f+0x66>
     b8e:	14 96       	adiw	r26, 0x04	; 4
     b90:	2d 93       	st	X+, r18
     b92:	3d 93       	st	X+, r19
     b94:	4d 93       	st	X+, r20
     b96:	5c 93       	st	X, r21
     b98:	17 97       	sbiw	r26, 0x07	; 7
     b9a:	08 95       	ret
     b9c:	2f 3f       	cpi	r18, 0xFF	; 255
     b9e:	31 05       	cpc	r19, r1
     ba0:	79 f4       	brne	.+30     	; 0xbc0 <__unpack_f+0xc2>
     ba2:	41 15       	cp	r20, r1
     ba4:	51 05       	cpc	r21, r1
     ba6:	61 05       	cpc	r22, r1
     ba8:	71 05       	cpc	r23, r1
     baa:	19 f4       	brne	.+6      	; 0xbb2 <__unpack_f+0xb4>
     bac:	84 e0       	ldi	r24, 0x04	; 4
     bae:	8c 93       	st	X, r24
     bb0:	08 95       	ret
     bb2:	64 ff       	sbrs	r22, 4
     bb4:	03 c0       	rjmp	.+6      	; 0xbbc <__unpack_f+0xbe>
     bb6:	81 e0       	ldi	r24, 0x01	; 1
     bb8:	8c 93       	st	X, r24
     bba:	12 c0       	rjmp	.+36     	; 0xbe0 <__unpack_f+0xe2>
     bbc:	1c 92       	st	X, r1
     bbe:	10 c0       	rjmp	.+32     	; 0xbe0 <__unpack_f+0xe2>
     bc0:	2f 57       	subi	r18, 0x7F	; 127
     bc2:	30 40       	sbci	r19, 0x00	; 0
     bc4:	13 96       	adiw	r26, 0x03	; 3
     bc6:	3c 93       	st	X, r19
     bc8:	2e 93       	st	-X, r18
     bca:	12 97       	sbiw	r26, 0x02	; 2
     bcc:	83 e0       	ldi	r24, 0x03	; 3
     bce:	8c 93       	st	X, r24
     bd0:	87 e0       	ldi	r24, 0x07	; 7
     bd2:	44 0f       	add	r20, r20
     bd4:	55 1f       	adc	r21, r21
     bd6:	66 1f       	adc	r22, r22
     bd8:	77 1f       	adc	r23, r23
     bda:	8a 95       	dec	r24
     bdc:	d1 f7       	brne	.-12     	; 0xbd2 <__unpack_f+0xd4>
     bde:	70 64       	ori	r23, 0x40	; 64
     be0:	14 96       	adiw	r26, 0x04	; 4
     be2:	4d 93       	st	X+, r20
     be4:	5d 93       	st	X+, r21
     be6:	6d 93       	st	X+, r22
     be8:	7c 93       	st	X, r23
     bea:	17 97       	sbiw	r26, 0x07	; 7
     bec:	08 95       	ret

00000bee <__fpcmp_parts_f>:
     bee:	1f 93       	push	r17
     bf0:	dc 01       	movw	r26, r24
     bf2:	fb 01       	movw	r30, r22
     bf4:	9c 91       	ld	r25, X
     bf6:	92 30       	cpi	r25, 0x02	; 2
     bf8:	08 f4       	brcc	.+2      	; 0xbfc <__fpcmp_parts_f+0xe>
     bfa:	47 c0       	rjmp	.+142    	; 0xc8a <__fpcmp_parts_f+0x9c>
     bfc:	80 81       	ld	r24, Z
     bfe:	82 30       	cpi	r24, 0x02	; 2
     c00:	08 f4       	brcc	.+2      	; 0xc04 <__fpcmp_parts_f+0x16>
     c02:	43 c0       	rjmp	.+134    	; 0xc8a <__fpcmp_parts_f+0x9c>
     c04:	94 30       	cpi	r25, 0x04	; 4
     c06:	51 f4       	brne	.+20     	; 0xc1c <__fpcmp_parts_f+0x2e>
     c08:	11 96       	adiw	r26, 0x01	; 1
     c0a:	1c 91       	ld	r17, X
     c0c:	84 30       	cpi	r24, 0x04	; 4
     c0e:	99 f5       	brne	.+102    	; 0xc76 <__fpcmp_parts_f+0x88>
     c10:	81 81       	ldd	r24, Z+1	; 0x01
     c12:	68 2f       	mov	r22, r24
     c14:	70 e0       	ldi	r23, 0x00	; 0
     c16:	61 1b       	sub	r22, r17
     c18:	71 09       	sbc	r23, r1
     c1a:	3f c0       	rjmp	.+126    	; 0xc9a <__fpcmp_parts_f+0xac>
     c1c:	84 30       	cpi	r24, 0x04	; 4
     c1e:	21 f0       	breq	.+8      	; 0xc28 <__fpcmp_parts_f+0x3a>
     c20:	92 30       	cpi	r25, 0x02	; 2
     c22:	31 f4       	brne	.+12     	; 0xc30 <__fpcmp_parts_f+0x42>
     c24:	82 30       	cpi	r24, 0x02	; 2
     c26:	b9 f1       	breq	.+110    	; 0xc96 <__fpcmp_parts_f+0xa8>
     c28:	81 81       	ldd	r24, Z+1	; 0x01
     c2a:	88 23       	and	r24, r24
     c2c:	89 f1       	breq	.+98     	; 0xc90 <__fpcmp_parts_f+0xa2>
     c2e:	2d c0       	rjmp	.+90     	; 0xc8a <__fpcmp_parts_f+0x9c>
     c30:	11 96       	adiw	r26, 0x01	; 1
     c32:	1c 91       	ld	r17, X
     c34:	11 97       	sbiw	r26, 0x01	; 1
     c36:	82 30       	cpi	r24, 0x02	; 2
     c38:	f1 f0       	breq	.+60     	; 0xc76 <__fpcmp_parts_f+0x88>
     c3a:	81 81       	ldd	r24, Z+1	; 0x01
     c3c:	18 17       	cp	r17, r24
     c3e:	d9 f4       	brne	.+54     	; 0xc76 <__fpcmp_parts_f+0x88>
     c40:	12 96       	adiw	r26, 0x02	; 2
     c42:	2d 91       	ld	r18, X+
     c44:	3c 91       	ld	r19, X
     c46:	13 97       	sbiw	r26, 0x03	; 3
     c48:	82 81       	ldd	r24, Z+2	; 0x02
     c4a:	93 81       	ldd	r25, Z+3	; 0x03
     c4c:	82 17       	cp	r24, r18
     c4e:	93 07       	cpc	r25, r19
     c50:	94 f0       	brlt	.+36     	; 0xc76 <__fpcmp_parts_f+0x88>
     c52:	28 17       	cp	r18, r24
     c54:	39 07       	cpc	r19, r25
     c56:	bc f0       	brlt	.+46     	; 0xc86 <__fpcmp_parts_f+0x98>
     c58:	14 96       	adiw	r26, 0x04	; 4
     c5a:	8d 91       	ld	r24, X+
     c5c:	9d 91       	ld	r25, X+
     c5e:	0d 90       	ld	r0, X+
     c60:	bc 91       	ld	r27, X
     c62:	a0 2d       	mov	r26, r0
     c64:	24 81       	ldd	r18, Z+4	; 0x04
     c66:	35 81       	ldd	r19, Z+5	; 0x05
     c68:	46 81       	ldd	r20, Z+6	; 0x06
     c6a:	57 81       	ldd	r21, Z+7	; 0x07
     c6c:	28 17       	cp	r18, r24
     c6e:	39 07       	cpc	r19, r25
     c70:	4a 07       	cpc	r20, r26
     c72:	5b 07       	cpc	r21, r27
     c74:	18 f4       	brcc	.+6      	; 0xc7c <__fpcmp_parts_f+0x8e>
     c76:	11 23       	and	r17, r17
     c78:	41 f0       	breq	.+16     	; 0xc8a <__fpcmp_parts_f+0x9c>
     c7a:	0a c0       	rjmp	.+20     	; 0xc90 <__fpcmp_parts_f+0xa2>
     c7c:	82 17       	cp	r24, r18
     c7e:	93 07       	cpc	r25, r19
     c80:	a4 07       	cpc	r26, r20
     c82:	b5 07       	cpc	r27, r21
     c84:	40 f4       	brcc	.+16     	; 0xc96 <__fpcmp_parts_f+0xa8>
     c86:	11 23       	and	r17, r17
     c88:	19 f0       	breq	.+6      	; 0xc90 <__fpcmp_parts_f+0xa2>
     c8a:	61 e0       	ldi	r22, 0x01	; 1
     c8c:	70 e0       	ldi	r23, 0x00	; 0
     c8e:	05 c0       	rjmp	.+10     	; 0xc9a <__fpcmp_parts_f+0xac>
     c90:	6f ef       	ldi	r22, 0xFF	; 255
     c92:	7f ef       	ldi	r23, 0xFF	; 255
     c94:	02 c0       	rjmp	.+4      	; 0xc9a <__fpcmp_parts_f+0xac>
     c96:	60 e0       	ldi	r22, 0x00	; 0
     c98:	70 e0       	ldi	r23, 0x00	; 0
     c9a:	cb 01       	movw	r24, r22
     c9c:	1f 91       	pop	r17
     c9e:	08 95       	ret

00000ca0 <HLCD_VoidSendChar>:
 *
 *					This Function send a character to the LCD
 *
 **********************************************************************/
void HLCD_VoidSendChar(u8 Copy_u8Data)
{
     ca0:	df 93       	push	r29
     ca2:	cf 93       	push	r28
     ca4:	cd b7       	in	r28, 0x3d	; 61
     ca6:	de b7       	in	r29, 0x3e	; 62
     ca8:	6d 97       	sbiw	r28, 0x1d	; 29
     caa:	0f b6       	in	r0, 0x3f	; 63
     cac:	f8 94       	cli
     cae:	de bf       	out	0x3e, r29	; 62
     cb0:	0f be       	out	0x3f, r0	; 63
     cb2:	cd bf       	out	0x3d, r28	; 61
     cb4:	8d 8f       	std	Y+29, r24	; 0x1d
	/*								set RS pin							*/
	MDIO_VoidSetPinValue(HLCD_CONTROL_PORT,HLCD_RS_PIN,DIO_PIN_HIGH);
     cb6:	81 e0       	ldi	r24, 0x01	; 1
     cb8:	60 e0       	ldi	r22, 0x00	; 0
     cba:	41 e0       	ldi	r20, 0x01	; 1
     cbc:	0e 94 21 11 	call	0x2242	; 0x2242 <MDIO_VoidSetPinValue>
	/*								clear RW pin						*/
	/*				here we set the pin value to port B pin 1 to 0v		*/
	MDIO_VoidSetPinValue(HLCD_CONTROL_PORT,HLCD_RW_PIN,DIO_PIN_LOW);
     cc0:	81 e0       	ldi	r24, 0x01	; 1
     cc2:	61 e0       	ldi	r22, 0x01	; 1
     cc4:	40 e0       	ldi	r20, 0x00	; 0
     cc6:	0e 94 21 11 	call	0x2242	; 0x2242 <MDIO_VoidSetPinValue>

	/*				here we set the port C to the given data			*/
	MDIO_VoidSetPortValue(HLCD_DATA_PORT, Copy_u8Data);
     cca:	82 e0       	ldi	r24, 0x02	; 2
     ccc:	6d 8d       	ldd	r22, Y+29	; 0x1d
     cce:	0e 94 ee 12 	call	0x25dc	; 0x25dc <MDIO_VoidSetPortValue>
	/*				set E pin to HIGH									*/
	/*				here we set the pin value to port B pin 0 to 5v		*/
	MDIO_VoidSetPinValue(HLCD_CONTROL_PORT,HLCD_E_PIN,DIO_PIN_HIGH);
     cd2:	81 e0       	ldi	r24, 0x01	; 1
     cd4:	62 e0       	ldi	r22, 0x02	; 2
     cd6:	41 e0       	ldi	r20, 0x01	; 1
     cd8:	0e 94 21 11 	call	0x2242	; 0x2242 <MDIO_VoidSetPinValue>
     cdc:	80 e0       	ldi	r24, 0x00	; 0
     cde:	90 e0       	ldi	r25, 0x00	; 0
     ce0:	a0 e8       	ldi	r26, 0x80	; 128
     ce2:	bf e3       	ldi	r27, 0x3F	; 63
     ce4:	89 8f       	std	Y+25, r24	; 0x19
     ce6:	9a 8f       	std	Y+26, r25	; 0x1a
     ce8:	ab 8f       	std	Y+27, r26	; 0x1b
     cea:	bc 8f       	std	Y+28, r27	; 0x1c
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
     cec:	69 8d       	ldd	r22, Y+25	; 0x19
     cee:	7a 8d       	ldd	r23, Y+26	; 0x1a
     cf0:	8b 8d       	ldd	r24, Y+27	; 0x1b
     cf2:	9c 8d       	ldd	r25, Y+28	; 0x1c
     cf4:	20 e0       	ldi	r18, 0x00	; 0
     cf6:	30 e0       	ldi	r19, 0x00	; 0
     cf8:	4a e7       	ldi	r20, 0x7A	; 122
     cfa:	53 e4       	ldi	r21, 0x43	; 67
     cfc:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
     d00:	dc 01       	movw	r26, r24
     d02:	cb 01       	movw	r24, r22
     d04:	8d 8b       	std	Y+21, r24	; 0x15
     d06:	9e 8b       	std	Y+22, r25	; 0x16
     d08:	af 8b       	std	Y+23, r26	; 0x17
     d0a:	b8 8f       	std	Y+24, r27	; 0x18
	if (__tmp < 1.0)
     d0c:	6d 89       	ldd	r22, Y+21	; 0x15
     d0e:	7e 89       	ldd	r23, Y+22	; 0x16
     d10:	8f 89       	ldd	r24, Y+23	; 0x17
     d12:	98 8d       	ldd	r25, Y+24	; 0x18
     d14:	20 e0       	ldi	r18, 0x00	; 0
     d16:	30 e0       	ldi	r19, 0x00	; 0
     d18:	40 e8       	ldi	r20, 0x80	; 128
     d1a:	5f e3       	ldi	r21, 0x3F	; 63
     d1c:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
     d20:	88 23       	and	r24, r24
     d22:	2c f4       	brge	.+10     	; 0xd2e <HLCD_VoidSendChar+0x8e>
		__ticks = 1;
     d24:	81 e0       	ldi	r24, 0x01	; 1
     d26:	90 e0       	ldi	r25, 0x00	; 0
     d28:	9c 8b       	std	Y+20, r25	; 0x14
     d2a:	8b 8b       	std	Y+19, r24	; 0x13
     d2c:	3f c0       	rjmp	.+126    	; 0xdac <HLCD_VoidSendChar+0x10c>
	else if (__tmp > 65535)
     d2e:	6d 89       	ldd	r22, Y+21	; 0x15
     d30:	7e 89       	ldd	r23, Y+22	; 0x16
     d32:	8f 89       	ldd	r24, Y+23	; 0x17
     d34:	98 8d       	ldd	r25, Y+24	; 0x18
     d36:	20 e0       	ldi	r18, 0x00	; 0
     d38:	3f ef       	ldi	r19, 0xFF	; 255
     d3a:	4f e7       	ldi	r20, 0x7F	; 127
     d3c:	57 e4       	ldi	r21, 0x47	; 71
     d3e:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
     d42:	18 16       	cp	r1, r24
     d44:	4c f5       	brge	.+82     	; 0xd98 <HLCD_VoidSendChar+0xf8>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
     d46:	69 8d       	ldd	r22, Y+25	; 0x19
     d48:	7a 8d       	ldd	r23, Y+26	; 0x1a
     d4a:	8b 8d       	ldd	r24, Y+27	; 0x1b
     d4c:	9c 8d       	ldd	r25, Y+28	; 0x1c
     d4e:	20 e0       	ldi	r18, 0x00	; 0
     d50:	30 e0       	ldi	r19, 0x00	; 0
     d52:	40 e2       	ldi	r20, 0x20	; 32
     d54:	51 e4       	ldi	r21, 0x41	; 65
     d56:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
     d5a:	dc 01       	movw	r26, r24
     d5c:	cb 01       	movw	r24, r22
     d5e:	bc 01       	movw	r22, r24
     d60:	cd 01       	movw	r24, r26
     d62:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
     d66:	dc 01       	movw	r26, r24
     d68:	cb 01       	movw	r24, r22
     d6a:	9c 8b       	std	Y+20, r25	; 0x14
     d6c:	8b 8b       	std	Y+19, r24	; 0x13
     d6e:	0f c0       	rjmp	.+30     	; 0xd8e <HLCD_VoidSendChar+0xee>
     d70:	89 e1       	ldi	r24, 0x19	; 25
     d72:	90 e0       	ldi	r25, 0x00	; 0
     d74:	9a 8b       	std	Y+18, r25	; 0x12
     d76:	89 8b       	std	Y+17, r24	; 0x11
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
     d78:	89 89       	ldd	r24, Y+17	; 0x11
     d7a:	9a 89       	ldd	r25, Y+18	; 0x12
     d7c:	01 97       	sbiw	r24, 0x01	; 1
     d7e:	f1 f7       	brne	.-4      	; 0xd7c <HLCD_VoidSendChar+0xdc>
     d80:	9a 8b       	std	Y+18, r25	; 0x12
     d82:	89 8b       	std	Y+17, r24	; 0x11
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     d84:	8b 89       	ldd	r24, Y+19	; 0x13
     d86:	9c 89       	ldd	r25, Y+20	; 0x14
     d88:	01 97       	sbiw	r24, 0x01	; 1
     d8a:	9c 8b       	std	Y+20, r25	; 0x14
     d8c:	8b 8b       	std	Y+19, r24	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     d8e:	8b 89       	ldd	r24, Y+19	; 0x13
     d90:	9c 89       	ldd	r25, Y+20	; 0x14
     d92:	00 97       	sbiw	r24, 0x00	; 0
     d94:	69 f7       	brne	.-38     	; 0xd70 <HLCD_VoidSendChar+0xd0>
     d96:	14 c0       	rjmp	.+40     	; 0xdc0 <HLCD_VoidSendChar+0x120>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
     d98:	6d 89       	ldd	r22, Y+21	; 0x15
     d9a:	7e 89       	ldd	r23, Y+22	; 0x16
     d9c:	8f 89       	ldd	r24, Y+23	; 0x17
     d9e:	98 8d       	ldd	r25, Y+24	; 0x18
     da0:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
     da4:	dc 01       	movw	r26, r24
     da6:	cb 01       	movw	r24, r22
     da8:	9c 8b       	std	Y+20, r25	; 0x14
     daa:	8b 8b       	std	Y+19, r24	; 0x13
     dac:	8b 89       	ldd	r24, Y+19	; 0x13
     dae:	9c 89       	ldd	r25, Y+20	; 0x14
     db0:	98 8b       	std	Y+16, r25	; 0x10
     db2:	8f 87       	std	Y+15, r24	; 0x0f
     db4:	8f 85       	ldd	r24, Y+15	; 0x0f
     db6:	98 89       	ldd	r25, Y+16	; 0x10
     db8:	01 97       	sbiw	r24, 0x01	; 1
     dba:	f1 f7       	brne	.-4      	; 0xdb8 <HLCD_VoidSendChar+0x118>
     dbc:	98 8b       	std	Y+16, r25	; 0x10
     dbe:	8f 87       	std	Y+15, r24	; 0x0f
	/*				Delay Function for 10 microsecond					*/
	_delay_ms(1);
	/*							clear E pin								*/
	/*		here we set the pin value to port B pin 2 to 5v				*/
	MDIO_VoidSetPinValue(HLCD_CONTROL_PORT,HLCD_E_PIN,DIO_PIN_LOW);
     dc0:	81 e0       	ldi	r24, 0x01	; 1
     dc2:	62 e0       	ldi	r22, 0x02	; 2
     dc4:	40 e0       	ldi	r20, 0x00	; 0
     dc6:	0e 94 21 11 	call	0x2242	; 0x2242 <MDIO_VoidSetPinValue>
     dca:	80 e0       	ldi	r24, 0x00	; 0
     dcc:	90 e0       	ldi	r25, 0x00	; 0
     dce:	a0 e8       	ldi	r26, 0x80	; 128
     dd0:	b0 e4       	ldi	r27, 0x40	; 64
     dd2:	8b 87       	std	Y+11, r24	; 0x0b
     dd4:	9c 87       	std	Y+12, r25	; 0x0c
     dd6:	ad 87       	std	Y+13, r26	; 0x0d
     dd8:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
     dda:	6b 85       	ldd	r22, Y+11	; 0x0b
     ddc:	7c 85       	ldd	r23, Y+12	; 0x0c
     dde:	8d 85       	ldd	r24, Y+13	; 0x0d
     de0:	9e 85       	ldd	r25, Y+14	; 0x0e
     de2:	20 e0       	ldi	r18, 0x00	; 0
     de4:	30 e0       	ldi	r19, 0x00	; 0
     de6:	4a e7       	ldi	r20, 0x7A	; 122
     de8:	53 e4       	ldi	r21, 0x43	; 67
     dea:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
     dee:	dc 01       	movw	r26, r24
     df0:	cb 01       	movw	r24, r22
     df2:	8f 83       	std	Y+7, r24	; 0x07
     df4:	98 87       	std	Y+8, r25	; 0x08
     df6:	a9 87       	std	Y+9, r26	; 0x09
     df8:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
     dfa:	6f 81       	ldd	r22, Y+7	; 0x07
     dfc:	78 85       	ldd	r23, Y+8	; 0x08
     dfe:	89 85       	ldd	r24, Y+9	; 0x09
     e00:	9a 85       	ldd	r25, Y+10	; 0x0a
     e02:	20 e0       	ldi	r18, 0x00	; 0
     e04:	30 e0       	ldi	r19, 0x00	; 0
     e06:	40 e8       	ldi	r20, 0x80	; 128
     e08:	5f e3       	ldi	r21, 0x3F	; 63
     e0a:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
     e0e:	88 23       	and	r24, r24
     e10:	2c f4       	brge	.+10     	; 0xe1c <HLCD_VoidSendChar+0x17c>
		__ticks = 1;
     e12:	81 e0       	ldi	r24, 0x01	; 1
     e14:	90 e0       	ldi	r25, 0x00	; 0
     e16:	9e 83       	std	Y+6, r25	; 0x06
     e18:	8d 83       	std	Y+5, r24	; 0x05
     e1a:	3f c0       	rjmp	.+126    	; 0xe9a <HLCD_VoidSendChar+0x1fa>
	else if (__tmp > 65535)
     e1c:	6f 81       	ldd	r22, Y+7	; 0x07
     e1e:	78 85       	ldd	r23, Y+8	; 0x08
     e20:	89 85       	ldd	r24, Y+9	; 0x09
     e22:	9a 85       	ldd	r25, Y+10	; 0x0a
     e24:	20 e0       	ldi	r18, 0x00	; 0
     e26:	3f ef       	ldi	r19, 0xFF	; 255
     e28:	4f e7       	ldi	r20, 0x7F	; 127
     e2a:	57 e4       	ldi	r21, 0x47	; 71
     e2c:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
     e30:	18 16       	cp	r1, r24
     e32:	4c f5       	brge	.+82     	; 0xe86 <HLCD_VoidSendChar+0x1e6>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
     e34:	6b 85       	ldd	r22, Y+11	; 0x0b
     e36:	7c 85       	ldd	r23, Y+12	; 0x0c
     e38:	8d 85       	ldd	r24, Y+13	; 0x0d
     e3a:	9e 85       	ldd	r25, Y+14	; 0x0e
     e3c:	20 e0       	ldi	r18, 0x00	; 0
     e3e:	30 e0       	ldi	r19, 0x00	; 0
     e40:	40 e2       	ldi	r20, 0x20	; 32
     e42:	51 e4       	ldi	r21, 0x41	; 65
     e44:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
     e48:	dc 01       	movw	r26, r24
     e4a:	cb 01       	movw	r24, r22
     e4c:	bc 01       	movw	r22, r24
     e4e:	cd 01       	movw	r24, r26
     e50:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
     e54:	dc 01       	movw	r26, r24
     e56:	cb 01       	movw	r24, r22
     e58:	9e 83       	std	Y+6, r25	; 0x06
     e5a:	8d 83       	std	Y+5, r24	; 0x05
     e5c:	0f c0       	rjmp	.+30     	; 0xe7c <HLCD_VoidSendChar+0x1dc>
     e5e:	89 e1       	ldi	r24, 0x19	; 25
     e60:	90 e0       	ldi	r25, 0x00	; 0
     e62:	9c 83       	std	Y+4, r25	; 0x04
     e64:	8b 83       	std	Y+3, r24	; 0x03
     e66:	8b 81       	ldd	r24, Y+3	; 0x03
     e68:	9c 81       	ldd	r25, Y+4	; 0x04
     e6a:	01 97       	sbiw	r24, 0x01	; 1
     e6c:	f1 f7       	brne	.-4      	; 0xe6a <HLCD_VoidSendChar+0x1ca>
     e6e:	9c 83       	std	Y+4, r25	; 0x04
     e70:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     e72:	8d 81       	ldd	r24, Y+5	; 0x05
     e74:	9e 81       	ldd	r25, Y+6	; 0x06
     e76:	01 97       	sbiw	r24, 0x01	; 1
     e78:	9e 83       	std	Y+6, r25	; 0x06
     e7a:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     e7c:	8d 81       	ldd	r24, Y+5	; 0x05
     e7e:	9e 81       	ldd	r25, Y+6	; 0x06
     e80:	00 97       	sbiw	r24, 0x00	; 0
     e82:	69 f7       	brne	.-38     	; 0xe5e <HLCD_VoidSendChar+0x1be>
     e84:	14 c0       	rjmp	.+40     	; 0xeae <HLCD_VoidSendChar+0x20e>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
     e86:	6f 81       	ldd	r22, Y+7	; 0x07
     e88:	78 85       	ldd	r23, Y+8	; 0x08
     e8a:	89 85       	ldd	r24, Y+9	; 0x09
     e8c:	9a 85       	ldd	r25, Y+10	; 0x0a
     e8e:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
     e92:	dc 01       	movw	r26, r24
     e94:	cb 01       	movw	r24, r22
     e96:	9e 83       	std	Y+6, r25	; 0x06
     e98:	8d 83       	std	Y+5, r24	; 0x05
     e9a:	8d 81       	ldd	r24, Y+5	; 0x05
     e9c:	9e 81       	ldd	r25, Y+6	; 0x06
     e9e:	9a 83       	std	Y+2, r25	; 0x02
     ea0:	89 83       	std	Y+1, r24	; 0x01
     ea2:	89 81       	ldd	r24, Y+1	; 0x01
     ea4:	9a 81       	ldd	r25, Y+2	; 0x02
     ea6:	01 97       	sbiw	r24, 0x01	; 1
     ea8:	f1 f7       	brne	.-4      	; 0xea6 <HLCD_VoidSendChar+0x206>
     eaa:	9a 83       	std	Y+2, r25	; 0x02
     eac:	89 83       	std	Y+1, r24	; 0x01
	/*Delay Function for 1ms to make sure that the LCD complete the task*/
	_delay_ms(4);

}
     eae:	6d 96       	adiw	r28, 0x1d	; 29
     eb0:	0f b6       	in	r0, 0x3f	; 63
     eb2:	f8 94       	cli
     eb4:	de bf       	out	0x3e, r29	; 62
     eb6:	0f be       	out	0x3f, r0	; 63
     eb8:	cd bf       	out	0x3d, r28	; 61
     eba:	cf 91       	pop	r28
     ebc:	df 91       	pop	r29
     ebe:	08 95       	ret

00000ec0 <HLCD_VoidSendCommand>:
 *
 *		This Function send a command to the LCD
 *
 ************************************************************************/
void HLCD_VoidSendCommand(u8 Copy_u8Command)
{
     ec0:	df 93       	push	r29
     ec2:	cf 93       	push	r28
     ec4:	cd b7       	in	r28, 0x3d	; 61
     ec6:	de b7       	in	r29, 0x3e	; 62
     ec8:	6d 97       	sbiw	r28, 0x1d	; 29
     eca:	0f b6       	in	r0, 0x3f	; 63
     ecc:	f8 94       	cli
     ece:	de bf       	out	0x3e, r29	; 62
     ed0:	0f be       	out	0x3f, r0	; 63
     ed2:	cd bf       	out	0x3d, r28	; 61
     ed4:	8d 8f       	std	Y+29, r24	; 0x1d
	/*					clear Rs pin									*/
	MDIO_VoidSetPinValue(HLCD_CONTROL_PORT,HLCD_RS_PIN,DIO_PIN_LOW);
     ed6:	81 e0       	ldi	r24, 0x01	; 1
     ed8:	60 e0       	ldi	r22, 0x00	; 0
     eda:	40 e0       	ldi	r20, 0x00	; 0
     edc:	0e 94 21 11 	call	0x2242	; 0x2242 <MDIO_VoidSetPinValue>
	/*					clear RW pin									*/
	/*			here we set the pin value to port B pin 1 to 0v			*/
	MDIO_VoidSetPinValue(HLCD_CONTROL_PORT,HLCD_RW_PIN,DIO_PIN_LOW);
     ee0:	81 e0       	ldi	r24, 0x01	; 1
     ee2:	61 e0       	ldi	r22, 0x01	; 1
     ee4:	40 e0       	ldi	r20, 0x00	; 0
     ee6:	0e 94 21 11 	call	0x2242	; 0x2242 <MDIO_VoidSetPinValue>

	/*			Delay Function for 10 microsecond						*/
	/*			here we set the port C to the given data				*/
	MDIO_VoidSetPortValue(HLCD_DATA_PORT, Copy_u8Command);
     eea:	82 e0       	ldi	r24, 0x02	; 2
     eec:	6d 8d       	ldd	r22, Y+29	; 0x1d
     eee:	0e 94 ee 12 	call	0x25dc	; 0x25dc <MDIO_VoidSetPortValue>
	/*				set E pin to HIGH									*/
	/*			here we set the pin value to port B pin 0 to 5v			*/
	MDIO_VoidSetPinValue(HLCD_CONTROL_PORT,HLCD_E_PIN,DIO_PIN_HIGH);
     ef2:	81 e0       	ldi	r24, 0x01	; 1
     ef4:	62 e0       	ldi	r22, 0x02	; 2
     ef6:	41 e0       	ldi	r20, 0x01	; 1
     ef8:	0e 94 21 11 	call	0x2242	; 0x2242 <MDIO_VoidSetPinValue>
     efc:	80 e0       	ldi	r24, 0x00	; 0
     efe:	90 e0       	ldi	r25, 0x00	; 0
     f00:	a0 e8       	ldi	r26, 0x80	; 128
     f02:	bf e3       	ldi	r27, 0x3F	; 63
     f04:	89 8f       	std	Y+25, r24	; 0x19
     f06:	9a 8f       	std	Y+26, r25	; 0x1a
     f08:	ab 8f       	std	Y+27, r26	; 0x1b
     f0a:	bc 8f       	std	Y+28, r27	; 0x1c
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
     f0c:	69 8d       	ldd	r22, Y+25	; 0x19
     f0e:	7a 8d       	ldd	r23, Y+26	; 0x1a
     f10:	8b 8d       	ldd	r24, Y+27	; 0x1b
     f12:	9c 8d       	ldd	r25, Y+28	; 0x1c
     f14:	20 e0       	ldi	r18, 0x00	; 0
     f16:	30 e0       	ldi	r19, 0x00	; 0
     f18:	4a e7       	ldi	r20, 0x7A	; 122
     f1a:	53 e4       	ldi	r21, 0x43	; 67
     f1c:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
     f20:	dc 01       	movw	r26, r24
     f22:	cb 01       	movw	r24, r22
     f24:	8d 8b       	std	Y+21, r24	; 0x15
     f26:	9e 8b       	std	Y+22, r25	; 0x16
     f28:	af 8b       	std	Y+23, r26	; 0x17
     f2a:	b8 8f       	std	Y+24, r27	; 0x18
	if (__tmp < 1.0)
     f2c:	6d 89       	ldd	r22, Y+21	; 0x15
     f2e:	7e 89       	ldd	r23, Y+22	; 0x16
     f30:	8f 89       	ldd	r24, Y+23	; 0x17
     f32:	98 8d       	ldd	r25, Y+24	; 0x18
     f34:	20 e0       	ldi	r18, 0x00	; 0
     f36:	30 e0       	ldi	r19, 0x00	; 0
     f38:	40 e8       	ldi	r20, 0x80	; 128
     f3a:	5f e3       	ldi	r21, 0x3F	; 63
     f3c:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
     f40:	88 23       	and	r24, r24
     f42:	2c f4       	brge	.+10     	; 0xf4e <HLCD_VoidSendCommand+0x8e>
		__ticks = 1;
     f44:	81 e0       	ldi	r24, 0x01	; 1
     f46:	90 e0       	ldi	r25, 0x00	; 0
     f48:	9c 8b       	std	Y+20, r25	; 0x14
     f4a:	8b 8b       	std	Y+19, r24	; 0x13
     f4c:	3f c0       	rjmp	.+126    	; 0xfcc <HLCD_VoidSendCommand+0x10c>
	else if (__tmp > 65535)
     f4e:	6d 89       	ldd	r22, Y+21	; 0x15
     f50:	7e 89       	ldd	r23, Y+22	; 0x16
     f52:	8f 89       	ldd	r24, Y+23	; 0x17
     f54:	98 8d       	ldd	r25, Y+24	; 0x18
     f56:	20 e0       	ldi	r18, 0x00	; 0
     f58:	3f ef       	ldi	r19, 0xFF	; 255
     f5a:	4f e7       	ldi	r20, 0x7F	; 127
     f5c:	57 e4       	ldi	r21, 0x47	; 71
     f5e:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
     f62:	18 16       	cp	r1, r24
     f64:	4c f5       	brge	.+82     	; 0xfb8 <HLCD_VoidSendCommand+0xf8>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
     f66:	69 8d       	ldd	r22, Y+25	; 0x19
     f68:	7a 8d       	ldd	r23, Y+26	; 0x1a
     f6a:	8b 8d       	ldd	r24, Y+27	; 0x1b
     f6c:	9c 8d       	ldd	r25, Y+28	; 0x1c
     f6e:	20 e0       	ldi	r18, 0x00	; 0
     f70:	30 e0       	ldi	r19, 0x00	; 0
     f72:	40 e2       	ldi	r20, 0x20	; 32
     f74:	51 e4       	ldi	r21, 0x41	; 65
     f76:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
     f7a:	dc 01       	movw	r26, r24
     f7c:	cb 01       	movw	r24, r22
     f7e:	bc 01       	movw	r22, r24
     f80:	cd 01       	movw	r24, r26
     f82:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
     f86:	dc 01       	movw	r26, r24
     f88:	cb 01       	movw	r24, r22
     f8a:	9c 8b       	std	Y+20, r25	; 0x14
     f8c:	8b 8b       	std	Y+19, r24	; 0x13
     f8e:	0f c0       	rjmp	.+30     	; 0xfae <HLCD_VoidSendCommand+0xee>
     f90:	89 e1       	ldi	r24, 0x19	; 25
     f92:	90 e0       	ldi	r25, 0x00	; 0
     f94:	9a 8b       	std	Y+18, r25	; 0x12
     f96:	89 8b       	std	Y+17, r24	; 0x11
     f98:	89 89       	ldd	r24, Y+17	; 0x11
     f9a:	9a 89       	ldd	r25, Y+18	; 0x12
     f9c:	01 97       	sbiw	r24, 0x01	; 1
     f9e:	f1 f7       	brne	.-4      	; 0xf9c <HLCD_VoidSendCommand+0xdc>
     fa0:	9a 8b       	std	Y+18, r25	; 0x12
     fa2:	89 8b       	std	Y+17, r24	; 0x11
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     fa4:	8b 89       	ldd	r24, Y+19	; 0x13
     fa6:	9c 89       	ldd	r25, Y+20	; 0x14
     fa8:	01 97       	sbiw	r24, 0x01	; 1
     faa:	9c 8b       	std	Y+20, r25	; 0x14
     fac:	8b 8b       	std	Y+19, r24	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     fae:	8b 89       	ldd	r24, Y+19	; 0x13
     fb0:	9c 89       	ldd	r25, Y+20	; 0x14
     fb2:	00 97       	sbiw	r24, 0x00	; 0
     fb4:	69 f7       	brne	.-38     	; 0xf90 <HLCD_VoidSendCommand+0xd0>
     fb6:	14 c0       	rjmp	.+40     	; 0xfe0 <HLCD_VoidSendCommand+0x120>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
     fb8:	6d 89       	ldd	r22, Y+21	; 0x15
     fba:	7e 89       	ldd	r23, Y+22	; 0x16
     fbc:	8f 89       	ldd	r24, Y+23	; 0x17
     fbe:	98 8d       	ldd	r25, Y+24	; 0x18
     fc0:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
     fc4:	dc 01       	movw	r26, r24
     fc6:	cb 01       	movw	r24, r22
     fc8:	9c 8b       	std	Y+20, r25	; 0x14
     fca:	8b 8b       	std	Y+19, r24	; 0x13
     fcc:	8b 89       	ldd	r24, Y+19	; 0x13
     fce:	9c 89       	ldd	r25, Y+20	; 0x14
     fd0:	98 8b       	std	Y+16, r25	; 0x10
     fd2:	8f 87       	std	Y+15, r24	; 0x0f
     fd4:	8f 85       	ldd	r24, Y+15	; 0x0f
     fd6:	98 89       	ldd	r25, Y+16	; 0x10
     fd8:	01 97       	sbiw	r24, 0x01	; 1
     fda:	f1 f7       	brne	.-4      	; 0xfd8 <HLCD_VoidSendCommand+0x118>
     fdc:	98 8b       	std	Y+16, r25	; 0x10
     fde:	8f 87       	std	Y+15, r24	; 0x0f
	_delay_ms(1);
	/*					clear E pin										*/
	/*			here we set the pin value to port B pin 2 to 5v			*/
	MDIO_VoidSetPinValue(HLCD_CONTROL_PORT,HLCD_E_PIN,DIO_PIN_LOW);
     fe0:	81 e0       	ldi	r24, 0x01	; 1
     fe2:	62 e0       	ldi	r22, 0x02	; 2
     fe4:	40 e0       	ldi	r20, 0x00	; 0
     fe6:	0e 94 21 11 	call	0x2242	; 0x2242 <MDIO_VoidSetPinValue>
     fea:	80 e0       	ldi	r24, 0x00	; 0
     fec:	90 e0       	ldi	r25, 0x00	; 0
     fee:	a0 e8       	ldi	r26, 0x80	; 128
     ff0:	b0 e4       	ldi	r27, 0x40	; 64
     ff2:	8b 87       	std	Y+11, r24	; 0x0b
     ff4:	9c 87       	std	Y+12, r25	; 0x0c
     ff6:	ad 87       	std	Y+13, r26	; 0x0d
     ff8:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
     ffa:	6b 85       	ldd	r22, Y+11	; 0x0b
     ffc:	7c 85       	ldd	r23, Y+12	; 0x0c
     ffe:	8d 85       	ldd	r24, Y+13	; 0x0d
    1000:	9e 85       	ldd	r25, Y+14	; 0x0e
    1002:	20 e0       	ldi	r18, 0x00	; 0
    1004:	30 e0       	ldi	r19, 0x00	; 0
    1006:	4a e7       	ldi	r20, 0x7A	; 122
    1008:	53 e4       	ldi	r21, 0x43	; 67
    100a:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    100e:	dc 01       	movw	r26, r24
    1010:	cb 01       	movw	r24, r22
    1012:	8f 83       	std	Y+7, r24	; 0x07
    1014:	98 87       	std	Y+8, r25	; 0x08
    1016:	a9 87       	std	Y+9, r26	; 0x09
    1018:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    101a:	6f 81       	ldd	r22, Y+7	; 0x07
    101c:	78 85       	ldd	r23, Y+8	; 0x08
    101e:	89 85       	ldd	r24, Y+9	; 0x09
    1020:	9a 85       	ldd	r25, Y+10	; 0x0a
    1022:	20 e0       	ldi	r18, 0x00	; 0
    1024:	30 e0       	ldi	r19, 0x00	; 0
    1026:	40 e8       	ldi	r20, 0x80	; 128
    1028:	5f e3       	ldi	r21, 0x3F	; 63
    102a:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    102e:	88 23       	and	r24, r24
    1030:	2c f4       	brge	.+10     	; 0x103c <HLCD_VoidSendCommand+0x17c>
		__ticks = 1;
    1032:	81 e0       	ldi	r24, 0x01	; 1
    1034:	90 e0       	ldi	r25, 0x00	; 0
    1036:	9e 83       	std	Y+6, r25	; 0x06
    1038:	8d 83       	std	Y+5, r24	; 0x05
    103a:	3f c0       	rjmp	.+126    	; 0x10ba <HLCD_VoidSendCommand+0x1fa>
	else if (__tmp > 65535)
    103c:	6f 81       	ldd	r22, Y+7	; 0x07
    103e:	78 85       	ldd	r23, Y+8	; 0x08
    1040:	89 85       	ldd	r24, Y+9	; 0x09
    1042:	9a 85       	ldd	r25, Y+10	; 0x0a
    1044:	20 e0       	ldi	r18, 0x00	; 0
    1046:	3f ef       	ldi	r19, 0xFF	; 255
    1048:	4f e7       	ldi	r20, 0x7F	; 127
    104a:	57 e4       	ldi	r21, 0x47	; 71
    104c:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    1050:	18 16       	cp	r1, r24
    1052:	4c f5       	brge	.+82     	; 0x10a6 <HLCD_VoidSendCommand+0x1e6>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    1054:	6b 85       	ldd	r22, Y+11	; 0x0b
    1056:	7c 85       	ldd	r23, Y+12	; 0x0c
    1058:	8d 85       	ldd	r24, Y+13	; 0x0d
    105a:	9e 85       	ldd	r25, Y+14	; 0x0e
    105c:	20 e0       	ldi	r18, 0x00	; 0
    105e:	30 e0       	ldi	r19, 0x00	; 0
    1060:	40 e2       	ldi	r20, 0x20	; 32
    1062:	51 e4       	ldi	r21, 0x41	; 65
    1064:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1068:	dc 01       	movw	r26, r24
    106a:	cb 01       	movw	r24, r22
    106c:	bc 01       	movw	r22, r24
    106e:	cd 01       	movw	r24, r26
    1070:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1074:	dc 01       	movw	r26, r24
    1076:	cb 01       	movw	r24, r22
    1078:	9e 83       	std	Y+6, r25	; 0x06
    107a:	8d 83       	std	Y+5, r24	; 0x05
    107c:	0f c0       	rjmp	.+30     	; 0x109c <HLCD_VoidSendCommand+0x1dc>
    107e:	89 e1       	ldi	r24, 0x19	; 25
    1080:	90 e0       	ldi	r25, 0x00	; 0
    1082:	9c 83       	std	Y+4, r25	; 0x04
    1084:	8b 83       	std	Y+3, r24	; 0x03
    1086:	8b 81       	ldd	r24, Y+3	; 0x03
    1088:	9c 81       	ldd	r25, Y+4	; 0x04
    108a:	01 97       	sbiw	r24, 0x01	; 1
    108c:	f1 f7       	brne	.-4      	; 0x108a <HLCD_VoidSendCommand+0x1ca>
    108e:	9c 83       	std	Y+4, r25	; 0x04
    1090:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1092:	8d 81       	ldd	r24, Y+5	; 0x05
    1094:	9e 81       	ldd	r25, Y+6	; 0x06
    1096:	01 97       	sbiw	r24, 0x01	; 1
    1098:	9e 83       	std	Y+6, r25	; 0x06
    109a:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    109c:	8d 81       	ldd	r24, Y+5	; 0x05
    109e:	9e 81       	ldd	r25, Y+6	; 0x06
    10a0:	00 97       	sbiw	r24, 0x00	; 0
    10a2:	69 f7       	brne	.-38     	; 0x107e <HLCD_VoidSendCommand+0x1be>
    10a4:	14 c0       	rjmp	.+40     	; 0x10ce <HLCD_VoidSendCommand+0x20e>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    10a6:	6f 81       	ldd	r22, Y+7	; 0x07
    10a8:	78 85       	ldd	r23, Y+8	; 0x08
    10aa:	89 85       	ldd	r24, Y+9	; 0x09
    10ac:	9a 85       	ldd	r25, Y+10	; 0x0a
    10ae:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    10b2:	dc 01       	movw	r26, r24
    10b4:	cb 01       	movw	r24, r22
    10b6:	9e 83       	std	Y+6, r25	; 0x06
    10b8:	8d 83       	std	Y+5, r24	; 0x05
    10ba:	8d 81       	ldd	r24, Y+5	; 0x05
    10bc:	9e 81       	ldd	r25, Y+6	; 0x06
    10be:	9a 83       	std	Y+2, r25	; 0x02
    10c0:	89 83       	std	Y+1, r24	; 0x01
    10c2:	89 81       	ldd	r24, Y+1	; 0x01
    10c4:	9a 81       	ldd	r25, Y+2	; 0x02
    10c6:	01 97       	sbiw	r24, 0x01	; 1
    10c8:	f1 f7       	brne	.-4      	; 0x10c6 <HLCD_VoidSendCommand+0x206>
    10ca:	9a 83       	std	Y+2, r25	; 0x02
    10cc:	89 83       	std	Y+1, r24	; 0x01
	/*Delay Function for 1ms to make sure that the LCD complete the task*/
	_delay_ms(4);
}
    10ce:	6d 96       	adiw	r28, 0x1d	; 29
    10d0:	0f b6       	in	r0, 0x3f	; 63
    10d2:	f8 94       	cli
    10d4:	de bf       	out	0x3e, r29	; 62
    10d6:	0f be       	out	0x3f, r0	; 63
    10d8:	cd bf       	out	0x3d, r28	; 61
    10da:	cf 91       	pop	r28
    10dc:	df 91       	pop	r29
    10de:	08 95       	ret

000010e0 <HLCD_enuInit>:
 *
 * 		Here we initialize each port direction and every pin we need
 *
 **********************************************************************/
void HLCD_enuInit(void)
{
    10e0:	df 93       	push	r29
    10e2:	cf 93       	push	r28
    10e4:	cd b7       	in	r28, 0x3d	; 61
    10e6:	de b7       	in	r29, 0x3e	; 62
    10e8:	e8 97       	sbiw	r28, 0x38	; 56
    10ea:	0f b6       	in	r0, 0x3f	; 63
    10ec:	f8 94       	cli
    10ee:	de bf       	out	0x3e, r29	; 62
    10f0:	0f be       	out	0x3f, r0	; 63
    10f2:	cd bf       	out	0x3d, r28	; 61
	MDIO_VoidSetPortDirection(DIO_PORTC,DIO_PORT_HIGH);
    10f4:	82 e0       	ldi	r24, 0x02	; 2
    10f6:	6f ef       	ldi	r22, 0xFF	; 255
    10f8:	0e 94 ad 12 	call	0x255a	; 0x255a <MDIO_VoidSetPortDirection>
	/**/
	MDIO_VoidSetPinDirection(DIO_PORTB,DIO_PIN0,DIO_PIN_HIGH);
    10fc:	81 e0       	ldi	r24, 0x01	; 1
    10fe:	60 e0       	ldi	r22, 0x00	; 0
    1100:	41 e0       	ldi	r20, 0x01	; 1
    1102:	0e 94 19 10 	call	0x2032	; 0x2032 <MDIO_VoidSetPinDirection>
	/**/
	MDIO_VoidSetPinDirection(DIO_PORTB,DIO_PIN1,DIO_PIN_HIGH);
    1106:	81 e0       	ldi	r24, 0x01	; 1
    1108:	61 e0       	ldi	r22, 0x01	; 1
    110a:	41 e0       	ldi	r20, 0x01	; 1
    110c:	0e 94 19 10 	call	0x2032	; 0x2032 <MDIO_VoidSetPinDirection>
	/**/
	MDIO_VoidSetPinDirection(DIO_PORTB,DIO_PIN2,DIO_PIN_HIGH);
    1110:	81 e0       	ldi	r24, 0x01	; 1
    1112:	62 e0       	ldi	r22, 0x02	; 2
    1114:	41 e0       	ldi	r20, 0x01	; 1
    1116:	0e 94 19 10 	call	0x2032	; 0x2032 <MDIO_VoidSetPinDirection>
    111a:	80 e0       	ldi	r24, 0x00	; 0
    111c:	90 e0       	ldi	r25, 0x00	; 0
    111e:	a8 e4       	ldi	r26, 0x48	; 72
    1120:	b2 e4       	ldi	r27, 0x42	; 66
    1122:	8d ab       	std	Y+53, r24	; 0x35
    1124:	9e ab       	std	Y+54, r25	; 0x36
    1126:	af ab       	std	Y+55, r26	; 0x37
    1128:	b8 af       	std	Y+56, r27	; 0x38
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    112a:	6d a9       	ldd	r22, Y+53	; 0x35
    112c:	7e a9       	ldd	r23, Y+54	; 0x36
    112e:	8f a9       	ldd	r24, Y+55	; 0x37
    1130:	98 ad       	ldd	r25, Y+56	; 0x38
    1132:	20 e0       	ldi	r18, 0x00	; 0
    1134:	30 e0       	ldi	r19, 0x00	; 0
    1136:	4a e7       	ldi	r20, 0x7A	; 122
    1138:	53 e4       	ldi	r21, 0x43	; 67
    113a:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    113e:	dc 01       	movw	r26, r24
    1140:	cb 01       	movw	r24, r22
    1142:	89 ab       	std	Y+49, r24	; 0x31
    1144:	9a ab       	std	Y+50, r25	; 0x32
    1146:	ab ab       	std	Y+51, r26	; 0x33
    1148:	bc ab       	std	Y+52, r27	; 0x34
	if (__tmp < 1.0)
    114a:	69 a9       	ldd	r22, Y+49	; 0x31
    114c:	7a a9       	ldd	r23, Y+50	; 0x32
    114e:	8b a9       	ldd	r24, Y+51	; 0x33
    1150:	9c a9       	ldd	r25, Y+52	; 0x34
    1152:	20 e0       	ldi	r18, 0x00	; 0
    1154:	30 e0       	ldi	r19, 0x00	; 0
    1156:	40 e8       	ldi	r20, 0x80	; 128
    1158:	5f e3       	ldi	r21, 0x3F	; 63
    115a:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    115e:	88 23       	and	r24, r24
    1160:	2c f4       	brge	.+10     	; 0x116c <HLCD_enuInit+0x8c>
		__ticks = 1;
    1162:	81 e0       	ldi	r24, 0x01	; 1
    1164:	90 e0       	ldi	r25, 0x00	; 0
    1166:	98 ab       	std	Y+48, r25	; 0x30
    1168:	8f a7       	std	Y+47, r24	; 0x2f
    116a:	3f c0       	rjmp	.+126    	; 0x11ea <HLCD_enuInit+0x10a>
	else if (__tmp > 65535)
    116c:	69 a9       	ldd	r22, Y+49	; 0x31
    116e:	7a a9       	ldd	r23, Y+50	; 0x32
    1170:	8b a9       	ldd	r24, Y+51	; 0x33
    1172:	9c a9       	ldd	r25, Y+52	; 0x34
    1174:	20 e0       	ldi	r18, 0x00	; 0
    1176:	3f ef       	ldi	r19, 0xFF	; 255
    1178:	4f e7       	ldi	r20, 0x7F	; 127
    117a:	57 e4       	ldi	r21, 0x47	; 71
    117c:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    1180:	18 16       	cp	r1, r24
    1182:	4c f5       	brge	.+82     	; 0x11d6 <HLCD_enuInit+0xf6>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    1184:	6d a9       	ldd	r22, Y+53	; 0x35
    1186:	7e a9       	ldd	r23, Y+54	; 0x36
    1188:	8f a9       	ldd	r24, Y+55	; 0x37
    118a:	98 ad       	ldd	r25, Y+56	; 0x38
    118c:	20 e0       	ldi	r18, 0x00	; 0
    118e:	30 e0       	ldi	r19, 0x00	; 0
    1190:	40 e2       	ldi	r20, 0x20	; 32
    1192:	51 e4       	ldi	r21, 0x41	; 65
    1194:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1198:	dc 01       	movw	r26, r24
    119a:	cb 01       	movw	r24, r22
    119c:	bc 01       	movw	r22, r24
    119e:	cd 01       	movw	r24, r26
    11a0:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    11a4:	dc 01       	movw	r26, r24
    11a6:	cb 01       	movw	r24, r22
    11a8:	98 ab       	std	Y+48, r25	; 0x30
    11aa:	8f a7       	std	Y+47, r24	; 0x2f
    11ac:	0f c0       	rjmp	.+30     	; 0x11cc <HLCD_enuInit+0xec>
    11ae:	89 e1       	ldi	r24, 0x19	; 25
    11b0:	90 e0       	ldi	r25, 0x00	; 0
    11b2:	9e a7       	std	Y+46, r25	; 0x2e
    11b4:	8d a7       	std	Y+45, r24	; 0x2d
    11b6:	8d a5       	ldd	r24, Y+45	; 0x2d
    11b8:	9e a5       	ldd	r25, Y+46	; 0x2e
    11ba:	01 97       	sbiw	r24, 0x01	; 1
    11bc:	f1 f7       	brne	.-4      	; 0x11ba <HLCD_enuInit+0xda>
    11be:	9e a7       	std	Y+46, r25	; 0x2e
    11c0:	8d a7       	std	Y+45, r24	; 0x2d
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    11c2:	8f a5       	ldd	r24, Y+47	; 0x2f
    11c4:	98 a9       	ldd	r25, Y+48	; 0x30
    11c6:	01 97       	sbiw	r24, 0x01	; 1
    11c8:	98 ab       	std	Y+48, r25	; 0x30
    11ca:	8f a7       	std	Y+47, r24	; 0x2f
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    11cc:	8f a5       	ldd	r24, Y+47	; 0x2f
    11ce:	98 a9       	ldd	r25, Y+48	; 0x30
    11d0:	00 97       	sbiw	r24, 0x00	; 0
    11d2:	69 f7       	brne	.-38     	; 0x11ae <HLCD_enuInit+0xce>
    11d4:	14 c0       	rjmp	.+40     	; 0x11fe <HLCD_enuInit+0x11e>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    11d6:	69 a9       	ldd	r22, Y+49	; 0x31
    11d8:	7a a9       	ldd	r23, Y+50	; 0x32
    11da:	8b a9       	ldd	r24, Y+51	; 0x33
    11dc:	9c a9       	ldd	r25, Y+52	; 0x34
    11de:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    11e2:	dc 01       	movw	r26, r24
    11e4:	cb 01       	movw	r24, r22
    11e6:	98 ab       	std	Y+48, r25	; 0x30
    11e8:	8f a7       	std	Y+47, r24	; 0x2f
    11ea:	8f a5       	ldd	r24, Y+47	; 0x2f
    11ec:	98 a9       	ldd	r25, Y+48	; 0x30
    11ee:	9c a7       	std	Y+44, r25	; 0x2c
    11f0:	8b a7       	std	Y+43, r24	; 0x2b
    11f2:	8b a5       	ldd	r24, Y+43	; 0x2b
    11f4:	9c a5       	ldd	r25, Y+44	; 0x2c
    11f6:	01 97       	sbiw	r24, 0x01	; 1
    11f8:	f1 f7       	brne	.-4      	; 0x11f6 <HLCD_enuInit+0x116>
    11fa:	9c a7       	std	Y+44, r25	; 0x2c
    11fc:	8b a7       	std	Y+43, r24	; 0x2b
#if HLCD_INIT_MODE == HLCD_8_BIT_MODE

		/*					Delay for 30ms									*/
		_delay_ms(50);
		/*					set Port c to output							*/
		HLCD_VoidSendCommand(0b00111000);
    11fe:	88 e3       	ldi	r24, 0x38	; 56
    1200:	0e 94 60 07 	call	0xec0	; 0xec0 <HLCD_VoidSendCommand>
    1204:	80 e0       	ldi	r24, 0x00	; 0
    1206:	90 e0       	ldi	r25, 0x00	; 0
    1208:	a0 e8       	ldi	r26, 0x80	; 128
    120a:	bf e3       	ldi	r27, 0x3F	; 63
    120c:	8f a3       	std	Y+39, r24	; 0x27
    120e:	98 a7       	std	Y+40, r25	; 0x28
    1210:	a9 a7       	std	Y+41, r26	; 0x29
    1212:	ba a7       	std	Y+42, r27	; 0x2a
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    1214:	6f a1       	ldd	r22, Y+39	; 0x27
    1216:	78 a5       	ldd	r23, Y+40	; 0x28
    1218:	89 a5       	ldd	r24, Y+41	; 0x29
    121a:	9a a5       	ldd	r25, Y+42	; 0x2a
    121c:	20 e0       	ldi	r18, 0x00	; 0
    121e:	30 e0       	ldi	r19, 0x00	; 0
    1220:	4a e7       	ldi	r20, 0x7A	; 122
    1222:	53 e4       	ldi	r21, 0x43	; 67
    1224:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1228:	dc 01       	movw	r26, r24
    122a:	cb 01       	movw	r24, r22
    122c:	8b a3       	std	Y+35, r24	; 0x23
    122e:	9c a3       	std	Y+36, r25	; 0x24
    1230:	ad a3       	std	Y+37, r26	; 0x25
    1232:	be a3       	std	Y+38, r27	; 0x26
	if (__tmp < 1.0)
    1234:	6b a1       	ldd	r22, Y+35	; 0x23
    1236:	7c a1       	ldd	r23, Y+36	; 0x24
    1238:	8d a1       	ldd	r24, Y+37	; 0x25
    123a:	9e a1       	ldd	r25, Y+38	; 0x26
    123c:	20 e0       	ldi	r18, 0x00	; 0
    123e:	30 e0       	ldi	r19, 0x00	; 0
    1240:	40 e8       	ldi	r20, 0x80	; 128
    1242:	5f e3       	ldi	r21, 0x3F	; 63
    1244:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    1248:	88 23       	and	r24, r24
    124a:	2c f4       	brge	.+10     	; 0x1256 <HLCD_enuInit+0x176>
		__ticks = 1;
    124c:	81 e0       	ldi	r24, 0x01	; 1
    124e:	90 e0       	ldi	r25, 0x00	; 0
    1250:	9a a3       	std	Y+34, r25	; 0x22
    1252:	89 a3       	std	Y+33, r24	; 0x21
    1254:	3f c0       	rjmp	.+126    	; 0x12d4 <HLCD_enuInit+0x1f4>
	else if (__tmp > 65535)
    1256:	6b a1       	ldd	r22, Y+35	; 0x23
    1258:	7c a1       	ldd	r23, Y+36	; 0x24
    125a:	8d a1       	ldd	r24, Y+37	; 0x25
    125c:	9e a1       	ldd	r25, Y+38	; 0x26
    125e:	20 e0       	ldi	r18, 0x00	; 0
    1260:	3f ef       	ldi	r19, 0xFF	; 255
    1262:	4f e7       	ldi	r20, 0x7F	; 127
    1264:	57 e4       	ldi	r21, 0x47	; 71
    1266:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    126a:	18 16       	cp	r1, r24
    126c:	4c f5       	brge	.+82     	; 0x12c0 <HLCD_enuInit+0x1e0>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    126e:	6f a1       	ldd	r22, Y+39	; 0x27
    1270:	78 a5       	ldd	r23, Y+40	; 0x28
    1272:	89 a5       	ldd	r24, Y+41	; 0x29
    1274:	9a a5       	ldd	r25, Y+42	; 0x2a
    1276:	20 e0       	ldi	r18, 0x00	; 0
    1278:	30 e0       	ldi	r19, 0x00	; 0
    127a:	40 e2       	ldi	r20, 0x20	; 32
    127c:	51 e4       	ldi	r21, 0x41	; 65
    127e:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1282:	dc 01       	movw	r26, r24
    1284:	cb 01       	movw	r24, r22
    1286:	bc 01       	movw	r22, r24
    1288:	cd 01       	movw	r24, r26
    128a:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    128e:	dc 01       	movw	r26, r24
    1290:	cb 01       	movw	r24, r22
    1292:	9a a3       	std	Y+34, r25	; 0x22
    1294:	89 a3       	std	Y+33, r24	; 0x21
    1296:	0f c0       	rjmp	.+30     	; 0x12b6 <HLCD_enuInit+0x1d6>
    1298:	89 e1       	ldi	r24, 0x19	; 25
    129a:	90 e0       	ldi	r25, 0x00	; 0
    129c:	98 a3       	std	Y+32, r25	; 0x20
    129e:	8f 8f       	std	Y+31, r24	; 0x1f
    12a0:	8f 8d       	ldd	r24, Y+31	; 0x1f
    12a2:	98 a1       	ldd	r25, Y+32	; 0x20
    12a4:	01 97       	sbiw	r24, 0x01	; 1
    12a6:	f1 f7       	brne	.-4      	; 0x12a4 <HLCD_enuInit+0x1c4>
    12a8:	98 a3       	std	Y+32, r25	; 0x20
    12aa:	8f 8f       	std	Y+31, r24	; 0x1f
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    12ac:	89 a1       	ldd	r24, Y+33	; 0x21
    12ae:	9a a1       	ldd	r25, Y+34	; 0x22
    12b0:	01 97       	sbiw	r24, 0x01	; 1
    12b2:	9a a3       	std	Y+34, r25	; 0x22
    12b4:	89 a3       	std	Y+33, r24	; 0x21
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    12b6:	89 a1       	ldd	r24, Y+33	; 0x21
    12b8:	9a a1       	ldd	r25, Y+34	; 0x22
    12ba:	00 97       	sbiw	r24, 0x00	; 0
    12bc:	69 f7       	brne	.-38     	; 0x1298 <HLCD_enuInit+0x1b8>
    12be:	14 c0       	rjmp	.+40     	; 0x12e8 <HLCD_enuInit+0x208>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    12c0:	6b a1       	ldd	r22, Y+35	; 0x23
    12c2:	7c a1       	ldd	r23, Y+36	; 0x24
    12c4:	8d a1       	ldd	r24, Y+37	; 0x25
    12c6:	9e a1       	ldd	r25, Y+38	; 0x26
    12c8:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    12cc:	dc 01       	movw	r26, r24
    12ce:	cb 01       	movw	r24, r22
    12d0:	9a a3       	std	Y+34, r25	; 0x22
    12d2:	89 a3       	std	Y+33, r24	; 0x21
    12d4:	89 a1       	ldd	r24, Y+33	; 0x21
    12d6:	9a a1       	ldd	r25, Y+34	; 0x22
    12d8:	9e 8f       	std	Y+30, r25	; 0x1e
    12da:	8d 8f       	std	Y+29, r24	; 0x1d
    12dc:	8d 8d       	ldd	r24, Y+29	; 0x1d
    12de:	9e 8d       	ldd	r25, Y+30	; 0x1e
    12e0:	01 97       	sbiw	r24, 0x01	; 1
    12e2:	f1 f7       	brne	.-4      	; 0x12e0 <HLCD_enuInit+0x200>
    12e4:	9e 8f       	std	Y+30, r25	; 0x1e
    12e6:	8d 8f       	std	Y+29, r24	; 0x1d
		_delay_ms(1);
		/*					set port b pin number 0 to high					*/
		HLCD_VoidSendCommand(0b00001111);
    12e8:	8f e0       	ldi	r24, 0x0F	; 15
    12ea:	0e 94 60 07 	call	0xec0	; 0xec0 <HLCD_VoidSendCommand>
    12ee:	80 e0       	ldi	r24, 0x00	; 0
    12f0:	90 e0       	ldi	r25, 0x00	; 0
    12f2:	a0 e8       	ldi	r26, 0x80	; 128
    12f4:	bf e3       	ldi	r27, 0x3F	; 63
    12f6:	89 8f       	std	Y+25, r24	; 0x19
    12f8:	9a 8f       	std	Y+26, r25	; 0x1a
    12fa:	ab 8f       	std	Y+27, r26	; 0x1b
    12fc:	bc 8f       	std	Y+28, r27	; 0x1c
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    12fe:	69 8d       	ldd	r22, Y+25	; 0x19
    1300:	7a 8d       	ldd	r23, Y+26	; 0x1a
    1302:	8b 8d       	ldd	r24, Y+27	; 0x1b
    1304:	9c 8d       	ldd	r25, Y+28	; 0x1c
    1306:	20 e0       	ldi	r18, 0x00	; 0
    1308:	30 e0       	ldi	r19, 0x00	; 0
    130a:	4a e7       	ldi	r20, 0x7A	; 122
    130c:	53 e4       	ldi	r21, 0x43	; 67
    130e:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1312:	dc 01       	movw	r26, r24
    1314:	cb 01       	movw	r24, r22
    1316:	8d 8b       	std	Y+21, r24	; 0x15
    1318:	9e 8b       	std	Y+22, r25	; 0x16
    131a:	af 8b       	std	Y+23, r26	; 0x17
    131c:	b8 8f       	std	Y+24, r27	; 0x18
	if (__tmp < 1.0)
    131e:	6d 89       	ldd	r22, Y+21	; 0x15
    1320:	7e 89       	ldd	r23, Y+22	; 0x16
    1322:	8f 89       	ldd	r24, Y+23	; 0x17
    1324:	98 8d       	ldd	r25, Y+24	; 0x18
    1326:	20 e0       	ldi	r18, 0x00	; 0
    1328:	30 e0       	ldi	r19, 0x00	; 0
    132a:	40 e8       	ldi	r20, 0x80	; 128
    132c:	5f e3       	ldi	r21, 0x3F	; 63
    132e:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    1332:	88 23       	and	r24, r24
    1334:	2c f4       	brge	.+10     	; 0x1340 <HLCD_enuInit+0x260>
		__ticks = 1;
    1336:	81 e0       	ldi	r24, 0x01	; 1
    1338:	90 e0       	ldi	r25, 0x00	; 0
    133a:	9c 8b       	std	Y+20, r25	; 0x14
    133c:	8b 8b       	std	Y+19, r24	; 0x13
    133e:	3f c0       	rjmp	.+126    	; 0x13be <HLCD_enuInit+0x2de>
	else if (__tmp > 65535)
    1340:	6d 89       	ldd	r22, Y+21	; 0x15
    1342:	7e 89       	ldd	r23, Y+22	; 0x16
    1344:	8f 89       	ldd	r24, Y+23	; 0x17
    1346:	98 8d       	ldd	r25, Y+24	; 0x18
    1348:	20 e0       	ldi	r18, 0x00	; 0
    134a:	3f ef       	ldi	r19, 0xFF	; 255
    134c:	4f e7       	ldi	r20, 0x7F	; 127
    134e:	57 e4       	ldi	r21, 0x47	; 71
    1350:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    1354:	18 16       	cp	r1, r24
    1356:	4c f5       	brge	.+82     	; 0x13aa <HLCD_enuInit+0x2ca>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    1358:	69 8d       	ldd	r22, Y+25	; 0x19
    135a:	7a 8d       	ldd	r23, Y+26	; 0x1a
    135c:	8b 8d       	ldd	r24, Y+27	; 0x1b
    135e:	9c 8d       	ldd	r25, Y+28	; 0x1c
    1360:	20 e0       	ldi	r18, 0x00	; 0
    1362:	30 e0       	ldi	r19, 0x00	; 0
    1364:	40 e2       	ldi	r20, 0x20	; 32
    1366:	51 e4       	ldi	r21, 0x41	; 65
    1368:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    136c:	dc 01       	movw	r26, r24
    136e:	cb 01       	movw	r24, r22
    1370:	bc 01       	movw	r22, r24
    1372:	cd 01       	movw	r24, r26
    1374:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1378:	dc 01       	movw	r26, r24
    137a:	cb 01       	movw	r24, r22
    137c:	9c 8b       	std	Y+20, r25	; 0x14
    137e:	8b 8b       	std	Y+19, r24	; 0x13
    1380:	0f c0       	rjmp	.+30     	; 0x13a0 <HLCD_enuInit+0x2c0>
    1382:	89 e1       	ldi	r24, 0x19	; 25
    1384:	90 e0       	ldi	r25, 0x00	; 0
    1386:	9a 8b       	std	Y+18, r25	; 0x12
    1388:	89 8b       	std	Y+17, r24	; 0x11
    138a:	89 89       	ldd	r24, Y+17	; 0x11
    138c:	9a 89       	ldd	r25, Y+18	; 0x12
    138e:	01 97       	sbiw	r24, 0x01	; 1
    1390:	f1 f7       	brne	.-4      	; 0x138e <HLCD_enuInit+0x2ae>
    1392:	9a 8b       	std	Y+18, r25	; 0x12
    1394:	89 8b       	std	Y+17, r24	; 0x11
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1396:	8b 89       	ldd	r24, Y+19	; 0x13
    1398:	9c 89       	ldd	r25, Y+20	; 0x14
    139a:	01 97       	sbiw	r24, 0x01	; 1
    139c:	9c 8b       	std	Y+20, r25	; 0x14
    139e:	8b 8b       	std	Y+19, r24	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    13a0:	8b 89       	ldd	r24, Y+19	; 0x13
    13a2:	9c 89       	ldd	r25, Y+20	; 0x14
    13a4:	00 97       	sbiw	r24, 0x00	; 0
    13a6:	69 f7       	brne	.-38     	; 0x1382 <HLCD_enuInit+0x2a2>
    13a8:	14 c0       	rjmp	.+40     	; 0x13d2 <HLCD_enuInit+0x2f2>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    13aa:	6d 89       	ldd	r22, Y+21	; 0x15
    13ac:	7e 89       	ldd	r23, Y+22	; 0x16
    13ae:	8f 89       	ldd	r24, Y+23	; 0x17
    13b0:	98 8d       	ldd	r25, Y+24	; 0x18
    13b2:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    13b6:	dc 01       	movw	r26, r24
    13b8:	cb 01       	movw	r24, r22
    13ba:	9c 8b       	std	Y+20, r25	; 0x14
    13bc:	8b 8b       	std	Y+19, r24	; 0x13
    13be:	8b 89       	ldd	r24, Y+19	; 0x13
    13c0:	9c 89       	ldd	r25, Y+20	; 0x14
    13c2:	98 8b       	std	Y+16, r25	; 0x10
    13c4:	8f 87       	std	Y+15, r24	; 0x0f
    13c6:	8f 85       	ldd	r24, Y+15	; 0x0f
    13c8:	98 89       	ldd	r25, Y+16	; 0x10
    13ca:	01 97       	sbiw	r24, 0x01	; 1
    13cc:	f1 f7       	brne	.-4      	; 0x13ca <HLCD_enuInit+0x2ea>
    13ce:	98 8b       	std	Y+16, r25	; 0x10
    13d0:	8f 87       	std	Y+15, r24	; 0x0f
		/*					Delay for 1ms									*/
		_delay_ms(1);
		HLCD_VoidSendCommand(0b00000000);
    13d2:	80 e0       	ldi	r24, 0x00	; 0
    13d4:	0e 94 60 07 	call	0xec0	; 0xec0 <HLCD_VoidSendCommand>
    13d8:	80 e0       	ldi	r24, 0x00	; 0
    13da:	90 e0       	ldi	r25, 0x00	; 0
    13dc:	a0 e0       	ldi	r26, 0x00	; 0
    13de:	b0 e4       	ldi	r27, 0x40	; 64
    13e0:	8b 87       	std	Y+11, r24	; 0x0b
    13e2:	9c 87       	std	Y+12, r25	; 0x0c
    13e4:	ad 87       	std	Y+13, r26	; 0x0d
    13e6:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    13e8:	6b 85       	ldd	r22, Y+11	; 0x0b
    13ea:	7c 85       	ldd	r23, Y+12	; 0x0c
    13ec:	8d 85       	ldd	r24, Y+13	; 0x0d
    13ee:	9e 85       	ldd	r25, Y+14	; 0x0e
    13f0:	20 e0       	ldi	r18, 0x00	; 0
    13f2:	30 e0       	ldi	r19, 0x00	; 0
    13f4:	4a e7       	ldi	r20, 0x7A	; 122
    13f6:	53 e4       	ldi	r21, 0x43	; 67
    13f8:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    13fc:	dc 01       	movw	r26, r24
    13fe:	cb 01       	movw	r24, r22
    1400:	8f 83       	std	Y+7, r24	; 0x07
    1402:	98 87       	std	Y+8, r25	; 0x08
    1404:	a9 87       	std	Y+9, r26	; 0x09
    1406:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    1408:	6f 81       	ldd	r22, Y+7	; 0x07
    140a:	78 85       	ldd	r23, Y+8	; 0x08
    140c:	89 85       	ldd	r24, Y+9	; 0x09
    140e:	9a 85       	ldd	r25, Y+10	; 0x0a
    1410:	20 e0       	ldi	r18, 0x00	; 0
    1412:	30 e0       	ldi	r19, 0x00	; 0
    1414:	40 e8       	ldi	r20, 0x80	; 128
    1416:	5f e3       	ldi	r21, 0x3F	; 63
    1418:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    141c:	88 23       	and	r24, r24
    141e:	2c f4       	brge	.+10     	; 0x142a <HLCD_enuInit+0x34a>
		__ticks = 1;
    1420:	81 e0       	ldi	r24, 0x01	; 1
    1422:	90 e0       	ldi	r25, 0x00	; 0
    1424:	9e 83       	std	Y+6, r25	; 0x06
    1426:	8d 83       	std	Y+5, r24	; 0x05
    1428:	3f c0       	rjmp	.+126    	; 0x14a8 <HLCD_enuInit+0x3c8>
	else if (__tmp > 65535)
    142a:	6f 81       	ldd	r22, Y+7	; 0x07
    142c:	78 85       	ldd	r23, Y+8	; 0x08
    142e:	89 85       	ldd	r24, Y+9	; 0x09
    1430:	9a 85       	ldd	r25, Y+10	; 0x0a
    1432:	20 e0       	ldi	r18, 0x00	; 0
    1434:	3f ef       	ldi	r19, 0xFF	; 255
    1436:	4f e7       	ldi	r20, 0x7F	; 127
    1438:	57 e4       	ldi	r21, 0x47	; 71
    143a:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    143e:	18 16       	cp	r1, r24
    1440:	4c f5       	brge	.+82     	; 0x1494 <HLCD_enuInit+0x3b4>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    1442:	6b 85       	ldd	r22, Y+11	; 0x0b
    1444:	7c 85       	ldd	r23, Y+12	; 0x0c
    1446:	8d 85       	ldd	r24, Y+13	; 0x0d
    1448:	9e 85       	ldd	r25, Y+14	; 0x0e
    144a:	20 e0       	ldi	r18, 0x00	; 0
    144c:	30 e0       	ldi	r19, 0x00	; 0
    144e:	40 e2       	ldi	r20, 0x20	; 32
    1450:	51 e4       	ldi	r21, 0x41	; 65
    1452:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1456:	dc 01       	movw	r26, r24
    1458:	cb 01       	movw	r24, r22
    145a:	bc 01       	movw	r22, r24
    145c:	cd 01       	movw	r24, r26
    145e:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1462:	dc 01       	movw	r26, r24
    1464:	cb 01       	movw	r24, r22
    1466:	9e 83       	std	Y+6, r25	; 0x06
    1468:	8d 83       	std	Y+5, r24	; 0x05
    146a:	0f c0       	rjmp	.+30     	; 0x148a <HLCD_enuInit+0x3aa>
    146c:	89 e1       	ldi	r24, 0x19	; 25
    146e:	90 e0       	ldi	r25, 0x00	; 0
    1470:	9c 83       	std	Y+4, r25	; 0x04
    1472:	8b 83       	std	Y+3, r24	; 0x03
    1474:	8b 81       	ldd	r24, Y+3	; 0x03
    1476:	9c 81       	ldd	r25, Y+4	; 0x04
    1478:	01 97       	sbiw	r24, 0x01	; 1
    147a:	f1 f7       	brne	.-4      	; 0x1478 <HLCD_enuInit+0x398>
    147c:	9c 83       	std	Y+4, r25	; 0x04
    147e:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1480:	8d 81       	ldd	r24, Y+5	; 0x05
    1482:	9e 81       	ldd	r25, Y+6	; 0x06
    1484:	01 97       	sbiw	r24, 0x01	; 1
    1486:	9e 83       	std	Y+6, r25	; 0x06
    1488:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    148a:	8d 81       	ldd	r24, Y+5	; 0x05
    148c:	9e 81       	ldd	r25, Y+6	; 0x06
    148e:	00 97       	sbiw	r24, 0x00	; 0
    1490:	69 f7       	brne	.-38     	; 0x146c <HLCD_enuInit+0x38c>
    1492:	14 c0       	rjmp	.+40     	; 0x14bc <HLCD_enuInit+0x3dc>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    1494:	6f 81       	ldd	r22, Y+7	; 0x07
    1496:	78 85       	ldd	r23, Y+8	; 0x08
    1498:	89 85       	ldd	r24, Y+9	; 0x09
    149a:	9a 85       	ldd	r25, Y+10	; 0x0a
    149c:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    14a0:	dc 01       	movw	r26, r24
    14a2:	cb 01       	movw	r24, r22
    14a4:	9e 83       	std	Y+6, r25	; 0x06
    14a6:	8d 83       	std	Y+5, r24	; 0x05
    14a8:	8d 81       	ldd	r24, Y+5	; 0x05
    14aa:	9e 81       	ldd	r25, Y+6	; 0x06
    14ac:	9a 83       	std	Y+2, r25	; 0x02
    14ae:	89 83       	std	Y+1, r24	; 0x01
    14b0:	89 81       	ldd	r24, Y+1	; 0x01
    14b2:	9a 81       	ldd	r25, Y+2	; 0x02
    14b4:	01 97       	sbiw	r24, 0x01	; 1
    14b6:	f1 f7       	brne	.-4      	; 0x14b4 <HLCD_enuInit+0x3d4>
    14b8:	9a 83       	std	Y+2, r25	; 0x02
    14ba:	89 83       	std	Y+1, r24	; 0x01
		/*							*/
		HLCD_VoidSendCommand(0b00000110);

#endif

}
    14bc:	e8 96       	adiw	r28, 0x38	; 56
    14be:	0f b6       	in	r0, 0x3f	; 63
    14c0:	f8 94       	cli
    14c2:	de bf       	out	0x3e, r29	; 62
    14c4:	0f be       	out	0x3f, r0	; 63
    14c6:	cd bf       	out	0x3d, r28	; 61
    14c8:	cf 91       	pop	r28
    14ca:	df 91       	pop	r29
    14cc:	08 95       	ret

000014ce <HLCD_VoidWriteStr>:
 *
 *		This function write the whole string in the LCD
 *
 **********************************************************************/
void HLCD_VoidWriteStr(u8 * pu8str)
{
    14ce:	df 93       	push	r29
    14d0:	cf 93       	push	r28
    14d2:	00 d0       	rcall	.+0      	; 0x14d4 <HLCD_VoidWriteStr+0x6>
    14d4:	0f 92       	push	r0
    14d6:	cd b7       	in	r28, 0x3d	; 61
    14d8:	de b7       	in	r29, 0x3e	; 62
    14da:	9b 83       	std	Y+3, r25	; 0x03
    14dc:	8a 83       	std	Y+2, r24	; 0x02
	/*Null terminator is very important that helps me a lot*/
	u8 i = 0;
    14de:	19 82       	std	Y+1, r1	; 0x01
    14e0:	0e c0       	rjmp	.+28     	; 0x14fe <HLCD_VoidWriteStr+0x30>
	/*			Here we loop till the null terminator				*/
	while(pu8str[i] != 0)
	{
		/*Send the character to the LCD in each iteration till the end*/
		HLCD_VoidSendChar(pu8str[i]);
    14e2:	89 81       	ldd	r24, Y+1	; 0x01
    14e4:	28 2f       	mov	r18, r24
    14e6:	30 e0       	ldi	r19, 0x00	; 0
    14e8:	8a 81       	ldd	r24, Y+2	; 0x02
    14ea:	9b 81       	ldd	r25, Y+3	; 0x03
    14ec:	fc 01       	movw	r30, r24
    14ee:	e2 0f       	add	r30, r18
    14f0:	f3 1f       	adc	r31, r19
    14f2:	80 81       	ld	r24, Z
    14f4:	0e 94 50 06 	call	0xca0	; 0xca0 <HLCD_VoidSendChar>
		i++;
    14f8:	89 81       	ldd	r24, Y+1	; 0x01
    14fa:	8f 5f       	subi	r24, 0xFF	; 255
    14fc:	89 83       	std	Y+1, r24	; 0x01
void HLCD_VoidWriteStr(u8 * pu8str)
{
	/*Null terminator is very important that helps me a lot*/
	u8 i = 0;
	/*			Here we loop till the null terminator				*/
	while(pu8str[i] != 0)
    14fe:	89 81       	ldd	r24, Y+1	; 0x01
    1500:	28 2f       	mov	r18, r24
    1502:	30 e0       	ldi	r19, 0x00	; 0
    1504:	8a 81       	ldd	r24, Y+2	; 0x02
    1506:	9b 81       	ldd	r25, Y+3	; 0x03
    1508:	fc 01       	movw	r30, r24
    150a:	e2 0f       	add	r30, r18
    150c:	f3 1f       	adc	r31, r19
    150e:	80 81       	ld	r24, Z
    1510:	88 23       	and	r24, r24
    1512:	39 f7       	brne	.-50     	; 0x14e2 <HLCD_VoidWriteStr+0x14>
		/*Send the character to the LCD in each iteration till the end*/
		HLCD_VoidSendChar(pu8str[i]);
		i++;
	}

}
    1514:	0f 90       	pop	r0
    1516:	0f 90       	pop	r0
    1518:	0f 90       	pop	r0
    151a:	cf 91       	pop	r28
    151c:	df 91       	pop	r29
    151e:	08 95       	ret

00001520 <HLCD_GoToXY>:
 *
 * Function to go to special position of the col
 *
 *********************************************************************/
void HLCD_GoToXY(u8 x,s8 y)
{
    1520:	df 93       	push	r29
    1522:	cf 93       	push	r28
    1524:	00 d0       	rcall	.+0      	; 0x1526 <HLCD_GoToXY+0x6>
    1526:	00 d0       	rcall	.+0      	; 0x1528 <HLCD_GoToXY+0x8>
    1528:	cd b7       	in	r28, 0x3d	; 61
    152a:	de b7       	in	r29, 0x3e	; 62
    152c:	89 83       	std	Y+1, r24	; 0x01
    152e:	6a 83       	std	Y+2, r22	; 0x02
	/*			here we check the x if it's 1 or 2					*/
	switch(x)
    1530:	89 81       	ldd	r24, Y+1	; 0x01
    1532:	28 2f       	mov	r18, r24
    1534:	30 e0       	ldi	r19, 0x00	; 0
    1536:	3c 83       	std	Y+4, r19	; 0x04
    1538:	2b 83       	std	Y+3, r18	; 0x03
    153a:	8b 81       	ldd	r24, Y+3	; 0x03
    153c:	9c 81       	ldd	r25, Y+4	; 0x04
    153e:	81 30       	cpi	r24, 0x01	; 1
    1540:	91 05       	cpc	r25, r1
    1542:	31 f0       	breq	.+12     	; 0x1550 <HLCD_GoToXY+0x30>
    1544:	2b 81       	ldd	r18, Y+3	; 0x03
    1546:	3c 81       	ldd	r19, Y+4	; 0x04
    1548:	22 30       	cpi	r18, 0x02	; 2
    154a:	31 05       	cpc	r19, r1
    154c:	31 f0       	breq	.+12     	; 0x155a <HLCD_GoToXY+0x3a>
    154e:	09 c0       	rjmp	.+18     	; 0x1562 <HLCD_GoToXY+0x42>
	{
		/* 		0x80 === 127 decimal		*/
		case 1: HLCD_VoidSendCommand(y + 127); break;
    1550:	8a 81       	ldd	r24, Y+2	; 0x02
    1552:	81 58       	subi	r24, 0x81	; 129
    1554:	0e 94 60 07 	call	0xec0	; 0xec0 <HLCD_VoidSendCommand>
    1558:	04 c0       	rjmp	.+8      	; 0x1562 <HLCD_GoToXY+0x42>
		/* 		0xBF === 191 decimal		*/
		case 2: HLCD_VoidSendCommand(y + 191); break;
    155a:	8a 81       	ldd	r24, Y+2	; 0x02
    155c:	81 54       	subi	r24, 0x41	; 65
    155e:	0e 94 60 07 	call	0xec0	; 0xec0 <HLCD_VoidSendCommand>
	}
}
    1562:	0f 90       	pop	r0
    1564:	0f 90       	pop	r0
    1566:	0f 90       	pop	r0
    1568:	0f 90       	pop	r0
    156a:	cf 91       	pop	r28
    156c:	df 91       	pop	r29
    156e:	08 95       	ret

00001570 <HLCD_VoidSendNumber>:
 *
 * This function send an int number to the LCD
 *
 ********************************************************************/
void HLCD_VoidSendNumber(u32 Number)
{
    1570:	ef 92       	push	r14
    1572:	ff 92       	push	r15
    1574:	0f 93       	push	r16
    1576:	1f 93       	push	r17
    1578:	df 93       	push	r29
    157a:	cf 93       	push	r28
    157c:	cd b7       	in	r28, 0x3d	; 61
    157e:	de b7       	in	r29, 0x3e	; 62
    1580:	2c 97       	sbiw	r28, 0x0c	; 12
    1582:	0f b6       	in	r0, 0x3f	; 63
    1584:	f8 94       	cli
    1586:	de bf       	out	0x3e, r29	; 62
    1588:	0f be       	out	0x3f, r0	; 63
    158a:	cd bf       	out	0x3d, r28	; 61
    158c:	69 87       	std	Y+9, r22	; 0x09
    158e:	7a 87       	std	Y+10, r23	; 0x0a
    1590:	8b 87       	std	Y+11, r24	; 0x0b
    1592:	9c 87       	std	Y+12, r25	; 0x0c
	if(Number == 0)
    1594:	89 85       	ldd	r24, Y+9	; 0x09
    1596:	9a 85       	ldd	r25, Y+10	; 0x0a
    1598:	ab 85       	ldd	r26, Y+11	; 0x0b
    159a:	bc 85       	ldd	r27, Y+12	; 0x0c
    159c:	00 97       	sbiw	r24, 0x00	; 0
    159e:	a1 05       	cpc	r26, r1
    15a0:	b1 05       	cpc	r27, r1
    15a2:	09 f4       	brne	.+2      	; 0x15a6 <HLCD_VoidSendNumber+0x36>
    15a4:	79 c0       	rjmp	.+242    	; 0x1698 <HLCD_VoidSendNumber+0x128>
		/*					Here Print the zero						*/
	}
	else
	{
		/*			Looping if the number is positive only 			*/
		u32 reverse = 1;
    15a6:	81 e0       	ldi	r24, 0x01	; 1
    15a8:	90 e0       	ldi	r25, 0x00	; 0
    15aa:	a0 e0       	ldi	r26, 0x00	; 0
    15ac:	b0 e0       	ldi	r27, 0x00	; 0
    15ae:	8d 83       	std	Y+5, r24	; 0x05
    15b0:	9e 83       	std	Y+6, r25	; 0x06
    15b2:	af 83       	std	Y+7, r26	; 0x07
    15b4:	b8 87       	std	Y+8, r27	; 0x08
    15b6:	36 c0       	rjmp	.+108    	; 0x1624 <HLCD_VoidSendNumber+0xb4>
		while(Number > 0)
		{
			/*	Here we reverse the number to display it on screen	*/
			reverse = (reverse * 10) + (Number  % 10);
    15b8:	8d 81       	ldd	r24, Y+5	; 0x05
    15ba:	9e 81       	ldd	r25, Y+6	; 0x06
    15bc:	af 81       	ldd	r26, Y+7	; 0x07
    15be:	b8 85       	ldd	r27, Y+8	; 0x08
    15c0:	2a e0       	ldi	r18, 0x0A	; 10
    15c2:	30 e0       	ldi	r19, 0x00	; 0
    15c4:	40 e0       	ldi	r20, 0x00	; 0
    15c6:	50 e0       	ldi	r21, 0x00	; 0
    15c8:	bc 01       	movw	r22, r24
    15ca:	cd 01       	movw	r24, r26
    15cc:	0e 94 e7 27 	call	0x4fce	; 0x4fce <__mulsi3>
    15d0:	7b 01       	movw	r14, r22
    15d2:	8c 01       	movw	r16, r24
    15d4:	89 85       	ldd	r24, Y+9	; 0x09
    15d6:	9a 85       	ldd	r25, Y+10	; 0x0a
    15d8:	ab 85       	ldd	r26, Y+11	; 0x0b
    15da:	bc 85       	ldd	r27, Y+12	; 0x0c
    15dc:	2a e0       	ldi	r18, 0x0A	; 10
    15de:	30 e0       	ldi	r19, 0x00	; 0
    15e0:	40 e0       	ldi	r20, 0x00	; 0
    15e2:	50 e0       	ldi	r21, 0x00	; 0
    15e4:	bc 01       	movw	r22, r24
    15e6:	cd 01       	movw	r24, r26
    15e8:	0e 94 06 28 	call	0x500c	; 0x500c <__udivmodsi4>
    15ec:	dc 01       	movw	r26, r24
    15ee:	cb 01       	movw	r24, r22
    15f0:	8e 0d       	add	r24, r14
    15f2:	9f 1d       	adc	r25, r15
    15f4:	a0 1f       	adc	r26, r16
    15f6:	b1 1f       	adc	r27, r17
    15f8:	8d 83       	std	Y+5, r24	; 0x05
    15fa:	9e 83       	std	Y+6, r25	; 0x06
    15fc:	af 83       	std	Y+7, r26	; 0x07
    15fe:	b8 87       	std	Y+8, r27	; 0x08
			Number = Number / 10;
    1600:	89 85       	ldd	r24, Y+9	; 0x09
    1602:	9a 85       	ldd	r25, Y+10	; 0x0a
    1604:	ab 85       	ldd	r26, Y+11	; 0x0b
    1606:	bc 85       	ldd	r27, Y+12	; 0x0c
    1608:	2a e0       	ldi	r18, 0x0A	; 10
    160a:	30 e0       	ldi	r19, 0x00	; 0
    160c:	40 e0       	ldi	r20, 0x00	; 0
    160e:	50 e0       	ldi	r21, 0x00	; 0
    1610:	bc 01       	movw	r22, r24
    1612:	cd 01       	movw	r24, r26
    1614:	0e 94 06 28 	call	0x500c	; 0x500c <__udivmodsi4>
    1618:	da 01       	movw	r26, r20
    161a:	c9 01       	movw	r24, r18
    161c:	89 87       	std	Y+9, r24	; 0x09
    161e:	9a 87       	std	Y+10, r25	; 0x0a
    1620:	ab 87       	std	Y+11, r26	; 0x0b
    1622:	bc 87       	std	Y+12, r27	; 0x0c
	}
	else
	{
		/*			Looping if the number is positive only 			*/
		u32 reverse = 1;
		while(Number > 0)
    1624:	89 85       	ldd	r24, Y+9	; 0x09
    1626:	9a 85       	ldd	r25, Y+10	; 0x0a
    1628:	ab 85       	ldd	r26, Y+11	; 0x0b
    162a:	bc 85       	ldd	r27, Y+12	; 0x0c
    162c:	00 97       	sbiw	r24, 0x00	; 0
    162e:	a1 05       	cpc	r26, r1
    1630:	b1 05       	cpc	r27, r1
    1632:	11 f6       	brne	.-124    	; 0x15b8 <HLCD_VoidSendNumber+0x48>
    1634:	28 c0       	rjmp	.+80     	; 0x1686 <HLCD_VoidSendNumber+0x116>
		}
		/*		Check if the reverse number is bigger than 1 or not */
		while(reverse > 1)
		{
			u32 remainder;
			remainder = reverse % 10;
    1636:	8d 81       	ldd	r24, Y+5	; 0x05
    1638:	9e 81       	ldd	r25, Y+6	; 0x06
    163a:	af 81       	ldd	r26, Y+7	; 0x07
    163c:	b8 85       	ldd	r27, Y+8	; 0x08
    163e:	2a e0       	ldi	r18, 0x0A	; 10
    1640:	30 e0       	ldi	r19, 0x00	; 0
    1642:	40 e0       	ldi	r20, 0x00	; 0
    1644:	50 e0       	ldi	r21, 0x00	; 0
    1646:	bc 01       	movw	r22, r24
    1648:	cd 01       	movw	r24, r26
    164a:	0e 94 06 28 	call	0x500c	; 0x500c <__udivmodsi4>
    164e:	dc 01       	movw	r26, r24
    1650:	cb 01       	movw	r24, r22
    1652:	89 83       	std	Y+1, r24	; 0x01
    1654:	9a 83       	std	Y+2, r25	; 0x02
    1656:	ab 83       	std	Y+3, r26	; 0x03
    1658:	bc 83       	std	Y+4, r27	; 0x04
			/*		Send the number to the LCD as a character		*/
			HLCD_VoidSendChar(remainder + 48);
    165a:	89 81       	ldd	r24, Y+1	; 0x01
    165c:	80 5d       	subi	r24, 0xD0	; 208
    165e:	0e 94 50 06 	call	0xca0	; 0xca0 <HLCD_VoidSendChar>
			reverse = reverse / 10;
    1662:	8d 81       	ldd	r24, Y+5	; 0x05
    1664:	9e 81       	ldd	r25, Y+6	; 0x06
    1666:	af 81       	ldd	r26, Y+7	; 0x07
    1668:	b8 85       	ldd	r27, Y+8	; 0x08
    166a:	2a e0       	ldi	r18, 0x0A	; 10
    166c:	30 e0       	ldi	r19, 0x00	; 0
    166e:	40 e0       	ldi	r20, 0x00	; 0
    1670:	50 e0       	ldi	r21, 0x00	; 0
    1672:	bc 01       	movw	r22, r24
    1674:	cd 01       	movw	r24, r26
    1676:	0e 94 06 28 	call	0x500c	; 0x500c <__udivmodsi4>
    167a:	da 01       	movw	r26, r20
    167c:	c9 01       	movw	r24, r18
    167e:	8d 83       	std	Y+5, r24	; 0x05
    1680:	9e 83       	std	Y+6, r25	; 0x06
    1682:	af 83       	std	Y+7, r26	; 0x07
    1684:	b8 87       	std	Y+8, r27	; 0x08
			/*	Here we reverse the number to display it on screen	*/
			reverse = (reverse * 10) + (Number  % 10);
			Number = Number / 10;
		}
		/*		Check if the reverse number is bigger than 1 or not */
		while(reverse > 1)
    1686:	8d 81       	ldd	r24, Y+5	; 0x05
    1688:	9e 81       	ldd	r25, Y+6	; 0x06
    168a:	af 81       	ldd	r26, Y+7	; 0x07
    168c:	b8 85       	ldd	r27, Y+8	; 0x08
    168e:	82 30       	cpi	r24, 0x02	; 2
    1690:	91 05       	cpc	r25, r1
    1692:	a1 05       	cpc	r26, r1
    1694:	b1 05       	cpc	r27, r1
    1696:	78 f6       	brcc	.-98     	; 0x1636 <HLCD_VoidSendNumber+0xc6>
			/*		Send the number to the LCD as a character		*/
			HLCD_VoidSendChar(remainder + 48);
			reverse = reverse / 10;
		}
	}
}
    1698:	2c 96       	adiw	r28, 0x0c	; 12
    169a:	0f b6       	in	r0, 0x3f	; 63
    169c:	f8 94       	cli
    169e:	de bf       	out	0x3e, r29	; 62
    16a0:	0f be       	out	0x3f, r0	; 63
    16a2:	cd bf       	out	0x3d, r28	; 61
    16a4:	cf 91       	pop	r28
    16a6:	df 91       	pop	r29
    16a8:	1f 91       	pop	r17
    16aa:	0f 91       	pop	r16
    16ac:	ff 90       	pop	r15
    16ae:	ef 90       	pop	r14
    16b0:	08 95       	ret

000016b2 <HLCD_SendFloatNumber>:
 *
 * 		This function send an float number to the LCD
 *
 *************************************************************/
void HLCD_SendFloatNumber(f32 Copy_f32Number)
{
    16b2:	df 93       	push	r29
    16b4:	cf 93       	push	r28
    16b6:	cd b7       	in	r28, 0x3d	; 61
    16b8:	de b7       	in	r29, 0x3e	; 62
    16ba:	2c 97       	sbiw	r28, 0x0c	; 12
    16bc:	0f b6       	in	r0, 0x3f	; 63
    16be:	f8 94       	cli
    16c0:	de bf       	out	0x3e, r29	; 62
    16c2:	0f be       	out	0x3f, r0	; 63
    16c4:	cd bf       	out	0x3d, r28	; 61
    16c6:	69 87       	std	Y+9, r22	; 0x09
    16c8:	7a 87       	std	Y+10, r23	; 0x0a
    16ca:	8b 87       	std	Y+11, r24	; 0x0b
    16cc:	9c 87       	std	Y+12, r25	; 0x0c
	f32 Local_f32FloatR;
	s32 Local_s32CopyNumber = (u32) Copy_f32Number;
    16ce:	69 85       	ldd	r22, Y+9	; 0x09
    16d0:	7a 85       	ldd	r23, Y+10	; 0x0a
    16d2:	8b 85       	ldd	r24, Y+11	; 0x0b
    16d4:	9c 85       	ldd	r25, Y+12	; 0x0c
    16d6:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    16da:	dc 01       	movw	r26, r24
    16dc:	cb 01       	movw	r24, r22
    16de:	89 83       	std	Y+1, r24	; 0x01
    16e0:	9a 83       	std	Y+2, r25	; 0x02
    16e2:	ab 83       	std	Y+3, r26	; 0x03
    16e4:	bc 83       	std	Y+4, r27	; 0x04
	HLCD_VoidSendNumber(Local_s32CopyNumber);
    16e6:	89 81       	ldd	r24, Y+1	; 0x01
    16e8:	9a 81       	ldd	r25, Y+2	; 0x02
    16ea:	ab 81       	ldd	r26, Y+3	; 0x03
    16ec:	bc 81       	ldd	r27, Y+4	; 0x04
    16ee:	bc 01       	movw	r22, r24
    16f0:	cd 01       	movw	r24, r26
    16f2:	0e 94 b8 0a 	call	0x1570	; 0x1570 <HLCD_VoidSendNumber>
	HLCD_VoidSendChar('.');
    16f6:	8e e2       	ldi	r24, 0x2E	; 46
    16f8:	0e 94 50 06 	call	0xca0	; 0xca0 <HLCD_VoidSendChar>

	Local_f32FloatR = (f32) Copy_f32Number - Local_s32CopyNumber;
    16fc:	69 81       	ldd	r22, Y+1	; 0x01
    16fe:	7a 81       	ldd	r23, Y+2	; 0x02
    1700:	8b 81       	ldd	r24, Y+3	; 0x03
    1702:	9c 81       	ldd	r25, Y+4	; 0x04
    1704:	0e 94 a9 03 	call	0x752	; 0x752 <__floatsisf>
    1708:	9b 01       	movw	r18, r22
    170a:	ac 01       	movw	r20, r24
    170c:	69 85       	ldd	r22, Y+9	; 0x09
    170e:	7a 85       	ldd	r23, Y+10	; 0x0a
    1710:	8b 85       	ldd	r24, Y+11	; 0x0b
    1712:	9c 85       	ldd	r25, Y+12	; 0x0c
    1714:	0e 94 c1 01 	call	0x382	; 0x382 <__subsf3>
    1718:	dc 01       	movw	r26, r24
    171a:	cb 01       	movw	r24, r22
    171c:	8d 83       	std	Y+5, r24	; 0x05
    171e:	9e 83       	std	Y+6, r25	; 0x06
    1720:	af 83       	std	Y+7, r26	; 0x07
    1722:	b8 87       	std	Y+8, r27	; 0x08
	/*				Check if the number is negative we need to get off the sign						*/
	if(Copy_f32Number < 0)
    1724:	69 85       	ldd	r22, Y+9	; 0x09
    1726:	7a 85       	ldd	r23, Y+10	; 0x0a
    1728:	8b 85       	ldd	r24, Y+11	; 0x0b
    172a:	9c 85       	ldd	r25, Y+12	; 0x0c
    172c:	20 e0       	ldi	r18, 0x00	; 0
    172e:	30 e0       	ldi	r19, 0x00	; 0
    1730:	40 e0       	ldi	r20, 0x00	; 0
    1732:	50 e0       	ldi	r21, 0x00	; 0
    1734:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    1738:	88 23       	and	r24, r24
    173a:	4c f4       	brge	.+18     	; 0x174e <HLCD_SendFloatNumber+0x9c>
	{
		Local_f32FloatR = (f32) (-1) * (Local_f32FloatR);
    173c:	8d 81       	ldd	r24, Y+5	; 0x05
    173e:	9e 81       	ldd	r25, Y+6	; 0x06
    1740:	af 81       	ldd	r26, Y+7	; 0x07
    1742:	b8 85       	ldd	r27, Y+8	; 0x08
    1744:	b0 58       	subi	r27, 0x80	; 128
    1746:	8d 83       	std	Y+5, r24	; 0x05
    1748:	9e 83       	std	Y+6, r25	; 0x06
    174a:	af 83       	std	Y+7, r26	; 0x07
    174c:	b8 87       	std	Y+8, r27	; 0x08
	}
	HLCD_VoidSendNumber((u32) Local_f32FloatR);
    174e:	6d 81       	ldd	r22, Y+5	; 0x05
    1750:	7e 81       	ldd	r23, Y+6	; 0x06
    1752:	8f 81       	ldd	r24, Y+7	; 0x07
    1754:	98 85       	ldd	r25, Y+8	; 0x08
    1756:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    175a:	dc 01       	movw	r26, r24
    175c:	cb 01       	movw	r24, r22
    175e:	bc 01       	movw	r22, r24
    1760:	cd 01       	movw	r24, r26
    1762:	0e 94 b8 0a 	call	0x1570	; 0x1570 <HLCD_VoidSendNumber>
}
    1766:	2c 96       	adiw	r28, 0x0c	; 12
    1768:	0f b6       	in	r0, 0x3f	; 63
    176a:	f8 94       	cli
    176c:	de bf       	out	0x3e, r29	; 62
    176e:	0f be       	out	0x3f, r0	; 63
    1770:	cd bf       	out	0x3d, r28	; 61
    1772:	cf 91       	pop	r28
    1774:	df 91       	pop	r29
    1776:	08 95       	ret

00001778 <HLCD_DrawCharacterE>:
 *
 * This function Draw shape E without the left
 *
 *************************************************************/
void HLCD_DrawCharacterE(void)
{
    1778:	df 93       	push	r29
    177a:	cf 93       	push	r28
    177c:	cd b7       	in	r28, 0x3d	; 61
    177e:	de b7       	in	r29, 0x3e	; 62
	HLCD_GoToXY(0,0);
    1780:	80 e0       	ldi	r24, 0x00	; 0
    1782:	60 e0       	ldi	r22, 0x00	; 0
    1784:	0e 94 90 0a 	call	0x1520	; 0x1520 <HLCD_GoToXY>
	HLCD_VoidSendCommand(0b01000000);
    1788:	80 e4       	ldi	r24, 0x40	; 64
    178a:	0e 94 60 07 	call	0xec0	; 0xec0 <HLCD_VoidSendCommand>
	HLCD_VoidSendCommand(0b01110);
    178e:	8e e0       	ldi	r24, 0x0E	; 14
    1790:	0e 94 60 07 	call	0xec0	; 0xec0 <HLCD_VoidSendCommand>
	HLCD_VoidSendCommand(0b01010);
    1794:	8a e0       	ldi	r24, 0x0A	; 10
    1796:	0e 94 60 07 	call	0xec0	; 0xec0 <HLCD_VoidSendCommand>
	HLCD_VoidSendCommand(0b01110);
    179a:	8e e0       	ldi	r24, 0x0E	; 14
    179c:	0e 94 60 07 	call	0xec0	; 0xec0 <HLCD_VoidSendCommand>
	HLCD_VoidSendCommand(0b00010);
    17a0:	82 e0       	ldi	r24, 0x02	; 2
    17a2:	0e 94 60 07 	call	0xec0	; 0xec0 <HLCD_VoidSendCommand>
	HLCD_VoidSendCommand(0b00010);
    17a6:	82 e0       	ldi	r24, 0x02	; 2
    17a8:	0e 94 60 07 	call	0xec0	; 0xec0 <HLCD_VoidSendCommand>
	HLCD_VoidSendCommand(0b01110);
    17ac:	8e e0       	ldi	r24, 0x0E	; 14
    17ae:	0e 94 60 07 	call	0xec0	; 0xec0 <HLCD_VoidSendCommand>
	HLCD_VoidSendCommand(0b00000);
    17b2:	80 e0       	ldi	r24, 0x00	; 0
    17b4:	0e 94 60 07 	call	0xec0	; 0xec0 <HLCD_VoidSendCommand>
	HLCD_VoidSendCommand(0b00000);
    17b8:	80 e0       	ldi	r24, 0x00	; 0
    17ba:	0e 94 60 07 	call	0xec0	; 0xec0 <HLCD_VoidSendCommand>
	HLCD_VoidSendChar(0);
    17be:	80 e0       	ldi	r24, 0x00	; 0
    17c0:	0e 94 50 06 	call	0xca0	; 0xca0 <HLCD_VoidSendChar>

}
    17c4:	cf 91       	pop	r28
    17c6:	df 91       	pop	r29
    17c8:	08 95       	ret

000017ca <HLCD_ClearDisplay>:
 *
 * 		This function clear all the characters on the screen
 *
 * ***********************************************************/
void HLCD_ClearDisplay(void)
{
    17ca:	df 93       	push	r29
    17cc:	cf 93       	push	r28
    17ce:	cd b7       	in	r28, 0x3d	; 61
    17d0:	de b7       	in	r29, 0x3e	; 62
	HLCD_VoidSendCommand(1);
    17d2:	81 e0       	ldi	r24, 0x01	; 1
    17d4:	0e 94 60 07 	call	0xec0	; 0xec0 <HLCD_VoidSendCommand>
}
    17d8:	cf 91       	pop	r28
    17da:	df 91       	pop	r29
    17dc:	08 95       	ret

000017de <HLCD_DrawCharacterF>:
 *
 * This function print F character on the screen
 *
 ************************************************************/
void HLCD_DrawCharacterF(void)
{
    17de:	df 93       	push	r29
    17e0:	cf 93       	push	r28
    17e2:	cd b7       	in	r28, 0x3d	; 61
    17e4:	de b7       	in	r29, 0x3e	; 62
	HLCD_GoToXY(0,3);
    17e6:	80 e0       	ldi	r24, 0x00	; 0
    17e8:	63 e0       	ldi	r22, 0x03	; 3
    17ea:	0e 94 90 0a 	call	0x1520	; 0x1520 <HLCD_GoToXY>
	HLCD_VoidSendCommand(0b01000011);
    17ee:	83 e4       	ldi	r24, 0x43	; 67
    17f0:	0e 94 60 07 	call	0xec0	; 0xec0 <HLCD_VoidSendCommand>
	HLCD_VoidSendCommand(0b00110);
    17f4:	86 e0       	ldi	r24, 0x06	; 6
    17f6:	0e 94 60 07 	call	0xec0	; 0xec0 <HLCD_VoidSendCommand>
	HLCD_VoidSendCommand(0b00100);
    17fa:	84 e0       	ldi	r24, 0x04	; 4
    17fc:	0e 94 60 07 	call	0xec0	; 0xec0 <HLCD_VoidSendCommand>
	HLCD_VoidSendCommand(0b01110);
    1800:	8e e0       	ldi	r24, 0x0E	; 14
    1802:	0e 94 60 07 	call	0xec0	; 0xec0 <HLCD_VoidSendCommand>
	HLCD_VoidSendCommand(0b00100);
    1806:	84 e0       	ldi	r24, 0x04	; 4
    1808:	0e 94 60 07 	call	0xec0	; 0xec0 <HLCD_VoidSendCommand>
	HLCD_VoidSendCommand(0b00100);
    180c:	84 e0       	ldi	r24, 0x04	; 4
    180e:	0e 94 60 07 	call	0xec0	; 0xec0 <HLCD_VoidSendCommand>
	HLCD_VoidSendCommand(0b00100);
    1812:	84 e0       	ldi	r24, 0x04	; 4
    1814:	0e 94 60 07 	call	0xec0	; 0xec0 <HLCD_VoidSendCommand>
	HLCD_VoidSendCommand(0b00100);
    1818:	84 e0       	ldi	r24, 0x04	; 4
    181a:	0e 94 60 07 	call	0xec0	; 0xec0 <HLCD_VoidSendCommand>
	HLCD_VoidSendCommand(0b00100);
    181e:	84 e0       	ldi	r24, 0x04	; 4
    1820:	0e 94 60 07 	call	0xec0	; 0xec0 <HLCD_VoidSendCommand>
	HLCD_VoidSendChar(0);
    1824:	80 e0       	ldi	r24, 0x00	; 0
    1826:	0e 94 50 06 	call	0xca0	; 0xca0 <HLCD_VoidSendChar>
}
    182a:	cf 91       	pop	r28
    182c:	df 91       	pop	r29
    182e:	08 95       	ret

00001830 <HLCD_DrawHuman>:
 *
 * This function draw a human
 *
 ***********************************************************/
void HLCD_DrawHuman(void)
{
    1830:	df 93       	push	r29
    1832:	cf 93       	push	r28
    1834:	cd b7       	in	r28, 0x3d	; 61
    1836:	de b7       	in	r29, 0x3e	; 62
	HLCD_VoidSendCommand(0b01000010);
    1838:	82 e4       	ldi	r24, 0x42	; 66
    183a:	0e 94 60 07 	call	0xec0	; 0xec0 <HLCD_VoidSendCommand>
	HLCD_GoToXY(1,5);
    183e:	81 e0       	ldi	r24, 0x01	; 1
    1840:	65 e0       	ldi	r22, 0x05	; 5
    1842:	0e 94 90 0a 	call	0x1520	; 0x1520 <HLCD_GoToXY>
	HLCD_VoidSendCommand(0b00100);
    1846:	84 e0       	ldi	r24, 0x04	; 4
    1848:	0e 94 60 07 	call	0xec0	; 0xec0 <HLCD_VoidSendCommand>
	HLCD_VoidSendCommand(0b01010);
    184c:	8a e0       	ldi	r24, 0x0A	; 10
    184e:	0e 94 60 07 	call	0xec0	; 0xec0 <HLCD_VoidSendCommand>
	HLCD_VoidSendCommand(0b01110);
    1852:	8e e0       	ldi	r24, 0x0E	; 14
    1854:	0e 94 60 07 	call	0xec0	; 0xec0 <HLCD_VoidSendCommand>
	HLCD_VoidSendCommand(0b00100);
    1858:	84 e0       	ldi	r24, 0x04	; 4
    185a:	0e 94 60 07 	call	0xec0	; 0xec0 <HLCD_VoidSendCommand>
	HLCD_VoidSendCommand(0b01110);
    185e:	8e e0       	ldi	r24, 0x0E	; 14
    1860:	0e 94 60 07 	call	0xec0	; 0xec0 <HLCD_VoidSendCommand>
	HLCD_VoidSendCommand(0b10101);
    1864:	85 e1       	ldi	r24, 0x15	; 21
    1866:	0e 94 60 07 	call	0xec0	; 0xec0 <HLCD_VoidSendCommand>
	HLCD_VoidSendCommand(0b00100);
    186a:	84 e0       	ldi	r24, 0x04	; 4
    186c:	0e 94 60 07 	call	0xec0	; 0xec0 <HLCD_VoidSendCommand>
	HLCD_VoidSendCommand(0b00100);
    1870:	84 e0       	ldi	r24, 0x04	; 4
    1872:	0e 94 60 07 	call	0xec0	; 0xec0 <HLCD_VoidSendCommand>
	HLCD_VoidSendChar(0);
    1876:	80 e0       	ldi	r24, 0x00	; 0
    1878:	0e 94 50 06 	call	0xca0	; 0xca0 <HLCD_VoidSendChar>
}
    187c:	cf 91       	pop	r28
    187e:	df 91       	pop	r29
    1880:	08 95       	ret

00001882 <HLCD_S32Private_GetPower>:
 *
 * 		This is a private function that get the power of a number
 *
 ****************************************************************************/
s32 HLCD_S32Private_GetPower(u8 Copy_u8BaseNumber, u8 Copy_PowerNumber)
{
    1882:	df 93       	push	r29
    1884:	cf 93       	push	r28
    1886:	cd b7       	in	r28, 0x3d	; 61
    1888:	de b7       	in	r29, 0x3e	; 62
    188a:	28 97       	sbiw	r28, 0x08	; 8
    188c:	0f b6       	in	r0, 0x3f	; 63
    188e:	f8 94       	cli
    1890:	de bf       	out	0x3e, r29	; 62
    1892:	0f be       	out	0x3f, r0	; 63
    1894:	cd bf       	out	0x3d, r28	; 61
    1896:	8b 83       	std	Y+3, r24	; 0x03
    1898:	6c 83       	std	Y+4, r22	; 0x04
	u8 Copy_u8Counter = Copy_PowerNumber;
    189a:	8c 81       	ldd	r24, Y+4	; 0x04
    189c:	8a 83       	std	Y+2, r24	; 0x02
	u8 Copy_u8NumberAfterPower = 0;
    189e:	19 82       	std	Y+1, r1	; 0x01
    18a0:	09 c0       	rjmp	.+18     	; 0x18b4 <HLCD_S32Private_GetPower+0x32>
	while(Copy_u8Counter != 0)
	{
		Copy_u8NumberAfterPower = Copy_u8BaseNumber * Copy_u8BaseNumber;
    18a2:	9b 81       	ldd	r25, Y+3	; 0x03
    18a4:	8b 81       	ldd	r24, Y+3	; 0x03
    18a6:	98 9f       	mul	r25, r24
    18a8:	80 2d       	mov	r24, r0
    18aa:	11 24       	eor	r1, r1
    18ac:	89 83       	std	Y+1, r24	; 0x01
		Copy_u8Counter--;
    18ae:	8a 81       	ldd	r24, Y+2	; 0x02
    18b0:	81 50       	subi	r24, 0x01	; 1
    18b2:	8a 83       	std	Y+2, r24	; 0x02
 ****************************************************************************/
s32 HLCD_S32Private_GetPower(u8 Copy_u8BaseNumber, u8 Copy_PowerNumber)
{
	u8 Copy_u8Counter = Copy_PowerNumber;
	u8 Copy_u8NumberAfterPower = 0;
	while(Copy_u8Counter != 0)
    18b4:	8a 81       	ldd	r24, Y+2	; 0x02
    18b6:	88 23       	and	r24, r24
    18b8:	a1 f7       	brne	.-24     	; 0x18a2 <HLCD_S32Private_GetPower+0x20>
	{
		Copy_u8NumberAfterPower = Copy_u8BaseNumber * Copy_u8BaseNumber;
		Copy_u8Counter--;
	}
}
    18ba:	28 96       	adiw	r28, 0x08	; 8
    18bc:	0f b6       	in	r0, 0x3f	; 63
    18be:	f8 94       	cli
    18c0:	de bf       	out	0x3e, r29	; 62
    18c2:	0f be       	out	0x3f, r0	; 63
    18c4:	cd bf       	out	0x3d, r28	; 61
    18c6:	cf 91       	pop	r28
    18c8:	df 91       	pop	r29
    18ca:	08 95       	ret

000018cc <HLCD_StoreCustomCharacter>:
 *
 * 		This function stores a custom pattern passed by an array
 *
 ***************************************************************************/
void HLCD_StoreCustomCharacter(u8 Copy_char_Index, u8 * Copy_Pattern)
{
    18cc:	df 93       	push	r29
    18ce:	cf 93       	push	r28
    18d0:	00 d0       	rcall	.+0      	; 0x18d2 <HLCD_StoreCustomCharacter+0x6>
    18d2:	00 d0       	rcall	.+0      	; 0x18d4 <HLCD_StoreCustomCharacter+0x8>
    18d4:	0f 92       	push	r0
    18d6:	cd b7       	in	r28, 0x3d	; 61
    18d8:	de b7       	in	r29, 0x3e	; 62
    18da:	8b 83       	std	Y+3, r24	; 0x03
    18dc:	7d 83       	std	Y+5, r23	; 0x05
    18de:	6c 83       	std	Y+4, r22	; 0x04
	u8 Local_CGRAMAdd = Copy_char_Index * 8;
    18e0:	8b 81       	ldd	r24, Y+3	; 0x03
    18e2:	88 2f       	mov	r24, r24
    18e4:	90 e0       	ldi	r25, 0x00	; 0
    18e6:	88 0f       	add	r24, r24
    18e8:	99 1f       	adc	r25, r25
    18ea:	88 0f       	add	r24, r24
    18ec:	99 1f       	adc	r25, r25
    18ee:	88 0f       	add	r24, r24
    18f0:	99 1f       	adc	r25, r25
    18f2:	8a 83       	std	Y+2, r24	; 0x02
	/*			Set CGRAM address										*/
	HLCD_VoidSendCommand(0b01000000 + Local_CGRAMAdd);
    18f4:	8a 81       	ldd	r24, Y+2	; 0x02
    18f6:	80 5c       	subi	r24, 0xC0	; 192
    18f8:	0e 94 60 07 	call	0xec0	; 0xec0 <HLCD_VoidSendCommand>
	/*			put the pattern in CGRAM								*/
	for(u8 Local_Counter = 0; Local_Counter < 8; Local_Counter++)
    18fc:	19 82       	std	Y+1, r1	; 0x01
    18fe:	0e c0       	rjmp	.+28     	; 0x191c <HLCD_StoreCustomCharacter+0x50>
	{
		HLCD_VoidSendChar(Copy_Pattern[Local_Counter]);
    1900:	89 81       	ldd	r24, Y+1	; 0x01
    1902:	28 2f       	mov	r18, r24
    1904:	30 e0       	ldi	r19, 0x00	; 0
    1906:	8c 81       	ldd	r24, Y+4	; 0x04
    1908:	9d 81       	ldd	r25, Y+5	; 0x05
    190a:	fc 01       	movw	r30, r24
    190c:	e2 0f       	add	r30, r18
    190e:	f3 1f       	adc	r31, r19
    1910:	80 81       	ld	r24, Z
    1912:	0e 94 50 06 	call	0xca0	; 0xca0 <HLCD_VoidSendChar>
{
	u8 Local_CGRAMAdd = Copy_char_Index * 8;
	/*			Set CGRAM address										*/
	HLCD_VoidSendCommand(0b01000000 + Local_CGRAMAdd);
	/*			put the pattern in CGRAM								*/
	for(u8 Local_Counter = 0; Local_Counter < 8; Local_Counter++)
    1916:	89 81       	ldd	r24, Y+1	; 0x01
    1918:	8f 5f       	subi	r24, 0xFF	; 255
    191a:	89 83       	std	Y+1, r24	; 0x01
    191c:	89 81       	ldd	r24, Y+1	; 0x01
    191e:	88 30       	cpi	r24, 0x08	; 8
    1920:	78 f3       	brcs	.-34     	; 0x1900 <HLCD_StoreCustomCharacter+0x34>
	{
		HLCD_VoidSendChar(Copy_Pattern[Local_Counter]);
	}
}
    1922:	0f 90       	pop	r0
    1924:	0f 90       	pop	r0
    1926:	0f 90       	pop	r0
    1928:	0f 90       	pop	r0
    192a:	0f 90       	pop	r0
    192c:	cf 91       	pop	r28
    192e:	df 91       	pop	r29
    1930:	08 95       	ret

00001932 <HLCD_ShiftDisplayLeft>:
 *
 * 		This Function Shift the display to the left
 *
 ***************************************************************************/
void HLCD_ShiftDisplayLeft()
{
    1932:	df 93       	push	r29
    1934:	cf 93       	push	r28
    1936:	cd b7       	in	r28, 0x3d	; 61
    1938:	de b7       	in	r29, 0x3e	; 62
    193a:	2e 97       	sbiw	r28, 0x0e	; 14
    193c:	0f b6       	in	r0, 0x3f	; 63
    193e:	f8 94       	cli
    1940:	de bf       	out	0x3e, r29	; 62
    1942:	0f be       	out	0x3f, r0	; 63
    1944:	cd bf       	out	0x3d, r28	; 61
	HLCD_VoidSendCommand(0b000110);
    1946:	86 e0       	ldi	r24, 0x06	; 6
    1948:	0e 94 60 07 	call	0xec0	; 0xec0 <HLCD_VoidSendCommand>
    194c:	80 e0       	ldi	r24, 0x00	; 0
    194e:	90 e0       	ldi	r25, 0x00	; 0
    1950:	a0 e0       	ldi	r26, 0x00	; 0
    1952:	b0 e4       	ldi	r27, 0x40	; 64
    1954:	8b 87       	std	Y+11, r24	; 0x0b
    1956:	9c 87       	std	Y+12, r25	; 0x0c
    1958:	ad 87       	std	Y+13, r26	; 0x0d
    195a:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    195c:	6b 85       	ldd	r22, Y+11	; 0x0b
    195e:	7c 85       	ldd	r23, Y+12	; 0x0c
    1960:	8d 85       	ldd	r24, Y+13	; 0x0d
    1962:	9e 85       	ldd	r25, Y+14	; 0x0e
    1964:	20 e0       	ldi	r18, 0x00	; 0
    1966:	30 e0       	ldi	r19, 0x00	; 0
    1968:	4a e7       	ldi	r20, 0x7A	; 122
    196a:	53 e4       	ldi	r21, 0x43	; 67
    196c:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1970:	dc 01       	movw	r26, r24
    1972:	cb 01       	movw	r24, r22
    1974:	8f 83       	std	Y+7, r24	; 0x07
    1976:	98 87       	std	Y+8, r25	; 0x08
    1978:	a9 87       	std	Y+9, r26	; 0x09
    197a:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    197c:	6f 81       	ldd	r22, Y+7	; 0x07
    197e:	78 85       	ldd	r23, Y+8	; 0x08
    1980:	89 85       	ldd	r24, Y+9	; 0x09
    1982:	9a 85       	ldd	r25, Y+10	; 0x0a
    1984:	20 e0       	ldi	r18, 0x00	; 0
    1986:	30 e0       	ldi	r19, 0x00	; 0
    1988:	40 e8       	ldi	r20, 0x80	; 128
    198a:	5f e3       	ldi	r21, 0x3F	; 63
    198c:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    1990:	88 23       	and	r24, r24
    1992:	2c f4       	brge	.+10     	; 0x199e <HLCD_ShiftDisplayLeft+0x6c>
		__ticks = 1;
    1994:	81 e0       	ldi	r24, 0x01	; 1
    1996:	90 e0       	ldi	r25, 0x00	; 0
    1998:	9e 83       	std	Y+6, r25	; 0x06
    199a:	8d 83       	std	Y+5, r24	; 0x05
    199c:	3f c0       	rjmp	.+126    	; 0x1a1c <HLCD_ShiftDisplayLeft+0xea>
	else if (__tmp > 65535)
    199e:	6f 81       	ldd	r22, Y+7	; 0x07
    19a0:	78 85       	ldd	r23, Y+8	; 0x08
    19a2:	89 85       	ldd	r24, Y+9	; 0x09
    19a4:	9a 85       	ldd	r25, Y+10	; 0x0a
    19a6:	20 e0       	ldi	r18, 0x00	; 0
    19a8:	3f ef       	ldi	r19, 0xFF	; 255
    19aa:	4f e7       	ldi	r20, 0x7F	; 127
    19ac:	57 e4       	ldi	r21, 0x47	; 71
    19ae:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    19b2:	18 16       	cp	r1, r24
    19b4:	4c f5       	brge	.+82     	; 0x1a08 <HLCD_ShiftDisplayLeft+0xd6>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    19b6:	6b 85       	ldd	r22, Y+11	; 0x0b
    19b8:	7c 85       	ldd	r23, Y+12	; 0x0c
    19ba:	8d 85       	ldd	r24, Y+13	; 0x0d
    19bc:	9e 85       	ldd	r25, Y+14	; 0x0e
    19be:	20 e0       	ldi	r18, 0x00	; 0
    19c0:	30 e0       	ldi	r19, 0x00	; 0
    19c2:	40 e2       	ldi	r20, 0x20	; 32
    19c4:	51 e4       	ldi	r21, 0x41	; 65
    19c6:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    19ca:	dc 01       	movw	r26, r24
    19cc:	cb 01       	movw	r24, r22
    19ce:	bc 01       	movw	r22, r24
    19d0:	cd 01       	movw	r24, r26
    19d2:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    19d6:	dc 01       	movw	r26, r24
    19d8:	cb 01       	movw	r24, r22
    19da:	9e 83       	std	Y+6, r25	; 0x06
    19dc:	8d 83       	std	Y+5, r24	; 0x05
    19de:	0f c0       	rjmp	.+30     	; 0x19fe <HLCD_ShiftDisplayLeft+0xcc>
    19e0:	89 e1       	ldi	r24, 0x19	; 25
    19e2:	90 e0       	ldi	r25, 0x00	; 0
    19e4:	9c 83       	std	Y+4, r25	; 0x04
    19e6:	8b 83       	std	Y+3, r24	; 0x03
    19e8:	8b 81       	ldd	r24, Y+3	; 0x03
    19ea:	9c 81       	ldd	r25, Y+4	; 0x04
    19ec:	01 97       	sbiw	r24, 0x01	; 1
    19ee:	f1 f7       	brne	.-4      	; 0x19ec <HLCD_ShiftDisplayLeft+0xba>
    19f0:	9c 83       	std	Y+4, r25	; 0x04
    19f2:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    19f4:	8d 81       	ldd	r24, Y+5	; 0x05
    19f6:	9e 81       	ldd	r25, Y+6	; 0x06
    19f8:	01 97       	sbiw	r24, 0x01	; 1
    19fa:	9e 83       	std	Y+6, r25	; 0x06
    19fc:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    19fe:	8d 81       	ldd	r24, Y+5	; 0x05
    1a00:	9e 81       	ldd	r25, Y+6	; 0x06
    1a02:	00 97       	sbiw	r24, 0x00	; 0
    1a04:	69 f7       	brne	.-38     	; 0x19e0 <HLCD_ShiftDisplayLeft+0xae>
    1a06:	14 c0       	rjmp	.+40     	; 0x1a30 <HLCD_ShiftDisplayLeft+0xfe>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    1a08:	6f 81       	ldd	r22, Y+7	; 0x07
    1a0a:	78 85       	ldd	r23, Y+8	; 0x08
    1a0c:	89 85       	ldd	r24, Y+9	; 0x09
    1a0e:	9a 85       	ldd	r25, Y+10	; 0x0a
    1a10:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1a14:	dc 01       	movw	r26, r24
    1a16:	cb 01       	movw	r24, r22
    1a18:	9e 83       	std	Y+6, r25	; 0x06
    1a1a:	8d 83       	std	Y+5, r24	; 0x05
    1a1c:	8d 81       	ldd	r24, Y+5	; 0x05
    1a1e:	9e 81       	ldd	r25, Y+6	; 0x06
    1a20:	9a 83       	std	Y+2, r25	; 0x02
    1a22:	89 83       	std	Y+1, r24	; 0x01
    1a24:	89 81       	ldd	r24, Y+1	; 0x01
    1a26:	9a 81       	ldd	r25, Y+2	; 0x02
    1a28:	01 97       	sbiw	r24, 0x01	; 1
    1a2a:	f1 f7       	brne	.-4      	; 0x1a28 <HLCD_ShiftDisplayLeft+0xf6>
    1a2c:	9a 83       	std	Y+2, r25	; 0x02
    1a2e:	89 83       	std	Y+1, r24	; 0x01
	_delay_ms(2);
}
    1a30:	2e 96       	adiw	r28, 0x0e	; 14
    1a32:	0f b6       	in	r0, 0x3f	; 63
    1a34:	f8 94       	cli
    1a36:	de bf       	out	0x3e, r29	; 62
    1a38:	0f be       	out	0x3f, r0	; 63
    1a3a:	cd bf       	out	0x3d, r28	; 61
    1a3c:	cf 91       	pop	r28
    1a3e:	df 91       	pop	r29
    1a40:	08 95       	ret

00001a42 <HLCD_ShiftDisplayRight>:
 *
 * 		This Function Shift the display to the right
 *
 **************************************************************************/
void HLCD_ShiftDisplayRight()
{
    1a42:	df 93       	push	r29
    1a44:	cf 93       	push	r28
    1a46:	cd b7       	in	r28, 0x3d	; 61
    1a48:	de b7       	in	r29, 0x3e	; 62
    1a4a:	2e 97       	sbiw	r28, 0x0e	; 14
    1a4c:	0f b6       	in	r0, 0x3f	; 63
    1a4e:	f8 94       	cli
    1a50:	de bf       	out	0x3e, r29	; 62
    1a52:	0f be       	out	0x3f, r0	; 63
    1a54:	cd bf       	out	0x3d, r28	; 61
	HLCD_VoidSendCommand(0b000111);
    1a56:	87 e0       	ldi	r24, 0x07	; 7
    1a58:	0e 94 60 07 	call	0xec0	; 0xec0 <HLCD_VoidSendCommand>
    1a5c:	80 e0       	ldi	r24, 0x00	; 0
    1a5e:	90 e0       	ldi	r25, 0x00	; 0
    1a60:	a0 e0       	ldi	r26, 0x00	; 0
    1a62:	b0 e4       	ldi	r27, 0x40	; 64
    1a64:	8b 87       	std	Y+11, r24	; 0x0b
    1a66:	9c 87       	std	Y+12, r25	; 0x0c
    1a68:	ad 87       	std	Y+13, r26	; 0x0d
    1a6a:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    1a6c:	6b 85       	ldd	r22, Y+11	; 0x0b
    1a6e:	7c 85       	ldd	r23, Y+12	; 0x0c
    1a70:	8d 85       	ldd	r24, Y+13	; 0x0d
    1a72:	9e 85       	ldd	r25, Y+14	; 0x0e
    1a74:	20 e0       	ldi	r18, 0x00	; 0
    1a76:	30 e0       	ldi	r19, 0x00	; 0
    1a78:	4a e7       	ldi	r20, 0x7A	; 122
    1a7a:	53 e4       	ldi	r21, 0x43	; 67
    1a7c:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1a80:	dc 01       	movw	r26, r24
    1a82:	cb 01       	movw	r24, r22
    1a84:	8f 83       	std	Y+7, r24	; 0x07
    1a86:	98 87       	std	Y+8, r25	; 0x08
    1a88:	a9 87       	std	Y+9, r26	; 0x09
    1a8a:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    1a8c:	6f 81       	ldd	r22, Y+7	; 0x07
    1a8e:	78 85       	ldd	r23, Y+8	; 0x08
    1a90:	89 85       	ldd	r24, Y+9	; 0x09
    1a92:	9a 85       	ldd	r25, Y+10	; 0x0a
    1a94:	20 e0       	ldi	r18, 0x00	; 0
    1a96:	30 e0       	ldi	r19, 0x00	; 0
    1a98:	40 e8       	ldi	r20, 0x80	; 128
    1a9a:	5f e3       	ldi	r21, 0x3F	; 63
    1a9c:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    1aa0:	88 23       	and	r24, r24
    1aa2:	2c f4       	brge	.+10     	; 0x1aae <HLCD_ShiftDisplayRight+0x6c>
		__ticks = 1;
    1aa4:	81 e0       	ldi	r24, 0x01	; 1
    1aa6:	90 e0       	ldi	r25, 0x00	; 0
    1aa8:	9e 83       	std	Y+6, r25	; 0x06
    1aaa:	8d 83       	std	Y+5, r24	; 0x05
    1aac:	3f c0       	rjmp	.+126    	; 0x1b2c <HLCD_ShiftDisplayRight+0xea>
	else if (__tmp > 65535)
    1aae:	6f 81       	ldd	r22, Y+7	; 0x07
    1ab0:	78 85       	ldd	r23, Y+8	; 0x08
    1ab2:	89 85       	ldd	r24, Y+9	; 0x09
    1ab4:	9a 85       	ldd	r25, Y+10	; 0x0a
    1ab6:	20 e0       	ldi	r18, 0x00	; 0
    1ab8:	3f ef       	ldi	r19, 0xFF	; 255
    1aba:	4f e7       	ldi	r20, 0x7F	; 127
    1abc:	57 e4       	ldi	r21, 0x47	; 71
    1abe:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    1ac2:	18 16       	cp	r1, r24
    1ac4:	4c f5       	brge	.+82     	; 0x1b18 <HLCD_ShiftDisplayRight+0xd6>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    1ac6:	6b 85       	ldd	r22, Y+11	; 0x0b
    1ac8:	7c 85       	ldd	r23, Y+12	; 0x0c
    1aca:	8d 85       	ldd	r24, Y+13	; 0x0d
    1acc:	9e 85       	ldd	r25, Y+14	; 0x0e
    1ace:	20 e0       	ldi	r18, 0x00	; 0
    1ad0:	30 e0       	ldi	r19, 0x00	; 0
    1ad2:	40 e2       	ldi	r20, 0x20	; 32
    1ad4:	51 e4       	ldi	r21, 0x41	; 65
    1ad6:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1ada:	dc 01       	movw	r26, r24
    1adc:	cb 01       	movw	r24, r22
    1ade:	bc 01       	movw	r22, r24
    1ae0:	cd 01       	movw	r24, r26
    1ae2:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1ae6:	dc 01       	movw	r26, r24
    1ae8:	cb 01       	movw	r24, r22
    1aea:	9e 83       	std	Y+6, r25	; 0x06
    1aec:	8d 83       	std	Y+5, r24	; 0x05
    1aee:	0f c0       	rjmp	.+30     	; 0x1b0e <HLCD_ShiftDisplayRight+0xcc>
    1af0:	89 e1       	ldi	r24, 0x19	; 25
    1af2:	90 e0       	ldi	r25, 0x00	; 0
    1af4:	9c 83       	std	Y+4, r25	; 0x04
    1af6:	8b 83       	std	Y+3, r24	; 0x03
    1af8:	8b 81       	ldd	r24, Y+3	; 0x03
    1afa:	9c 81       	ldd	r25, Y+4	; 0x04
    1afc:	01 97       	sbiw	r24, 0x01	; 1
    1afe:	f1 f7       	brne	.-4      	; 0x1afc <HLCD_ShiftDisplayRight+0xba>
    1b00:	9c 83       	std	Y+4, r25	; 0x04
    1b02:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1b04:	8d 81       	ldd	r24, Y+5	; 0x05
    1b06:	9e 81       	ldd	r25, Y+6	; 0x06
    1b08:	01 97       	sbiw	r24, 0x01	; 1
    1b0a:	9e 83       	std	Y+6, r25	; 0x06
    1b0c:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1b0e:	8d 81       	ldd	r24, Y+5	; 0x05
    1b10:	9e 81       	ldd	r25, Y+6	; 0x06
    1b12:	00 97       	sbiw	r24, 0x00	; 0
    1b14:	69 f7       	brne	.-38     	; 0x1af0 <HLCD_ShiftDisplayRight+0xae>
    1b16:	14 c0       	rjmp	.+40     	; 0x1b40 <HLCD_ShiftDisplayRight+0xfe>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    1b18:	6f 81       	ldd	r22, Y+7	; 0x07
    1b1a:	78 85       	ldd	r23, Y+8	; 0x08
    1b1c:	89 85       	ldd	r24, Y+9	; 0x09
    1b1e:	9a 85       	ldd	r25, Y+10	; 0x0a
    1b20:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1b24:	dc 01       	movw	r26, r24
    1b26:	cb 01       	movw	r24, r22
    1b28:	9e 83       	std	Y+6, r25	; 0x06
    1b2a:	8d 83       	std	Y+5, r24	; 0x05
    1b2c:	8d 81       	ldd	r24, Y+5	; 0x05
    1b2e:	9e 81       	ldd	r25, Y+6	; 0x06
    1b30:	9a 83       	std	Y+2, r25	; 0x02
    1b32:	89 83       	std	Y+1, r24	; 0x01
    1b34:	89 81       	ldd	r24, Y+1	; 0x01
    1b36:	9a 81       	ldd	r25, Y+2	; 0x02
    1b38:	01 97       	sbiw	r24, 0x01	; 1
    1b3a:	f1 f7       	brne	.-4      	; 0x1b38 <HLCD_ShiftDisplayRight+0xf6>
    1b3c:	9a 83       	std	Y+2, r25	; 0x02
    1b3e:	89 83       	std	Y+1, r24	; 0x01
	_delay_ms(2);
}
    1b40:	2e 96       	adiw	r28, 0x0e	; 14
    1b42:	0f b6       	in	r0, 0x3f	; 63
    1b44:	f8 94       	cli
    1b46:	de bf       	out	0x3e, r29	; 62
    1b48:	0f be       	out	0x3f, r0	; 63
    1b4a:	cd bf       	out	0x3d, r28	; 61
    1b4c:	cf 91       	pop	r28
    1b4e:	df 91       	pop	r29
    1b50:	08 95       	ret

00001b52 <HLCD_ShiftCursorLeft>:
 *
 * 		This function shift the cursor to the left
 *
 * **************************************************/
void HLCD_ShiftCursorLeft(void)
{
    1b52:	df 93       	push	r29
    1b54:	cf 93       	push	r28
    1b56:	cd b7       	in	r28, 0x3d	; 61
    1b58:	de b7       	in	r29, 0x3e	; 62
    1b5a:	2e 97       	sbiw	r28, 0x0e	; 14
    1b5c:	0f b6       	in	r0, 0x3f	; 63
    1b5e:	f8 94       	cli
    1b60:	de bf       	out	0x3e, r29	; 62
    1b62:	0f be       	out	0x3f, r0	; 63
    1b64:	cd bf       	out	0x3d, r28	; 61
	HLCD_VoidSendCommand(0b000100);
    1b66:	84 e0       	ldi	r24, 0x04	; 4
    1b68:	0e 94 60 07 	call	0xec0	; 0xec0 <HLCD_VoidSendCommand>
    1b6c:	80 e0       	ldi	r24, 0x00	; 0
    1b6e:	90 e0       	ldi	r25, 0x00	; 0
    1b70:	a0 e0       	ldi	r26, 0x00	; 0
    1b72:	b0 e4       	ldi	r27, 0x40	; 64
    1b74:	8b 87       	std	Y+11, r24	; 0x0b
    1b76:	9c 87       	std	Y+12, r25	; 0x0c
    1b78:	ad 87       	std	Y+13, r26	; 0x0d
    1b7a:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    1b7c:	6b 85       	ldd	r22, Y+11	; 0x0b
    1b7e:	7c 85       	ldd	r23, Y+12	; 0x0c
    1b80:	8d 85       	ldd	r24, Y+13	; 0x0d
    1b82:	9e 85       	ldd	r25, Y+14	; 0x0e
    1b84:	20 e0       	ldi	r18, 0x00	; 0
    1b86:	30 e0       	ldi	r19, 0x00	; 0
    1b88:	4a e7       	ldi	r20, 0x7A	; 122
    1b8a:	53 e4       	ldi	r21, 0x43	; 67
    1b8c:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1b90:	dc 01       	movw	r26, r24
    1b92:	cb 01       	movw	r24, r22
    1b94:	8f 83       	std	Y+7, r24	; 0x07
    1b96:	98 87       	std	Y+8, r25	; 0x08
    1b98:	a9 87       	std	Y+9, r26	; 0x09
    1b9a:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    1b9c:	6f 81       	ldd	r22, Y+7	; 0x07
    1b9e:	78 85       	ldd	r23, Y+8	; 0x08
    1ba0:	89 85       	ldd	r24, Y+9	; 0x09
    1ba2:	9a 85       	ldd	r25, Y+10	; 0x0a
    1ba4:	20 e0       	ldi	r18, 0x00	; 0
    1ba6:	30 e0       	ldi	r19, 0x00	; 0
    1ba8:	40 e8       	ldi	r20, 0x80	; 128
    1baa:	5f e3       	ldi	r21, 0x3F	; 63
    1bac:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    1bb0:	88 23       	and	r24, r24
    1bb2:	2c f4       	brge	.+10     	; 0x1bbe <HLCD_ShiftCursorLeft+0x6c>
		__ticks = 1;
    1bb4:	81 e0       	ldi	r24, 0x01	; 1
    1bb6:	90 e0       	ldi	r25, 0x00	; 0
    1bb8:	9e 83       	std	Y+6, r25	; 0x06
    1bba:	8d 83       	std	Y+5, r24	; 0x05
    1bbc:	3f c0       	rjmp	.+126    	; 0x1c3c <HLCD_ShiftCursorLeft+0xea>
	else if (__tmp > 65535)
    1bbe:	6f 81       	ldd	r22, Y+7	; 0x07
    1bc0:	78 85       	ldd	r23, Y+8	; 0x08
    1bc2:	89 85       	ldd	r24, Y+9	; 0x09
    1bc4:	9a 85       	ldd	r25, Y+10	; 0x0a
    1bc6:	20 e0       	ldi	r18, 0x00	; 0
    1bc8:	3f ef       	ldi	r19, 0xFF	; 255
    1bca:	4f e7       	ldi	r20, 0x7F	; 127
    1bcc:	57 e4       	ldi	r21, 0x47	; 71
    1bce:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    1bd2:	18 16       	cp	r1, r24
    1bd4:	4c f5       	brge	.+82     	; 0x1c28 <HLCD_ShiftCursorLeft+0xd6>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    1bd6:	6b 85       	ldd	r22, Y+11	; 0x0b
    1bd8:	7c 85       	ldd	r23, Y+12	; 0x0c
    1bda:	8d 85       	ldd	r24, Y+13	; 0x0d
    1bdc:	9e 85       	ldd	r25, Y+14	; 0x0e
    1bde:	20 e0       	ldi	r18, 0x00	; 0
    1be0:	30 e0       	ldi	r19, 0x00	; 0
    1be2:	40 e2       	ldi	r20, 0x20	; 32
    1be4:	51 e4       	ldi	r21, 0x41	; 65
    1be6:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1bea:	dc 01       	movw	r26, r24
    1bec:	cb 01       	movw	r24, r22
    1bee:	bc 01       	movw	r22, r24
    1bf0:	cd 01       	movw	r24, r26
    1bf2:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1bf6:	dc 01       	movw	r26, r24
    1bf8:	cb 01       	movw	r24, r22
    1bfa:	9e 83       	std	Y+6, r25	; 0x06
    1bfc:	8d 83       	std	Y+5, r24	; 0x05
    1bfe:	0f c0       	rjmp	.+30     	; 0x1c1e <HLCD_ShiftCursorLeft+0xcc>
    1c00:	89 e1       	ldi	r24, 0x19	; 25
    1c02:	90 e0       	ldi	r25, 0x00	; 0
    1c04:	9c 83       	std	Y+4, r25	; 0x04
    1c06:	8b 83       	std	Y+3, r24	; 0x03
    1c08:	8b 81       	ldd	r24, Y+3	; 0x03
    1c0a:	9c 81       	ldd	r25, Y+4	; 0x04
    1c0c:	01 97       	sbiw	r24, 0x01	; 1
    1c0e:	f1 f7       	brne	.-4      	; 0x1c0c <HLCD_ShiftCursorLeft+0xba>
    1c10:	9c 83       	std	Y+4, r25	; 0x04
    1c12:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1c14:	8d 81       	ldd	r24, Y+5	; 0x05
    1c16:	9e 81       	ldd	r25, Y+6	; 0x06
    1c18:	01 97       	sbiw	r24, 0x01	; 1
    1c1a:	9e 83       	std	Y+6, r25	; 0x06
    1c1c:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1c1e:	8d 81       	ldd	r24, Y+5	; 0x05
    1c20:	9e 81       	ldd	r25, Y+6	; 0x06
    1c22:	00 97       	sbiw	r24, 0x00	; 0
    1c24:	69 f7       	brne	.-38     	; 0x1c00 <HLCD_ShiftCursorLeft+0xae>
    1c26:	14 c0       	rjmp	.+40     	; 0x1c50 <HLCD_ShiftCursorLeft+0xfe>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    1c28:	6f 81       	ldd	r22, Y+7	; 0x07
    1c2a:	78 85       	ldd	r23, Y+8	; 0x08
    1c2c:	89 85       	ldd	r24, Y+9	; 0x09
    1c2e:	9a 85       	ldd	r25, Y+10	; 0x0a
    1c30:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1c34:	dc 01       	movw	r26, r24
    1c36:	cb 01       	movw	r24, r22
    1c38:	9e 83       	std	Y+6, r25	; 0x06
    1c3a:	8d 83       	std	Y+5, r24	; 0x05
    1c3c:	8d 81       	ldd	r24, Y+5	; 0x05
    1c3e:	9e 81       	ldd	r25, Y+6	; 0x06
    1c40:	9a 83       	std	Y+2, r25	; 0x02
    1c42:	89 83       	std	Y+1, r24	; 0x01
    1c44:	89 81       	ldd	r24, Y+1	; 0x01
    1c46:	9a 81       	ldd	r25, Y+2	; 0x02
    1c48:	01 97       	sbiw	r24, 0x01	; 1
    1c4a:	f1 f7       	brne	.-4      	; 0x1c48 <HLCD_ShiftCursorLeft+0xf6>
    1c4c:	9a 83       	std	Y+2, r25	; 0x02
    1c4e:	89 83       	std	Y+1, r24	; 0x01
	_delay_ms(2);
}
    1c50:	2e 96       	adiw	r28, 0x0e	; 14
    1c52:	0f b6       	in	r0, 0x3f	; 63
    1c54:	f8 94       	cli
    1c56:	de bf       	out	0x3e, r29	; 62
    1c58:	0f be       	out	0x3f, r0	; 63
    1c5a:	cd bf       	out	0x3d, r28	; 61
    1c5c:	cf 91       	pop	r28
    1c5e:	df 91       	pop	r29
    1c60:	08 95       	ret

00001c62 <HLCD_ShiftCursorRight>:
 *
 * 		This function shift the cursor to the right
 *
 * **************************************************/
void HLCD_ShiftCursorRight(void)
{
    1c62:	df 93       	push	r29
    1c64:	cf 93       	push	r28
    1c66:	cd b7       	in	r28, 0x3d	; 61
    1c68:	de b7       	in	r29, 0x3e	; 62
    1c6a:	2e 97       	sbiw	r28, 0x0e	; 14
    1c6c:	0f b6       	in	r0, 0x3f	; 63
    1c6e:	f8 94       	cli
    1c70:	de bf       	out	0x3e, r29	; 62
    1c72:	0f be       	out	0x3f, r0	; 63
    1c74:	cd bf       	out	0x3d, r28	; 61
	HLCD_VoidSendCommand(0b000101);
    1c76:	85 e0       	ldi	r24, 0x05	; 5
    1c78:	0e 94 60 07 	call	0xec0	; 0xec0 <HLCD_VoidSendCommand>
    1c7c:	80 e0       	ldi	r24, 0x00	; 0
    1c7e:	90 e0       	ldi	r25, 0x00	; 0
    1c80:	a0 e0       	ldi	r26, 0x00	; 0
    1c82:	b0 e4       	ldi	r27, 0x40	; 64
    1c84:	8b 87       	std	Y+11, r24	; 0x0b
    1c86:	9c 87       	std	Y+12, r25	; 0x0c
    1c88:	ad 87       	std	Y+13, r26	; 0x0d
    1c8a:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    1c8c:	6b 85       	ldd	r22, Y+11	; 0x0b
    1c8e:	7c 85       	ldd	r23, Y+12	; 0x0c
    1c90:	8d 85       	ldd	r24, Y+13	; 0x0d
    1c92:	9e 85       	ldd	r25, Y+14	; 0x0e
    1c94:	20 e0       	ldi	r18, 0x00	; 0
    1c96:	30 e0       	ldi	r19, 0x00	; 0
    1c98:	4a e7       	ldi	r20, 0x7A	; 122
    1c9a:	53 e4       	ldi	r21, 0x43	; 67
    1c9c:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1ca0:	dc 01       	movw	r26, r24
    1ca2:	cb 01       	movw	r24, r22
    1ca4:	8f 83       	std	Y+7, r24	; 0x07
    1ca6:	98 87       	std	Y+8, r25	; 0x08
    1ca8:	a9 87       	std	Y+9, r26	; 0x09
    1caa:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    1cac:	6f 81       	ldd	r22, Y+7	; 0x07
    1cae:	78 85       	ldd	r23, Y+8	; 0x08
    1cb0:	89 85       	ldd	r24, Y+9	; 0x09
    1cb2:	9a 85       	ldd	r25, Y+10	; 0x0a
    1cb4:	20 e0       	ldi	r18, 0x00	; 0
    1cb6:	30 e0       	ldi	r19, 0x00	; 0
    1cb8:	40 e8       	ldi	r20, 0x80	; 128
    1cba:	5f e3       	ldi	r21, 0x3F	; 63
    1cbc:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    1cc0:	88 23       	and	r24, r24
    1cc2:	2c f4       	brge	.+10     	; 0x1cce <HLCD_ShiftCursorRight+0x6c>
		__ticks = 1;
    1cc4:	81 e0       	ldi	r24, 0x01	; 1
    1cc6:	90 e0       	ldi	r25, 0x00	; 0
    1cc8:	9e 83       	std	Y+6, r25	; 0x06
    1cca:	8d 83       	std	Y+5, r24	; 0x05
    1ccc:	3f c0       	rjmp	.+126    	; 0x1d4c <HLCD_ShiftCursorRight+0xea>
	else if (__tmp > 65535)
    1cce:	6f 81       	ldd	r22, Y+7	; 0x07
    1cd0:	78 85       	ldd	r23, Y+8	; 0x08
    1cd2:	89 85       	ldd	r24, Y+9	; 0x09
    1cd4:	9a 85       	ldd	r25, Y+10	; 0x0a
    1cd6:	20 e0       	ldi	r18, 0x00	; 0
    1cd8:	3f ef       	ldi	r19, 0xFF	; 255
    1cda:	4f e7       	ldi	r20, 0x7F	; 127
    1cdc:	57 e4       	ldi	r21, 0x47	; 71
    1cde:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    1ce2:	18 16       	cp	r1, r24
    1ce4:	4c f5       	brge	.+82     	; 0x1d38 <HLCD_ShiftCursorRight+0xd6>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    1ce6:	6b 85       	ldd	r22, Y+11	; 0x0b
    1ce8:	7c 85       	ldd	r23, Y+12	; 0x0c
    1cea:	8d 85       	ldd	r24, Y+13	; 0x0d
    1cec:	9e 85       	ldd	r25, Y+14	; 0x0e
    1cee:	20 e0       	ldi	r18, 0x00	; 0
    1cf0:	30 e0       	ldi	r19, 0x00	; 0
    1cf2:	40 e2       	ldi	r20, 0x20	; 32
    1cf4:	51 e4       	ldi	r21, 0x41	; 65
    1cf6:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1cfa:	dc 01       	movw	r26, r24
    1cfc:	cb 01       	movw	r24, r22
    1cfe:	bc 01       	movw	r22, r24
    1d00:	cd 01       	movw	r24, r26
    1d02:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1d06:	dc 01       	movw	r26, r24
    1d08:	cb 01       	movw	r24, r22
    1d0a:	9e 83       	std	Y+6, r25	; 0x06
    1d0c:	8d 83       	std	Y+5, r24	; 0x05
    1d0e:	0f c0       	rjmp	.+30     	; 0x1d2e <HLCD_ShiftCursorRight+0xcc>
    1d10:	89 e1       	ldi	r24, 0x19	; 25
    1d12:	90 e0       	ldi	r25, 0x00	; 0
    1d14:	9c 83       	std	Y+4, r25	; 0x04
    1d16:	8b 83       	std	Y+3, r24	; 0x03
    1d18:	8b 81       	ldd	r24, Y+3	; 0x03
    1d1a:	9c 81       	ldd	r25, Y+4	; 0x04
    1d1c:	01 97       	sbiw	r24, 0x01	; 1
    1d1e:	f1 f7       	brne	.-4      	; 0x1d1c <HLCD_ShiftCursorRight+0xba>
    1d20:	9c 83       	std	Y+4, r25	; 0x04
    1d22:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1d24:	8d 81       	ldd	r24, Y+5	; 0x05
    1d26:	9e 81       	ldd	r25, Y+6	; 0x06
    1d28:	01 97       	sbiw	r24, 0x01	; 1
    1d2a:	9e 83       	std	Y+6, r25	; 0x06
    1d2c:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1d2e:	8d 81       	ldd	r24, Y+5	; 0x05
    1d30:	9e 81       	ldd	r25, Y+6	; 0x06
    1d32:	00 97       	sbiw	r24, 0x00	; 0
    1d34:	69 f7       	brne	.-38     	; 0x1d10 <HLCD_ShiftCursorRight+0xae>
    1d36:	14 c0       	rjmp	.+40     	; 0x1d60 <HLCD_ShiftCursorRight+0xfe>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    1d38:	6f 81       	ldd	r22, Y+7	; 0x07
    1d3a:	78 85       	ldd	r23, Y+8	; 0x08
    1d3c:	89 85       	ldd	r24, Y+9	; 0x09
    1d3e:	9a 85       	ldd	r25, Y+10	; 0x0a
    1d40:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1d44:	dc 01       	movw	r26, r24
    1d46:	cb 01       	movw	r24, r22
    1d48:	9e 83       	std	Y+6, r25	; 0x06
    1d4a:	8d 83       	std	Y+5, r24	; 0x05
    1d4c:	8d 81       	ldd	r24, Y+5	; 0x05
    1d4e:	9e 81       	ldd	r25, Y+6	; 0x06
    1d50:	9a 83       	std	Y+2, r25	; 0x02
    1d52:	89 83       	std	Y+1, r24	; 0x01
    1d54:	89 81       	ldd	r24, Y+1	; 0x01
    1d56:	9a 81       	ldd	r25, Y+2	; 0x02
    1d58:	01 97       	sbiw	r24, 0x01	; 1
    1d5a:	f1 f7       	brne	.-4      	; 0x1d58 <HLCD_ShiftCursorRight+0xf6>
    1d5c:	9a 83       	std	Y+2, r25	; 0x02
    1d5e:	89 83       	std	Y+1, r24	; 0x01
	_delay_ms(2);
}
    1d60:	2e 96       	adiw	r28, 0x0e	; 14
    1d62:	0f b6       	in	r0, 0x3f	; 63
    1d64:	f8 94       	cli
    1d66:	de bf       	out	0x3e, r29	; 62
    1d68:	0f be       	out	0x3f, r0	; 63
    1d6a:	cd bf       	out	0x3d, r28	; 61
    1d6c:	cf 91       	pop	r28
    1d6e:	df 91       	pop	r29
    1d70:	08 95       	ret

00001d72 <HLCD_WriteHexNumber>:
 *
 * 		This function write a number on the LCD as hex
 *
 ***************************************************** */
void HLCD_WriteHexNumber(u8 Number)
{
    1d72:	df 93       	push	r29
    1d74:	cf 93       	push	r28
    1d76:	cd b7       	in	r28, 0x3d	; 61
    1d78:	de b7       	in	r29, 0x3e	; 62
    1d7a:	c8 56       	subi	r28, 0x68	; 104
    1d7c:	d0 40       	sbci	r29, 0x00	; 0
    1d7e:	0f b6       	in	r0, 0x3f	; 63
    1d80:	f8 94       	cli
    1d82:	de bf       	out	0x3e, r29	; 62
    1d84:	0f be       	out	0x3f, r0	; 63
    1d86:	cd bf       	out	0x3d, r28	; 61
    1d88:	fe 01       	movw	r30, r28
    1d8a:	e8 59       	subi	r30, 0x98	; 152
    1d8c:	ff 4f       	sbci	r31, 0xFF	; 255
    1d8e:	80 83       	st	Z, r24
    /*				char array to store hexadecimal number				*/
    u8 Copy_u8HexaDeciNum[100];
    /*				counter for hexadecimal number array				*/
    u8 Copy_u8Counter = 0;
    1d90:	1b 82       	std	Y+3, r1	; 0x03
    1d92:	33 c0       	rjmp	.+102    	; 0x1dfa <HLCD_WriteHexNumber+0x88>
    while (Number != 0)
    {
        /*			temporary variable to store remainder				*/
        u8 Copy_u8tempVariable = 0;
    1d94:	1a 82       	std	Y+2, r1	; 0x02

        /*			storing remainder in Copy_u8tempVariable 			*/
        Copy_u8tempVariable = Number % 16;
    1d96:	fe 01       	movw	r30, r28
    1d98:	e8 59       	subi	r30, 0x98	; 152
    1d9a:	ff 4f       	sbci	r31, 0xFF	; 255
    1d9c:	80 81       	ld	r24, Z
    1d9e:	8f 70       	andi	r24, 0x0F	; 15
    1da0:	8a 83       	std	Y+2, r24	; 0x02

        /*			check if Copy_u8tempVariable < 10					*/
        if (Copy_u8tempVariable < 10)
    1da2:	8a 81       	ldd	r24, Y+2	; 0x02
    1da4:	8a 30       	cpi	r24, 0x0A	; 10
    1da6:	80 f4       	brcc	.+32     	; 0x1dc8 <HLCD_WriteHexNumber+0x56>
        {
            Copy_u8HexaDeciNum[Copy_u8Counter] = Copy_u8tempVariable + 48;
    1da8:	8b 81       	ldd	r24, Y+3	; 0x03
    1daa:	28 2f       	mov	r18, r24
    1dac:	30 e0       	ldi	r19, 0x00	; 0
    1dae:	8a 81       	ldd	r24, Y+2	; 0x02
    1db0:	48 2f       	mov	r20, r24
    1db2:	40 5d       	subi	r20, 0xD0	; 208
    1db4:	ce 01       	movw	r24, r28
    1db6:	04 96       	adiw	r24, 0x04	; 4
    1db8:	fc 01       	movw	r30, r24
    1dba:	e2 0f       	add	r30, r18
    1dbc:	f3 1f       	adc	r31, r19
    1dbe:	40 83       	st	Z, r20
            Copy_u8Counter++;
    1dc0:	8b 81       	ldd	r24, Y+3	; 0x03
    1dc2:	8f 5f       	subi	r24, 0xFF	; 255
    1dc4:	8b 83       	std	Y+3, r24	; 0x03
    1dc6:	0f c0       	rjmp	.+30     	; 0x1de6 <HLCD_WriteHexNumber+0x74>
        }
        else
        {
        	Copy_u8HexaDeciNum[Copy_u8Counter] = Copy_u8tempVariable + 55;
    1dc8:	8b 81       	ldd	r24, Y+3	; 0x03
    1dca:	28 2f       	mov	r18, r24
    1dcc:	30 e0       	ldi	r19, 0x00	; 0
    1dce:	8a 81       	ldd	r24, Y+2	; 0x02
    1dd0:	48 2f       	mov	r20, r24
    1dd2:	49 5c       	subi	r20, 0xC9	; 201
    1dd4:	ce 01       	movw	r24, r28
    1dd6:	04 96       	adiw	r24, 0x04	; 4
    1dd8:	fc 01       	movw	r30, r24
    1dda:	e2 0f       	add	r30, r18
    1ddc:	f3 1f       	adc	r31, r19
    1dde:	40 83       	st	Z, r20
        	Copy_u8Counter++;
    1de0:	8b 81       	ldd	r24, Y+3	; 0x03
    1de2:	8f 5f       	subi	r24, 0xFF	; 255
    1de4:	8b 83       	std	Y+3, r24	; 0x03
        }
        Number = Number / 16;
    1de6:	de 01       	movw	r26, r28
    1de8:	a8 59       	subi	r26, 0x98	; 152
    1dea:	bf 4f       	sbci	r27, 0xFF	; 255
    1dec:	fe 01       	movw	r30, r28
    1dee:	e8 59       	subi	r30, 0x98	; 152
    1df0:	ff 4f       	sbci	r31, 0xFF	; 255
    1df2:	80 81       	ld	r24, Z
    1df4:	82 95       	swap	r24
    1df6:	8f 70       	andi	r24, 0x0F	; 15
    1df8:	8c 93       	st	X, r24
{
    /*				char array to store hexadecimal number				*/
    u8 Copy_u8HexaDeciNum[100];
    /*				counter for hexadecimal number array				*/
    u8 Copy_u8Counter = 0;
    while (Number != 0)
    1dfa:	fe 01       	movw	r30, r28
    1dfc:	e8 59       	subi	r30, 0x98	; 152
    1dfe:	ff 4f       	sbci	r31, 0xFF	; 255
    1e00:	80 81       	ld	r24, Z
    1e02:	88 23       	and	r24, r24
    1e04:	39 f6       	brne	.-114    	; 0x1d94 <HLCD_WriteHexNumber+0x22>
        	Copy_u8HexaDeciNum[Copy_u8Counter] = Copy_u8tempVariable + 55;
        	Copy_u8Counter++;
        }
        Number = Number / 16;
    }
    for (u8 Copy_u8Counterloop = Copy_u8Counter - 1; Copy_u8Counterloop >= 0; Copy_u8Counterloop--)
    1e06:	8b 81       	ldd	r24, Y+3	; 0x03
    1e08:	81 50       	subi	r24, 0x01	; 1
    1e0a:	89 83       	std	Y+1, r24	; 0x01
    {
    	HLCD_VoidSendNumber(Copy_u8HexaDeciNum[Copy_u8Counterloop]);
    1e0c:	89 81       	ldd	r24, Y+1	; 0x01
    1e0e:	28 2f       	mov	r18, r24
    1e10:	30 e0       	ldi	r19, 0x00	; 0
    1e12:	ce 01       	movw	r24, r28
    1e14:	04 96       	adiw	r24, 0x04	; 4
    1e16:	fc 01       	movw	r30, r24
    1e18:	e2 0f       	add	r30, r18
    1e1a:	f3 1f       	adc	r31, r19
    1e1c:	80 81       	ld	r24, Z
    1e1e:	88 2f       	mov	r24, r24
    1e20:	90 e0       	ldi	r25, 0x00	; 0
    1e22:	a0 e0       	ldi	r26, 0x00	; 0
    1e24:	b0 e0       	ldi	r27, 0x00	; 0
    1e26:	bc 01       	movw	r22, r24
    1e28:	cd 01       	movw	r24, r26
    1e2a:	0e 94 b8 0a 	call	0x1570	; 0x1570 <HLCD_VoidSendNumber>
        	Copy_u8HexaDeciNum[Copy_u8Counter] = Copy_u8tempVariable + 55;
        	Copy_u8Counter++;
        }
        Number = Number / 16;
    }
    for (u8 Copy_u8Counterloop = Copy_u8Counter - 1; Copy_u8Counterloop >= 0; Copy_u8Counterloop--)
    1e2e:	89 81       	ldd	r24, Y+1	; 0x01
    1e30:	81 50       	subi	r24, 0x01	; 1
    1e32:	89 83       	std	Y+1, r24	; 0x01
    1e34:	eb cf       	rjmp	.-42     	; 0x1e0c <HLCD_WriteHexNumber+0x9a>

00001e36 <HLCD_WriteBinaryNumber>:
 *
 * 		This function Write a number in the LCD as a binary form
 *
 * ******************************************************************/
void HLCD_WriteBinaryNumber(u8 Number)
{
    1e36:	df 93       	push	r29
    1e38:	cf 93       	push	r28
    1e3a:	cd b7       	in	r28, 0x3d	; 61
    1e3c:	de b7       	in	r29, 0x3e	; 62
    1e3e:	c6 56       	subi	r28, 0x66	; 102
    1e40:	d0 40       	sbci	r29, 0x00	; 0
    1e42:	0f b6       	in	r0, 0x3f	; 63
    1e44:	f8 94       	cli
    1e46:	de bf       	out	0x3e, r29	; 62
    1e48:	0f be       	out	0x3f, r0	; 63
    1e4a:	cd bf       	out	0x3d, r28	; 61
    1e4c:	fe 01       	movw	r30, r28
    1e4e:	ea 59       	subi	r30, 0x9A	; 154
    1e50:	ff 4f       	sbci	r31, 0xFF	; 255
    1e52:	80 83       	st	Z, r24
    /*				char array to store Binary number					*/
    u8 Copy_u8BinaryDeciNum[100];

    for(u8 Copy_u8Counter = 0; Number > 0; Copy_u8Counter++)
    1e54:	19 82       	std	Y+1, r1	; 0x01
    1e56:	2c c0       	rjmp	.+88     	; 0x1eb0 <HLCD_WriteBinaryNumber+0x7a>
    {
    	/*			Getting the Mod of base 2 to convert into binary	*/
    	Copy_u8BinaryDeciNum[Copy_u8Counter] = Number % 2;
    1e58:	89 81       	ldd	r24, Y+1	; 0x01
    1e5a:	28 2f       	mov	r18, r24
    1e5c:	30 e0       	ldi	r19, 0x00	; 0
    1e5e:	fe 01       	movw	r30, r28
    1e60:	ea 59       	subi	r30, 0x9A	; 154
    1e62:	ff 4f       	sbci	r31, 0xFF	; 255
    1e64:	80 81       	ld	r24, Z
    1e66:	48 2f       	mov	r20, r24
    1e68:	41 70       	andi	r20, 0x01	; 1
    1e6a:	ce 01       	movw	r24, r28
    1e6c:	02 96       	adiw	r24, 0x02	; 2
    1e6e:	fc 01       	movw	r30, r24
    1e70:	e2 0f       	add	r30, r18
    1e72:	f3 1f       	adc	r31, r19
    1e74:	40 83       	st	Z, r20
    	Number = Number / 2;
    1e76:	de 01       	movw	r26, r28
    1e78:	aa 59       	subi	r26, 0x9A	; 154
    1e7a:	bf 4f       	sbci	r27, 0xFF	; 255
    1e7c:	fe 01       	movw	r30, r28
    1e7e:	ea 59       	subi	r30, 0x9A	; 154
    1e80:	ff 4f       	sbci	r31, 0xFF	; 255
    1e82:	80 81       	ld	r24, Z
    1e84:	86 95       	lsr	r24
    1e86:	8c 93       	st	X, r24
    	/*			Sending the number to the LCD						*/
    	HLCD_VoidSendNumber(Copy_u8BinaryDeciNum[Copy_u8Counter]);
    1e88:	89 81       	ldd	r24, Y+1	; 0x01
    1e8a:	28 2f       	mov	r18, r24
    1e8c:	30 e0       	ldi	r19, 0x00	; 0
    1e8e:	ce 01       	movw	r24, r28
    1e90:	02 96       	adiw	r24, 0x02	; 2
    1e92:	fc 01       	movw	r30, r24
    1e94:	e2 0f       	add	r30, r18
    1e96:	f3 1f       	adc	r31, r19
    1e98:	80 81       	ld	r24, Z
    1e9a:	88 2f       	mov	r24, r24
    1e9c:	90 e0       	ldi	r25, 0x00	; 0
    1e9e:	a0 e0       	ldi	r26, 0x00	; 0
    1ea0:	b0 e0       	ldi	r27, 0x00	; 0
    1ea2:	bc 01       	movw	r22, r24
    1ea4:	cd 01       	movw	r24, r26
    1ea6:	0e 94 b8 0a 	call	0x1570	; 0x1570 <HLCD_VoidSendNumber>
void HLCD_WriteBinaryNumber(u8 Number)
{
    /*				char array to store Binary number					*/
    u8 Copy_u8BinaryDeciNum[100];

    for(u8 Copy_u8Counter = 0; Number > 0; Copy_u8Counter++)
    1eaa:	89 81       	ldd	r24, Y+1	; 0x01
    1eac:	8f 5f       	subi	r24, 0xFF	; 255
    1eae:	89 83       	std	Y+1, r24	; 0x01
    1eb0:	fe 01       	movw	r30, r28
    1eb2:	ea 59       	subi	r30, 0x9A	; 154
    1eb4:	ff 4f       	sbci	r31, 0xFF	; 255
    1eb6:	80 81       	ld	r24, Z
    1eb8:	88 23       	and	r24, r24
    1eba:	71 f6       	brne	.-100    	; 0x1e58 <HLCD_WriteBinaryNumber+0x22>
    	Copy_u8BinaryDeciNum[Copy_u8Counter] = Number % 2;
    	Number = Number / 2;
    	/*			Sending the number to the LCD						*/
    	HLCD_VoidSendNumber(Copy_u8BinaryDeciNum[Copy_u8Counter]);
    }
}
    1ebc:	ca 59       	subi	r28, 0x9A	; 154
    1ebe:	df 4f       	sbci	r29, 0xFF	; 255
    1ec0:	0f b6       	in	r0, 0x3f	; 63
    1ec2:	f8 94       	cli
    1ec4:	de bf       	out	0x3e, r29	; 62
    1ec6:	0f be       	out	0x3f, r0	; 63
    1ec8:	cd bf       	out	0x3d, r28	; 61
    1eca:	cf 91       	pop	r28
    1ecc:	df 91       	pop	r29
    1ece:	08 95       	ret

00001ed0 <HLCD_AnimateString>:
 * 			last character in the string start from the beginning
 * 			of the LCD
 *
 ***********************************************************************/
void HLCD_AnimateString(u8 * str)
{
    1ed0:	df 93       	push	r29
    1ed2:	cf 93       	push	r28
    1ed4:	cd b7       	in	r28, 0x3d	; 61
    1ed6:	de b7       	in	r29, 0x3e	; 62
    1ed8:	60 97       	sbiw	r28, 0x10	; 16
    1eda:	0f b6       	in	r0, 0x3f	; 63
    1edc:	f8 94       	cli
    1ede:	de bf       	out	0x3e, r29	; 62
    1ee0:	0f be       	out	0x3f, r0	; 63
    1ee2:	cd bf       	out	0x3d, r28	; 61
    1ee4:	98 8b       	std	Y+16, r25	; 0x10
    1ee6:	8f 87       	std	Y+15, r24	; 0x0f
    1ee8:	93 c0       	rjmp	.+294    	; 0x2010 <HLCD_AnimateString+0x140>
	static s8 Copy_iCounter = -1;
	/*			Looping on the string to make the animation on it		*/
	for(; Copy_iCounter <= 15; Copy_iCounter++)
	{
		/*		Set the cursor to the beginning							*/
		HLCD_GoToXY(1,Copy_iCounter);
    1eea:	90 91 8e 01 	lds	r25, 0x018E
    1eee:	81 e0       	ldi	r24, 0x01	; 1
    1ef0:	69 2f       	mov	r22, r25
    1ef2:	0e 94 90 0a 	call	0x1520	; 0x1520 <HLCD_GoToXY>
		HLCD_VoidWriteStr(str);
    1ef6:	8f 85       	ldd	r24, Y+15	; 0x0f
    1ef8:	98 89       	ldd	r25, Y+16	; 0x10
    1efa:	0e 94 67 0a 	call	0x14ce	; 0x14ce <HLCD_VoidWriteStr>
		/*
		 * check if the counter bigger then the length of the
		 * 								character
		 *																*/
		if(Copy_iCounter > 10)
    1efe:	80 91 8e 01 	lds	r24, 0x018E
    1f02:	8b 30       	cpi	r24, 0x0B	; 11
    1f04:	64 f0       	brlt	.+24     	; 0x1f1e <HLCD_AnimateString+0x4e>
		{
			/*		Set the string from the first row and last column	*/
			HLCD_GoToXY(1, Copy_iCounter - 15);
    1f06:	80 91 8e 01 	lds	r24, 0x018E
    1f0a:	8f 50       	subi	r24, 0x0F	; 15
    1f0c:	98 2f       	mov	r25, r24
    1f0e:	81 e0       	ldi	r24, 0x01	; 1
    1f10:	69 2f       	mov	r22, r25
    1f12:	0e 94 90 0a 	call	0x1520	; 0x1520 <HLCD_GoToXY>
			/*		Send the String to the LCD							*/
			HLCD_VoidWriteStr(str);
    1f16:	8f 85       	ldd	r24, Y+15	; 0x0f
    1f18:	98 89       	ldd	r25, Y+16	; 0x10
    1f1a:	0e 94 67 0a 	call	0x14ce	; 0x14ce <HLCD_VoidWriteStr>
    1f1e:	80 e0       	ldi	r24, 0x00	; 0
    1f20:	90 e0       	ldi	r25, 0x00	; 0
    1f22:	a8 e4       	ldi	r26, 0x48	; 72
    1f24:	b3 e4       	ldi	r27, 0x43	; 67
    1f26:	8b 87       	std	Y+11, r24	; 0x0b
    1f28:	9c 87       	std	Y+12, r25	; 0x0c
    1f2a:	ad 87       	std	Y+13, r26	; 0x0d
    1f2c:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    1f2e:	6b 85       	ldd	r22, Y+11	; 0x0b
    1f30:	7c 85       	ldd	r23, Y+12	; 0x0c
    1f32:	8d 85       	ldd	r24, Y+13	; 0x0d
    1f34:	9e 85       	ldd	r25, Y+14	; 0x0e
    1f36:	20 e0       	ldi	r18, 0x00	; 0
    1f38:	30 e0       	ldi	r19, 0x00	; 0
    1f3a:	4a e7       	ldi	r20, 0x7A	; 122
    1f3c:	53 e4       	ldi	r21, 0x43	; 67
    1f3e:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1f42:	dc 01       	movw	r26, r24
    1f44:	cb 01       	movw	r24, r22
    1f46:	8f 83       	std	Y+7, r24	; 0x07
    1f48:	98 87       	std	Y+8, r25	; 0x08
    1f4a:	a9 87       	std	Y+9, r26	; 0x09
    1f4c:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    1f4e:	6f 81       	ldd	r22, Y+7	; 0x07
    1f50:	78 85       	ldd	r23, Y+8	; 0x08
    1f52:	89 85       	ldd	r24, Y+9	; 0x09
    1f54:	9a 85       	ldd	r25, Y+10	; 0x0a
    1f56:	20 e0       	ldi	r18, 0x00	; 0
    1f58:	30 e0       	ldi	r19, 0x00	; 0
    1f5a:	40 e8       	ldi	r20, 0x80	; 128
    1f5c:	5f e3       	ldi	r21, 0x3F	; 63
    1f5e:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    1f62:	88 23       	and	r24, r24
    1f64:	2c f4       	brge	.+10     	; 0x1f70 <HLCD_AnimateString+0xa0>
		__ticks = 1;
    1f66:	81 e0       	ldi	r24, 0x01	; 1
    1f68:	90 e0       	ldi	r25, 0x00	; 0
    1f6a:	9e 83       	std	Y+6, r25	; 0x06
    1f6c:	8d 83       	std	Y+5, r24	; 0x05
    1f6e:	3f c0       	rjmp	.+126    	; 0x1fee <HLCD_AnimateString+0x11e>
	else if (__tmp > 65535)
    1f70:	6f 81       	ldd	r22, Y+7	; 0x07
    1f72:	78 85       	ldd	r23, Y+8	; 0x08
    1f74:	89 85       	ldd	r24, Y+9	; 0x09
    1f76:	9a 85       	ldd	r25, Y+10	; 0x0a
    1f78:	20 e0       	ldi	r18, 0x00	; 0
    1f7a:	3f ef       	ldi	r19, 0xFF	; 255
    1f7c:	4f e7       	ldi	r20, 0x7F	; 127
    1f7e:	57 e4       	ldi	r21, 0x47	; 71
    1f80:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    1f84:	18 16       	cp	r1, r24
    1f86:	4c f5       	brge	.+82     	; 0x1fda <HLCD_AnimateString+0x10a>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    1f88:	6b 85       	ldd	r22, Y+11	; 0x0b
    1f8a:	7c 85       	ldd	r23, Y+12	; 0x0c
    1f8c:	8d 85       	ldd	r24, Y+13	; 0x0d
    1f8e:	9e 85       	ldd	r25, Y+14	; 0x0e
    1f90:	20 e0       	ldi	r18, 0x00	; 0
    1f92:	30 e0       	ldi	r19, 0x00	; 0
    1f94:	40 e2       	ldi	r20, 0x20	; 32
    1f96:	51 e4       	ldi	r21, 0x41	; 65
    1f98:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1f9c:	dc 01       	movw	r26, r24
    1f9e:	cb 01       	movw	r24, r22
    1fa0:	bc 01       	movw	r22, r24
    1fa2:	cd 01       	movw	r24, r26
    1fa4:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1fa8:	dc 01       	movw	r26, r24
    1faa:	cb 01       	movw	r24, r22
    1fac:	9e 83       	std	Y+6, r25	; 0x06
    1fae:	8d 83       	std	Y+5, r24	; 0x05
    1fb0:	0f c0       	rjmp	.+30     	; 0x1fd0 <HLCD_AnimateString+0x100>
    1fb2:	89 e1       	ldi	r24, 0x19	; 25
    1fb4:	90 e0       	ldi	r25, 0x00	; 0
    1fb6:	9c 83       	std	Y+4, r25	; 0x04
    1fb8:	8b 83       	std	Y+3, r24	; 0x03
    1fba:	8b 81       	ldd	r24, Y+3	; 0x03
    1fbc:	9c 81       	ldd	r25, Y+4	; 0x04
    1fbe:	01 97       	sbiw	r24, 0x01	; 1
    1fc0:	f1 f7       	brne	.-4      	; 0x1fbe <HLCD_AnimateString+0xee>
    1fc2:	9c 83       	std	Y+4, r25	; 0x04
    1fc4:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1fc6:	8d 81       	ldd	r24, Y+5	; 0x05
    1fc8:	9e 81       	ldd	r25, Y+6	; 0x06
    1fca:	01 97       	sbiw	r24, 0x01	; 1
    1fcc:	9e 83       	std	Y+6, r25	; 0x06
    1fce:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1fd0:	8d 81       	ldd	r24, Y+5	; 0x05
    1fd2:	9e 81       	ldd	r25, Y+6	; 0x06
    1fd4:	00 97       	sbiw	r24, 0x00	; 0
    1fd6:	69 f7       	brne	.-38     	; 0x1fb2 <HLCD_AnimateString+0xe2>
    1fd8:	14 c0       	rjmp	.+40     	; 0x2002 <HLCD_AnimateString+0x132>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    1fda:	6f 81       	ldd	r22, Y+7	; 0x07
    1fdc:	78 85       	ldd	r23, Y+8	; 0x08
    1fde:	89 85       	ldd	r24, Y+9	; 0x09
    1fe0:	9a 85       	ldd	r25, Y+10	; 0x0a
    1fe2:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1fe6:	dc 01       	movw	r26, r24
    1fe8:	cb 01       	movw	r24, r22
    1fea:	9e 83       	std	Y+6, r25	; 0x06
    1fec:	8d 83       	std	Y+5, r24	; 0x05
    1fee:	8d 81       	ldd	r24, Y+5	; 0x05
    1ff0:	9e 81       	ldd	r25, Y+6	; 0x06
    1ff2:	9a 83       	std	Y+2, r25	; 0x02
    1ff4:	89 83       	std	Y+1, r24	; 0x01
    1ff6:	89 81       	ldd	r24, Y+1	; 0x01
    1ff8:	9a 81       	ldd	r25, Y+2	; 0x02
    1ffa:	01 97       	sbiw	r24, 0x01	; 1
    1ffc:	f1 f7       	brne	.-4      	; 0x1ffa <HLCD_AnimateString+0x12a>
    1ffe:	9a 83       	std	Y+2, r25	; 0x02
    2000:	89 83       	std	Y+1, r24	; 0x01
		}
		/*						Wait for 200ms 							*/
		_delay_ms(200);
		/*				Clear all the display							*/
		HLCD_ClearDisplay();
    2002:	0e 94 e5 0b 	call	0x17ca	; 0x17ca <HLCD_ClearDisplay>
void HLCD_AnimateString(u8 * str)
{

	static s8 Copy_iCounter = -1;
	/*			Looping on the string to make the animation on it		*/
	for(; Copy_iCounter <= 15; Copy_iCounter++)
    2006:	80 91 8e 01 	lds	r24, 0x018E
    200a:	8f 5f       	subi	r24, 0xFF	; 255
    200c:	80 93 8e 01 	sts	0x018E, r24
    2010:	80 91 8e 01 	lds	r24, 0x018E
    2014:	80 31       	cpi	r24, 0x10	; 16
    2016:	0c f4       	brge	.+2      	; 0x201a <HLCD_AnimateString+0x14a>
    2018:	68 cf       	rjmp	.-304    	; 0x1eea <HLCD_AnimateString+0x1a>
		_delay_ms(200);
		/*				Clear all the display							*/
		HLCD_ClearDisplay();
	}
	/*				Start the counter from the beginning				*/
	Copy_iCounter = 1;
    201a:	81 e0       	ldi	r24, 0x01	; 1
    201c:	80 93 8e 01 	sts	0x018E, r24
}
    2020:	60 96       	adiw	r28, 0x10	; 16
    2022:	0f b6       	in	r0, 0x3f	; 63
    2024:	f8 94       	cli
    2026:	de bf       	out	0x3e, r29	; 62
    2028:	0f be       	out	0x3f, r0	; 63
    202a:	cd bf       	out	0x3d, r28	; 61
    202c:	cf 91       	pop	r28
    202e:	df 91       	pop	r29
    2030:	08 95       	ret

00002032 <MDIO_VoidSetPinDirection>:
 *
 * 			Here we Set the Pin direction of the given port to 1 or 0
 *
 *************************************************************************/
void MDIO_VoidSetPinDirection(u8 Copy_u8Port ,u8 Copy_u8Pin, u8 Copy_u8Direc)
{
    2032:	df 93       	push	r29
    2034:	cf 93       	push	r28
    2036:	cd b7       	in	r28, 0x3d	; 61
    2038:	de b7       	in	r29, 0x3e	; 62
    203a:	27 97       	sbiw	r28, 0x07	; 7
    203c:	0f b6       	in	r0, 0x3f	; 63
    203e:	f8 94       	cli
    2040:	de bf       	out	0x3e, r29	; 62
    2042:	0f be       	out	0x3f, r0	; 63
    2044:	cd bf       	out	0x3d, r28	; 61
    2046:	89 83       	std	Y+1, r24	; 0x01
    2048:	6a 83       	std	Y+2, r22	; 0x02
    204a:	4b 83       	std	Y+3, r20	; 0x03
	/*					check for pins and ports					*/
	if(Copy_u8Port <= DIO_PORTD  && Copy_u8Pin <= DIO_PIN7)
    204c:	89 81       	ldd	r24, Y+1	; 0x01
    204e:	84 30       	cpi	r24, 0x04	; 4
    2050:	08 f0       	brcs	.+2      	; 0x2054 <MDIO_VoidSetPinDirection+0x22>
    2052:	ee c0       	rjmp	.+476    	; 0x2230 <MDIO_VoidSetPinDirection+0x1fe>
    2054:	8a 81       	ldd	r24, Y+2	; 0x02
    2056:	88 30       	cpi	r24, 0x08	; 8
    2058:	08 f0       	brcs	.+2      	; 0x205c <MDIO_VoidSetPinDirection+0x2a>
    205a:	ea c0       	rjmp	.+468    	; 0x2230 <MDIO_VoidSetPinDirection+0x1fe>
	{
	/*					check the direction							*/
		if(DIO_PIN_HIGH == Copy_u8Direc)
    205c:	8b 81       	ldd	r24, Y+3	; 0x03
    205e:	81 30       	cpi	r24, 0x01	; 1
    2060:	09 f0       	breq	.+2      	; 0x2064 <MDIO_VoidSetPinDirection+0x32>
    2062:	6f c0       	rjmp	.+222    	; 0x2142 <MDIO_VoidSetPinDirection+0x110>
		{
			switch(Copy_u8Port)
    2064:	89 81       	ldd	r24, Y+1	; 0x01
    2066:	28 2f       	mov	r18, r24
    2068:	30 e0       	ldi	r19, 0x00	; 0
    206a:	3f 83       	std	Y+7, r19	; 0x07
    206c:	2e 83       	std	Y+6, r18	; 0x06
    206e:	8e 81       	ldd	r24, Y+6	; 0x06
    2070:	9f 81       	ldd	r25, Y+7	; 0x07
    2072:	81 30       	cpi	r24, 0x01	; 1
    2074:	91 05       	cpc	r25, r1
    2076:	49 f1       	breq	.+82     	; 0x20ca <MDIO_VoidSetPinDirection+0x98>
    2078:	2e 81       	ldd	r18, Y+6	; 0x06
    207a:	3f 81       	ldd	r19, Y+7	; 0x07
    207c:	22 30       	cpi	r18, 0x02	; 2
    207e:	31 05       	cpc	r19, r1
    2080:	2c f4       	brge	.+10     	; 0x208c <MDIO_VoidSetPinDirection+0x5a>
    2082:	8e 81       	ldd	r24, Y+6	; 0x06
    2084:	9f 81       	ldd	r25, Y+7	; 0x07
    2086:	00 97       	sbiw	r24, 0x00	; 0
    2088:	61 f0       	breq	.+24     	; 0x20a2 <MDIO_VoidSetPinDirection+0x70>
    208a:	d2 c0       	rjmp	.+420    	; 0x2230 <MDIO_VoidSetPinDirection+0x1fe>
    208c:	2e 81       	ldd	r18, Y+6	; 0x06
    208e:	3f 81       	ldd	r19, Y+7	; 0x07
    2090:	22 30       	cpi	r18, 0x02	; 2
    2092:	31 05       	cpc	r19, r1
    2094:	71 f1       	breq	.+92     	; 0x20f2 <MDIO_VoidSetPinDirection+0xc0>
    2096:	8e 81       	ldd	r24, Y+6	; 0x06
    2098:	9f 81       	ldd	r25, Y+7	; 0x07
    209a:	83 30       	cpi	r24, 0x03	; 3
    209c:	91 05       	cpc	r25, r1
    209e:	e9 f1       	breq	.+122    	; 0x211a <MDIO_VoidSetPinDirection+0xe8>
    20a0:	c7 c0       	rjmp	.+398    	; 0x2230 <MDIO_VoidSetPinDirection+0x1fe>
			{
				case DIO_PORTA:SET_BIT(DDRA_REG, Copy_u8Pin); break;
    20a2:	aa e3       	ldi	r26, 0x3A	; 58
    20a4:	b0 e0       	ldi	r27, 0x00	; 0
    20a6:	ea e3       	ldi	r30, 0x3A	; 58
    20a8:	f0 e0       	ldi	r31, 0x00	; 0
    20aa:	80 81       	ld	r24, Z
    20ac:	48 2f       	mov	r20, r24
    20ae:	8a 81       	ldd	r24, Y+2	; 0x02
    20b0:	28 2f       	mov	r18, r24
    20b2:	30 e0       	ldi	r19, 0x00	; 0
    20b4:	81 e0       	ldi	r24, 0x01	; 1
    20b6:	90 e0       	ldi	r25, 0x00	; 0
    20b8:	02 2e       	mov	r0, r18
    20ba:	02 c0       	rjmp	.+4      	; 0x20c0 <MDIO_VoidSetPinDirection+0x8e>
    20bc:	88 0f       	add	r24, r24
    20be:	99 1f       	adc	r25, r25
    20c0:	0a 94       	dec	r0
    20c2:	e2 f7       	brpl	.-8      	; 0x20bc <MDIO_VoidSetPinDirection+0x8a>
    20c4:	84 2b       	or	r24, r20
    20c6:	8c 93       	st	X, r24
    20c8:	b3 c0       	rjmp	.+358    	; 0x2230 <MDIO_VoidSetPinDirection+0x1fe>
				case DIO_PORTB:SET_BIT(DDRB_REG, Copy_u8Pin); break;
    20ca:	a7 e3       	ldi	r26, 0x37	; 55
    20cc:	b0 e0       	ldi	r27, 0x00	; 0
    20ce:	e7 e3       	ldi	r30, 0x37	; 55
    20d0:	f0 e0       	ldi	r31, 0x00	; 0
    20d2:	80 81       	ld	r24, Z
    20d4:	48 2f       	mov	r20, r24
    20d6:	8a 81       	ldd	r24, Y+2	; 0x02
    20d8:	28 2f       	mov	r18, r24
    20da:	30 e0       	ldi	r19, 0x00	; 0
    20dc:	81 e0       	ldi	r24, 0x01	; 1
    20de:	90 e0       	ldi	r25, 0x00	; 0
    20e0:	02 2e       	mov	r0, r18
    20e2:	02 c0       	rjmp	.+4      	; 0x20e8 <MDIO_VoidSetPinDirection+0xb6>
    20e4:	88 0f       	add	r24, r24
    20e6:	99 1f       	adc	r25, r25
    20e8:	0a 94       	dec	r0
    20ea:	e2 f7       	brpl	.-8      	; 0x20e4 <MDIO_VoidSetPinDirection+0xb2>
    20ec:	84 2b       	or	r24, r20
    20ee:	8c 93       	st	X, r24
    20f0:	9f c0       	rjmp	.+318    	; 0x2230 <MDIO_VoidSetPinDirection+0x1fe>
				case DIO_PORTC:SET_BIT(DDRC_REG, Copy_u8Pin); break;
    20f2:	a4 e3       	ldi	r26, 0x34	; 52
    20f4:	b0 e0       	ldi	r27, 0x00	; 0
    20f6:	e4 e3       	ldi	r30, 0x34	; 52
    20f8:	f0 e0       	ldi	r31, 0x00	; 0
    20fa:	80 81       	ld	r24, Z
    20fc:	48 2f       	mov	r20, r24
    20fe:	8a 81       	ldd	r24, Y+2	; 0x02
    2100:	28 2f       	mov	r18, r24
    2102:	30 e0       	ldi	r19, 0x00	; 0
    2104:	81 e0       	ldi	r24, 0x01	; 1
    2106:	90 e0       	ldi	r25, 0x00	; 0
    2108:	02 2e       	mov	r0, r18
    210a:	02 c0       	rjmp	.+4      	; 0x2110 <MDIO_VoidSetPinDirection+0xde>
    210c:	88 0f       	add	r24, r24
    210e:	99 1f       	adc	r25, r25
    2110:	0a 94       	dec	r0
    2112:	e2 f7       	brpl	.-8      	; 0x210c <MDIO_VoidSetPinDirection+0xda>
    2114:	84 2b       	or	r24, r20
    2116:	8c 93       	st	X, r24
    2118:	8b c0       	rjmp	.+278    	; 0x2230 <MDIO_VoidSetPinDirection+0x1fe>
				case DIO_PORTD:SET_BIT(DDRD_REG, Copy_u8Pin); break;
    211a:	a1 e3       	ldi	r26, 0x31	; 49
    211c:	b0 e0       	ldi	r27, 0x00	; 0
    211e:	e1 e3       	ldi	r30, 0x31	; 49
    2120:	f0 e0       	ldi	r31, 0x00	; 0
    2122:	80 81       	ld	r24, Z
    2124:	48 2f       	mov	r20, r24
    2126:	8a 81       	ldd	r24, Y+2	; 0x02
    2128:	28 2f       	mov	r18, r24
    212a:	30 e0       	ldi	r19, 0x00	; 0
    212c:	81 e0       	ldi	r24, 0x01	; 1
    212e:	90 e0       	ldi	r25, 0x00	; 0
    2130:	02 2e       	mov	r0, r18
    2132:	02 c0       	rjmp	.+4      	; 0x2138 <MDIO_VoidSetPinDirection+0x106>
    2134:	88 0f       	add	r24, r24
    2136:	99 1f       	adc	r25, r25
    2138:	0a 94       	dec	r0
    213a:	e2 f7       	brpl	.-8      	; 0x2134 <MDIO_VoidSetPinDirection+0x102>
    213c:	84 2b       	or	r24, r20
    213e:	8c 93       	st	X, r24
    2140:	77 c0       	rjmp	.+238    	; 0x2230 <MDIO_VoidSetPinDirection+0x1fe>
				default: /*		Wrong POrt ID		*/	      break;
			}
		}
	/**/
		else if(DIO_PIN_LOW == Copy_u8Direc)
    2142:	8b 81       	ldd	r24, Y+3	; 0x03
    2144:	88 23       	and	r24, r24
    2146:	09 f0       	breq	.+2      	; 0x214a <MDIO_VoidSetPinDirection+0x118>
    2148:	73 c0       	rjmp	.+230    	; 0x2230 <MDIO_VoidSetPinDirection+0x1fe>
		{
			switch(Copy_u8Port)
    214a:	89 81       	ldd	r24, Y+1	; 0x01
    214c:	28 2f       	mov	r18, r24
    214e:	30 e0       	ldi	r19, 0x00	; 0
    2150:	3d 83       	std	Y+5, r19	; 0x05
    2152:	2c 83       	std	Y+4, r18	; 0x04
    2154:	8c 81       	ldd	r24, Y+4	; 0x04
    2156:	9d 81       	ldd	r25, Y+5	; 0x05
    2158:	81 30       	cpi	r24, 0x01	; 1
    215a:	91 05       	cpc	r25, r1
    215c:	59 f1       	breq	.+86     	; 0x21b4 <MDIO_VoidSetPinDirection+0x182>
    215e:	2c 81       	ldd	r18, Y+4	; 0x04
    2160:	3d 81       	ldd	r19, Y+5	; 0x05
    2162:	22 30       	cpi	r18, 0x02	; 2
    2164:	31 05       	cpc	r19, r1
    2166:	2c f4       	brge	.+10     	; 0x2172 <MDIO_VoidSetPinDirection+0x140>
    2168:	8c 81       	ldd	r24, Y+4	; 0x04
    216a:	9d 81       	ldd	r25, Y+5	; 0x05
    216c:	00 97       	sbiw	r24, 0x00	; 0
    216e:	69 f0       	breq	.+26     	; 0x218a <MDIO_VoidSetPinDirection+0x158>
    2170:	5f c0       	rjmp	.+190    	; 0x2230 <MDIO_VoidSetPinDirection+0x1fe>
    2172:	2c 81       	ldd	r18, Y+4	; 0x04
    2174:	3d 81       	ldd	r19, Y+5	; 0x05
    2176:	22 30       	cpi	r18, 0x02	; 2
    2178:	31 05       	cpc	r19, r1
    217a:	89 f1       	breq	.+98     	; 0x21de <MDIO_VoidSetPinDirection+0x1ac>
    217c:	8c 81       	ldd	r24, Y+4	; 0x04
    217e:	9d 81       	ldd	r25, Y+5	; 0x05
    2180:	83 30       	cpi	r24, 0x03	; 3
    2182:	91 05       	cpc	r25, r1
    2184:	09 f4       	brne	.+2      	; 0x2188 <MDIO_VoidSetPinDirection+0x156>
    2186:	40 c0       	rjmp	.+128    	; 0x2208 <MDIO_VoidSetPinDirection+0x1d6>
    2188:	53 c0       	rjmp	.+166    	; 0x2230 <MDIO_VoidSetPinDirection+0x1fe>
			{
				case DIO_PORTA:CLR_BIT(DDRA_REG, Copy_u8Pin); break;
    218a:	aa e3       	ldi	r26, 0x3A	; 58
    218c:	b0 e0       	ldi	r27, 0x00	; 0
    218e:	ea e3       	ldi	r30, 0x3A	; 58
    2190:	f0 e0       	ldi	r31, 0x00	; 0
    2192:	80 81       	ld	r24, Z
    2194:	48 2f       	mov	r20, r24
    2196:	8a 81       	ldd	r24, Y+2	; 0x02
    2198:	28 2f       	mov	r18, r24
    219a:	30 e0       	ldi	r19, 0x00	; 0
    219c:	81 e0       	ldi	r24, 0x01	; 1
    219e:	90 e0       	ldi	r25, 0x00	; 0
    21a0:	02 2e       	mov	r0, r18
    21a2:	02 c0       	rjmp	.+4      	; 0x21a8 <MDIO_VoidSetPinDirection+0x176>
    21a4:	88 0f       	add	r24, r24
    21a6:	99 1f       	adc	r25, r25
    21a8:	0a 94       	dec	r0
    21aa:	e2 f7       	brpl	.-8      	; 0x21a4 <MDIO_VoidSetPinDirection+0x172>
    21ac:	80 95       	com	r24
    21ae:	84 23       	and	r24, r20
    21b0:	8c 93       	st	X, r24
    21b2:	3e c0       	rjmp	.+124    	; 0x2230 <MDIO_VoidSetPinDirection+0x1fe>
				case DIO_PORTB:CLR_BIT(DDRB_REG, Copy_u8Pin); break;
    21b4:	a7 e3       	ldi	r26, 0x37	; 55
    21b6:	b0 e0       	ldi	r27, 0x00	; 0
    21b8:	e7 e3       	ldi	r30, 0x37	; 55
    21ba:	f0 e0       	ldi	r31, 0x00	; 0
    21bc:	80 81       	ld	r24, Z
    21be:	48 2f       	mov	r20, r24
    21c0:	8a 81       	ldd	r24, Y+2	; 0x02
    21c2:	28 2f       	mov	r18, r24
    21c4:	30 e0       	ldi	r19, 0x00	; 0
    21c6:	81 e0       	ldi	r24, 0x01	; 1
    21c8:	90 e0       	ldi	r25, 0x00	; 0
    21ca:	02 2e       	mov	r0, r18
    21cc:	02 c0       	rjmp	.+4      	; 0x21d2 <MDIO_VoidSetPinDirection+0x1a0>
    21ce:	88 0f       	add	r24, r24
    21d0:	99 1f       	adc	r25, r25
    21d2:	0a 94       	dec	r0
    21d4:	e2 f7       	brpl	.-8      	; 0x21ce <MDIO_VoidSetPinDirection+0x19c>
    21d6:	80 95       	com	r24
    21d8:	84 23       	and	r24, r20
    21da:	8c 93       	st	X, r24
    21dc:	29 c0       	rjmp	.+82     	; 0x2230 <MDIO_VoidSetPinDirection+0x1fe>
				case DIO_PORTC:CLR_BIT(DDRC_REG, Copy_u8Pin); break;
    21de:	a4 e3       	ldi	r26, 0x34	; 52
    21e0:	b0 e0       	ldi	r27, 0x00	; 0
    21e2:	e4 e3       	ldi	r30, 0x34	; 52
    21e4:	f0 e0       	ldi	r31, 0x00	; 0
    21e6:	80 81       	ld	r24, Z
    21e8:	48 2f       	mov	r20, r24
    21ea:	8a 81       	ldd	r24, Y+2	; 0x02
    21ec:	28 2f       	mov	r18, r24
    21ee:	30 e0       	ldi	r19, 0x00	; 0
    21f0:	81 e0       	ldi	r24, 0x01	; 1
    21f2:	90 e0       	ldi	r25, 0x00	; 0
    21f4:	02 2e       	mov	r0, r18
    21f6:	02 c0       	rjmp	.+4      	; 0x21fc <MDIO_VoidSetPinDirection+0x1ca>
    21f8:	88 0f       	add	r24, r24
    21fa:	99 1f       	adc	r25, r25
    21fc:	0a 94       	dec	r0
    21fe:	e2 f7       	brpl	.-8      	; 0x21f8 <MDIO_VoidSetPinDirection+0x1c6>
    2200:	80 95       	com	r24
    2202:	84 23       	and	r24, r20
    2204:	8c 93       	st	X, r24
    2206:	14 c0       	rjmp	.+40     	; 0x2230 <MDIO_VoidSetPinDirection+0x1fe>
				case DIO_PORTD:CLR_BIT(DDRD_REG, Copy_u8Pin); break;
    2208:	a1 e3       	ldi	r26, 0x31	; 49
    220a:	b0 e0       	ldi	r27, 0x00	; 0
    220c:	e1 e3       	ldi	r30, 0x31	; 49
    220e:	f0 e0       	ldi	r31, 0x00	; 0
    2210:	80 81       	ld	r24, Z
    2212:	48 2f       	mov	r20, r24
    2214:	8a 81       	ldd	r24, Y+2	; 0x02
    2216:	28 2f       	mov	r18, r24
    2218:	30 e0       	ldi	r19, 0x00	; 0
    221a:	81 e0       	ldi	r24, 0x01	; 1
    221c:	90 e0       	ldi	r25, 0x00	; 0
    221e:	02 2e       	mov	r0, r18
    2220:	02 c0       	rjmp	.+4      	; 0x2226 <MDIO_VoidSetPinDirection+0x1f4>
    2222:	88 0f       	add	r24, r24
    2224:	99 1f       	adc	r25, r25
    2226:	0a 94       	dec	r0
    2228:	e2 f7       	brpl	.-8      	; 0x2222 <MDIO_VoidSetPinDirection+0x1f0>
    222a:	80 95       	com	r24
    222c:	84 23       	and	r24, r20
    222e:	8c 93       	st	X, r24
	}
	else
	{
		/*					Wrong PIN ID or POrt ID						*/
	}
}
    2230:	27 96       	adiw	r28, 0x07	; 7
    2232:	0f b6       	in	r0, 0x3f	; 63
    2234:	f8 94       	cli
    2236:	de bf       	out	0x3e, r29	; 62
    2238:	0f be       	out	0x3f, r0	; 63
    223a:	cd bf       	out	0x3d, r28	; 61
    223c:	cf 91       	pop	r28
    223e:	df 91       	pop	r29
    2240:	08 95       	ret

00002242 <MDIO_VoidSetPinValue>:
 *
 * 			Here we Set the Pin value of the given port to 1 or 0
 *
 *************************************************************************/
void MDIO_VoidSetPinValue(u8 Copy_u8Port ,u8 Copy_u8Pin, u8 Copy_u8Value)
{
    2242:	df 93       	push	r29
    2244:	cf 93       	push	r28
    2246:	cd b7       	in	r28, 0x3d	; 61
    2248:	de b7       	in	r29, 0x3e	; 62
    224a:	27 97       	sbiw	r28, 0x07	; 7
    224c:	0f b6       	in	r0, 0x3f	; 63
    224e:	f8 94       	cli
    2250:	de bf       	out	0x3e, r29	; 62
    2252:	0f be       	out	0x3f, r0	; 63
    2254:	cd bf       	out	0x3d, r28	; 61
    2256:	89 83       	std	Y+1, r24	; 0x01
    2258:	6a 83       	std	Y+2, r22	; 0x02
    225a:	4b 83       	std	Y+3, r20	; 0x03
	/*					check for pins and ports					*/
	if(Copy_u8Port <= DIO_PORTD  && Copy_u8Pin <= DIO_PIN7)
    225c:	89 81       	ldd	r24, Y+1	; 0x01
    225e:	84 30       	cpi	r24, 0x04	; 4
    2260:	08 f0       	brcs	.+2      	; 0x2264 <MDIO_VoidSetPinValue+0x22>
    2262:	ee c0       	rjmp	.+476    	; 0x2440 <MDIO_VoidSetPinValue+0x1fe>
    2264:	8a 81       	ldd	r24, Y+2	; 0x02
    2266:	88 30       	cpi	r24, 0x08	; 8
    2268:	08 f0       	brcs	.+2      	; 0x226c <MDIO_VoidSetPinValue+0x2a>
    226a:	ea c0       	rjmp	.+468    	; 0x2440 <MDIO_VoidSetPinValue+0x1fe>
	{
	/*check the direction*/
		if(DIO_PIN_HIGH == Copy_u8Value)
    226c:	8b 81       	ldd	r24, Y+3	; 0x03
    226e:	81 30       	cpi	r24, 0x01	; 1
    2270:	09 f0       	breq	.+2      	; 0x2274 <MDIO_VoidSetPinValue+0x32>
    2272:	6f c0       	rjmp	.+222    	; 0x2352 <MDIO_VoidSetPinValue+0x110>
		{
			switch(Copy_u8Port)
    2274:	89 81       	ldd	r24, Y+1	; 0x01
    2276:	28 2f       	mov	r18, r24
    2278:	30 e0       	ldi	r19, 0x00	; 0
    227a:	3f 83       	std	Y+7, r19	; 0x07
    227c:	2e 83       	std	Y+6, r18	; 0x06
    227e:	8e 81       	ldd	r24, Y+6	; 0x06
    2280:	9f 81       	ldd	r25, Y+7	; 0x07
    2282:	81 30       	cpi	r24, 0x01	; 1
    2284:	91 05       	cpc	r25, r1
    2286:	49 f1       	breq	.+82     	; 0x22da <MDIO_VoidSetPinValue+0x98>
    2288:	2e 81       	ldd	r18, Y+6	; 0x06
    228a:	3f 81       	ldd	r19, Y+7	; 0x07
    228c:	22 30       	cpi	r18, 0x02	; 2
    228e:	31 05       	cpc	r19, r1
    2290:	2c f4       	brge	.+10     	; 0x229c <MDIO_VoidSetPinValue+0x5a>
    2292:	8e 81       	ldd	r24, Y+6	; 0x06
    2294:	9f 81       	ldd	r25, Y+7	; 0x07
    2296:	00 97       	sbiw	r24, 0x00	; 0
    2298:	61 f0       	breq	.+24     	; 0x22b2 <MDIO_VoidSetPinValue+0x70>
    229a:	d2 c0       	rjmp	.+420    	; 0x2440 <MDIO_VoidSetPinValue+0x1fe>
    229c:	2e 81       	ldd	r18, Y+6	; 0x06
    229e:	3f 81       	ldd	r19, Y+7	; 0x07
    22a0:	22 30       	cpi	r18, 0x02	; 2
    22a2:	31 05       	cpc	r19, r1
    22a4:	71 f1       	breq	.+92     	; 0x2302 <MDIO_VoidSetPinValue+0xc0>
    22a6:	8e 81       	ldd	r24, Y+6	; 0x06
    22a8:	9f 81       	ldd	r25, Y+7	; 0x07
    22aa:	83 30       	cpi	r24, 0x03	; 3
    22ac:	91 05       	cpc	r25, r1
    22ae:	e9 f1       	breq	.+122    	; 0x232a <MDIO_VoidSetPinValue+0xe8>
    22b0:	c7 c0       	rjmp	.+398    	; 0x2440 <MDIO_VoidSetPinValue+0x1fe>
			{
				case DIO_PORTA:SET_BIT(PORTA_REG, Copy_u8Pin); break;
    22b2:	ab e3       	ldi	r26, 0x3B	; 59
    22b4:	b0 e0       	ldi	r27, 0x00	; 0
    22b6:	eb e3       	ldi	r30, 0x3B	; 59
    22b8:	f0 e0       	ldi	r31, 0x00	; 0
    22ba:	80 81       	ld	r24, Z
    22bc:	48 2f       	mov	r20, r24
    22be:	8a 81       	ldd	r24, Y+2	; 0x02
    22c0:	28 2f       	mov	r18, r24
    22c2:	30 e0       	ldi	r19, 0x00	; 0
    22c4:	81 e0       	ldi	r24, 0x01	; 1
    22c6:	90 e0       	ldi	r25, 0x00	; 0
    22c8:	02 2e       	mov	r0, r18
    22ca:	02 c0       	rjmp	.+4      	; 0x22d0 <MDIO_VoidSetPinValue+0x8e>
    22cc:	88 0f       	add	r24, r24
    22ce:	99 1f       	adc	r25, r25
    22d0:	0a 94       	dec	r0
    22d2:	e2 f7       	brpl	.-8      	; 0x22cc <MDIO_VoidSetPinValue+0x8a>
    22d4:	84 2b       	or	r24, r20
    22d6:	8c 93       	st	X, r24
    22d8:	b3 c0       	rjmp	.+358    	; 0x2440 <MDIO_VoidSetPinValue+0x1fe>
				case DIO_PORTB:SET_BIT(PORTB_REG, Copy_u8Pin); break;
    22da:	a8 e3       	ldi	r26, 0x38	; 56
    22dc:	b0 e0       	ldi	r27, 0x00	; 0
    22de:	e8 e3       	ldi	r30, 0x38	; 56
    22e0:	f0 e0       	ldi	r31, 0x00	; 0
    22e2:	80 81       	ld	r24, Z
    22e4:	48 2f       	mov	r20, r24
    22e6:	8a 81       	ldd	r24, Y+2	; 0x02
    22e8:	28 2f       	mov	r18, r24
    22ea:	30 e0       	ldi	r19, 0x00	; 0
    22ec:	81 e0       	ldi	r24, 0x01	; 1
    22ee:	90 e0       	ldi	r25, 0x00	; 0
    22f0:	02 2e       	mov	r0, r18
    22f2:	02 c0       	rjmp	.+4      	; 0x22f8 <MDIO_VoidSetPinValue+0xb6>
    22f4:	88 0f       	add	r24, r24
    22f6:	99 1f       	adc	r25, r25
    22f8:	0a 94       	dec	r0
    22fa:	e2 f7       	brpl	.-8      	; 0x22f4 <MDIO_VoidSetPinValue+0xb2>
    22fc:	84 2b       	or	r24, r20
    22fe:	8c 93       	st	X, r24
    2300:	9f c0       	rjmp	.+318    	; 0x2440 <MDIO_VoidSetPinValue+0x1fe>
				case DIO_PORTC:SET_BIT(PORTC_REG, Copy_u8Pin); break;
    2302:	a5 e3       	ldi	r26, 0x35	; 53
    2304:	b0 e0       	ldi	r27, 0x00	; 0
    2306:	e5 e3       	ldi	r30, 0x35	; 53
    2308:	f0 e0       	ldi	r31, 0x00	; 0
    230a:	80 81       	ld	r24, Z
    230c:	48 2f       	mov	r20, r24
    230e:	8a 81       	ldd	r24, Y+2	; 0x02
    2310:	28 2f       	mov	r18, r24
    2312:	30 e0       	ldi	r19, 0x00	; 0
    2314:	81 e0       	ldi	r24, 0x01	; 1
    2316:	90 e0       	ldi	r25, 0x00	; 0
    2318:	02 2e       	mov	r0, r18
    231a:	02 c0       	rjmp	.+4      	; 0x2320 <MDIO_VoidSetPinValue+0xde>
    231c:	88 0f       	add	r24, r24
    231e:	99 1f       	adc	r25, r25
    2320:	0a 94       	dec	r0
    2322:	e2 f7       	brpl	.-8      	; 0x231c <MDIO_VoidSetPinValue+0xda>
    2324:	84 2b       	or	r24, r20
    2326:	8c 93       	st	X, r24
    2328:	8b c0       	rjmp	.+278    	; 0x2440 <MDIO_VoidSetPinValue+0x1fe>
				case DIO_PORTD:SET_BIT(PORTD_REG, Copy_u8Pin); break;
    232a:	a2 e3       	ldi	r26, 0x32	; 50
    232c:	b0 e0       	ldi	r27, 0x00	; 0
    232e:	e2 e3       	ldi	r30, 0x32	; 50
    2330:	f0 e0       	ldi	r31, 0x00	; 0
    2332:	80 81       	ld	r24, Z
    2334:	48 2f       	mov	r20, r24
    2336:	8a 81       	ldd	r24, Y+2	; 0x02
    2338:	28 2f       	mov	r18, r24
    233a:	30 e0       	ldi	r19, 0x00	; 0
    233c:	81 e0       	ldi	r24, 0x01	; 1
    233e:	90 e0       	ldi	r25, 0x00	; 0
    2340:	02 2e       	mov	r0, r18
    2342:	02 c0       	rjmp	.+4      	; 0x2348 <MDIO_VoidSetPinValue+0x106>
    2344:	88 0f       	add	r24, r24
    2346:	99 1f       	adc	r25, r25
    2348:	0a 94       	dec	r0
    234a:	e2 f7       	brpl	.-8      	; 0x2344 <MDIO_VoidSetPinValue+0x102>
    234c:	84 2b       	or	r24, r20
    234e:	8c 93       	st	X, r24
    2350:	77 c0       	rjmp	.+238    	; 0x2440 <MDIO_VoidSetPinValue+0x1fe>
				default: /*		Wrong POrt ID		*/	   	   break;
			}
		}
	/**/
		else if(DIO_PIN_LOW == Copy_u8Value)
    2352:	8b 81       	ldd	r24, Y+3	; 0x03
    2354:	88 23       	and	r24, r24
    2356:	09 f0       	breq	.+2      	; 0x235a <MDIO_VoidSetPinValue+0x118>
    2358:	73 c0       	rjmp	.+230    	; 0x2440 <MDIO_VoidSetPinValue+0x1fe>
		{
			switch(Copy_u8Port)
    235a:	89 81       	ldd	r24, Y+1	; 0x01
    235c:	28 2f       	mov	r18, r24
    235e:	30 e0       	ldi	r19, 0x00	; 0
    2360:	3d 83       	std	Y+5, r19	; 0x05
    2362:	2c 83       	std	Y+4, r18	; 0x04
    2364:	8c 81       	ldd	r24, Y+4	; 0x04
    2366:	9d 81       	ldd	r25, Y+5	; 0x05
    2368:	81 30       	cpi	r24, 0x01	; 1
    236a:	91 05       	cpc	r25, r1
    236c:	59 f1       	breq	.+86     	; 0x23c4 <MDIO_VoidSetPinValue+0x182>
    236e:	2c 81       	ldd	r18, Y+4	; 0x04
    2370:	3d 81       	ldd	r19, Y+5	; 0x05
    2372:	22 30       	cpi	r18, 0x02	; 2
    2374:	31 05       	cpc	r19, r1
    2376:	2c f4       	brge	.+10     	; 0x2382 <MDIO_VoidSetPinValue+0x140>
    2378:	8c 81       	ldd	r24, Y+4	; 0x04
    237a:	9d 81       	ldd	r25, Y+5	; 0x05
    237c:	00 97       	sbiw	r24, 0x00	; 0
    237e:	69 f0       	breq	.+26     	; 0x239a <MDIO_VoidSetPinValue+0x158>
    2380:	5f c0       	rjmp	.+190    	; 0x2440 <MDIO_VoidSetPinValue+0x1fe>
    2382:	2c 81       	ldd	r18, Y+4	; 0x04
    2384:	3d 81       	ldd	r19, Y+5	; 0x05
    2386:	22 30       	cpi	r18, 0x02	; 2
    2388:	31 05       	cpc	r19, r1
    238a:	89 f1       	breq	.+98     	; 0x23ee <MDIO_VoidSetPinValue+0x1ac>
    238c:	8c 81       	ldd	r24, Y+4	; 0x04
    238e:	9d 81       	ldd	r25, Y+5	; 0x05
    2390:	83 30       	cpi	r24, 0x03	; 3
    2392:	91 05       	cpc	r25, r1
    2394:	09 f4       	brne	.+2      	; 0x2398 <MDIO_VoidSetPinValue+0x156>
    2396:	40 c0       	rjmp	.+128    	; 0x2418 <MDIO_VoidSetPinValue+0x1d6>
    2398:	53 c0       	rjmp	.+166    	; 0x2440 <MDIO_VoidSetPinValue+0x1fe>
			{
				case DIO_PORTA:CLR_BIT(PORTA_REG, Copy_u8Pin); break;
    239a:	ab e3       	ldi	r26, 0x3B	; 59
    239c:	b0 e0       	ldi	r27, 0x00	; 0
    239e:	eb e3       	ldi	r30, 0x3B	; 59
    23a0:	f0 e0       	ldi	r31, 0x00	; 0
    23a2:	80 81       	ld	r24, Z
    23a4:	48 2f       	mov	r20, r24
    23a6:	8a 81       	ldd	r24, Y+2	; 0x02
    23a8:	28 2f       	mov	r18, r24
    23aa:	30 e0       	ldi	r19, 0x00	; 0
    23ac:	81 e0       	ldi	r24, 0x01	; 1
    23ae:	90 e0       	ldi	r25, 0x00	; 0
    23b0:	02 2e       	mov	r0, r18
    23b2:	02 c0       	rjmp	.+4      	; 0x23b8 <MDIO_VoidSetPinValue+0x176>
    23b4:	88 0f       	add	r24, r24
    23b6:	99 1f       	adc	r25, r25
    23b8:	0a 94       	dec	r0
    23ba:	e2 f7       	brpl	.-8      	; 0x23b4 <MDIO_VoidSetPinValue+0x172>
    23bc:	80 95       	com	r24
    23be:	84 23       	and	r24, r20
    23c0:	8c 93       	st	X, r24
    23c2:	3e c0       	rjmp	.+124    	; 0x2440 <MDIO_VoidSetPinValue+0x1fe>
				case DIO_PORTB:CLR_BIT(PORTB_REG, Copy_u8Pin); break;
    23c4:	a8 e3       	ldi	r26, 0x38	; 56
    23c6:	b0 e0       	ldi	r27, 0x00	; 0
    23c8:	e8 e3       	ldi	r30, 0x38	; 56
    23ca:	f0 e0       	ldi	r31, 0x00	; 0
    23cc:	80 81       	ld	r24, Z
    23ce:	48 2f       	mov	r20, r24
    23d0:	8a 81       	ldd	r24, Y+2	; 0x02
    23d2:	28 2f       	mov	r18, r24
    23d4:	30 e0       	ldi	r19, 0x00	; 0
    23d6:	81 e0       	ldi	r24, 0x01	; 1
    23d8:	90 e0       	ldi	r25, 0x00	; 0
    23da:	02 2e       	mov	r0, r18
    23dc:	02 c0       	rjmp	.+4      	; 0x23e2 <MDIO_VoidSetPinValue+0x1a0>
    23de:	88 0f       	add	r24, r24
    23e0:	99 1f       	adc	r25, r25
    23e2:	0a 94       	dec	r0
    23e4:	e2 f7       	brpl	.-8      	; 0x23de <MDIO_VoidSetPinValue+0x19c>
    23e6:	80 95       	com	r24
    23e8:	84 23       	and	r24, r20
    23ea:	8c 93       	st	X, r24
    23ec:	29 c0       	rjmp	.+82     	; 0x2440 <MDIO_VoidSetPinValue+0x1fe>
				case DIO_PORTC:CLR_BIT(PORTC_REG, Copy_u8Pin); break;
    23ee:	a5 e3       	ldi	r26, 0x35	; 53
    23f0:	b0 e0       	ldi	r27, 0x00	; 0
    23f2:	e5 e3       	ldi	r30, 0x35	; 53
    23f4:	f0 e0       	ldi	r31, 0x00	; 0
    23f6:	80 81       	ld	r24, Z
    23f8:	48 2f       	mov	r20, r24
    23fa:	8a 81       	ldd	r24, Y+2	; 0x02
    23fc:	28 2f       	mov	r18, r24
    23fe:	30 e0       	ldi	r19, 0x00	; 0
    2400:	81 e0       	ldi	r24, 0x01	; 1
    2402:	90 e0       	ldi	r25, 0x00	; 0
    2404:	02 2e       	mov	r0, r18
    2406:	02 c0       	rjmp	.+4      	; 0x240c <MDIO_VoidSetPinValue+0x1ca>
    2408:	88 0f       	add	r24, r24
    240a:	99 1f       	adc	r25, r25
    240c:	0a 94       	dec	r0
    240e:	e2 f7       	brpl	.-8      	; 0x2408 <MDIO_VoidSetPinValue+0x1c6>
    2410:	80 95       	com	r24
    2412:	84 23       	and	r24, r20
    2414:	8c 93       	st	X, r24
    2416:	14 c0       	rjmp	.+40     	; 0x2440 <MDIO_VoidSetPinValue+0x1fe>
				case DIO_PORTD:CLR_BIT(PORTD_REG, Copy_u8Pin); break;
    2418:	a2 e3       	ldi	r26, 0x32	; 50
    241a:	b0 e0       	ldi	r27, 0x00	; 0
    241c:	e2 e3       	ldi	r30, 0x32	; 50
    241e:	f0 e0       	ldi	r31, 0x00	; 0
    2420:	80 81       	ld	r24, Z
    2422:	48 2f       	mov	r20, r24
    2424:	8a 81       	ldd	r24, Y+2	; 0x02
    2426:	28 2f       	mov	r18, r24
    2428:	30 e0       	ldi	r19, 0x00	; 0
    242a:	81 e0       	ldi	r24, 0x01	; 1
    242c:	90 e0       	ldi	r25, 0x00	; 0
    242e:	02 2e       	mov	r0, r18
    2430:	02 c0       	rjmp	.+4      	; 0x2436 <MDIO_VoidSetPinValue+0x1f4>
    2432:	88 0f       	add	r24, r24
    2434:	99 1f       	adc	r25, r25
    2436:	0a 94       	dec	r0
    2438:	e2 f7       	brpl	.-8      	; 0x2432 <MDIO_VoidSetPinValue+0x1f0>
    243a:	80 95       	com	r24
    243c:	84 23       	and	r24, r20
    243e:	8c 93       	st	X, r24
	else
	{
		/*Wrong PIN ID or POrt ID*/
	}

}
    2440:	27 96       	adiw	r28, 0x07	; 7
    2442:	0f b6       	in	r0, 0x3f	; 63
    2444:	f8 94       	cli
    2446:	de bf       	out	0x3e, r29	; 62
    2448:	0f be       	out	0x3f, r0	; 63
    244a:	cd bf       	out	0x3d, r28	; 61
    244c:	cf 91       	pop	r28
    244e:	df 91       	pop	r29
    2450:	08 95       	ret

00002452 <MDIO_u8GetPinValue>:
 *
 * 			Here we get the Pin value of the given port and pin
 *
 *************************************************************************/
u8 MDIO_u8GetPinValue(u8 Copy_u8Port ,u8 Copy_u8Pin)
{
    2452:	df 93       	push	r29
    2454:	cf 93       	push	r28
    2456:	00 d0       	rcall	.+0      	; 0x2458 <MDIO_u8GetPinValue+0x6>
    2458:	00 d0       	rcall	.+0      	; 0x245a <MDIO_u8GetPinValue+0x8>
    245a:	0f 92       	push	r0
    245c:	cd b7       	in	r28, 0x3d	; 61
    245e:	de b7       	in	r29, 0x3e	; 62
    2460:	8a 83       	std	Y+2, r24	; 0x02
    2462:	6b 83       	std	Y+3, r22	; 0x03
	/*					check for pins and ports					*/
	u8 LOC_u8RetValue_var1;
	if(Copy_u8Port <= DIO_PORTD  && Copy_u8Pin <= DIO_PIN7)
    2464:	8a 81       	ldd	r24, Y+2	; 0x02
    2466:	84 30       	cpi	r24, 0x04	; 4
    2468:	08 f0       	brcs	.+2      	; 0x246c <MDIO_u8GetPinValue+0x1a>
    246a:	6c c0       	rjmp	.+216    	; 0x2544 <MDIO_u8GetPinValue+0xf2>
    246c:	8b 81       	ldd	r24, Y+3	; 0x03
    246e:	88 30       	cpi	r24, 0x08	; 8
    2470:	08 f0       	brcs	.+2      	; 0x2474 <MDIO_u8GetPinValue+0x22>
    2472:	68 c0       	rjmp	.+208    	; 0x2544 <MDIO_u8GetPinValue+0xf2>
	{

		switch(Copy_u8Port)
    2474:	8a 81       	ldd	r24, Y+2	; 0x02
    2476:	28 2f       	mov	r18, r24
    2478:	30 e0       	ldi	r19, 0x00	; 0
    247a:	3d 83       	std	Y+5, r19	; 0x05
    247c:	2c 83       	std	Y+4, r18	; 0x04
    247e:	4c 81       	ldd	r20, Y+4	; 0x04
    2480:	5d 81       	ldd	r21, Y+5	; 0x05
    2482:	41 30       	cpi	r20, 0x01	; 1
    2484:	51 05       	cpc	r21, r1
    2486:	41 f1       	breq	.+80     	; 0x24d8 <MDIO_u8GetPinValue+0x86>
    2488:	8c 81       	ldd	r24, Y+4	; 0x04
    248a:	9d 81       	ldd	r25, Y+5	; 0x05
    248c:	82 30       	cpi	r24, 0x02	; 2
    248e:	91 05       	cpc	r25, r1
    2490:	34 f4       	brge	.+12     	; 0x249e <MDIO_u8GetPinValue+0x4c>
    2492:	2c 81       	ldd	r18, Y+4	; 0x04
    2494:	3d 81       	ldd	r19, Y+5	; 0x05
    2496:	21 15       	cp	r18, r1
    2498:	31 05       	cpc	r19, r1
    249a:	61 f0       	breq	.+24     	; 0x24b4 <MDIO_u8GetPinValue+0x62>
    249c:	55 c0       	rjmp	.+170    	; 0x2548 <MDIO_u8GetPinValue+0xf6>
    249e:	4c 81       	ldd	r20, Y+4	; 0x04
    24a0:	5d 81       	ldd	r21, Y+5	; 0x05
    24a2:	42 30       	cpi	r20, 0x02	; 2
    24a4:	51 05       	cpc	r21, r1
    24a6:	51 f1       	breq	.+84     	; 0x24fc <MDIO_u8GetPinValue+0xaa>
    24a8:	8c 81       	ldd	r24, Y+4	; 0x04
    24aa:	9d 81       	ldd	r25, Y+5	; 0x05
    24ac:	83 30       	cpi	r24, 0x03	; 3
    24ae:	91 05       	cpc	r25, r1
    24b0:	b9 f1       	breq	.+110    	; 0x2520 <MDIO_u8GetPinValue+0xce>
    24b2:	4a c0       	rjmp	.+148    	; 0x2548 <MDIO_u8GetPinValue+0xf6>
		{
			case DIO_PORTA: LOC_u8RetValue_var1 = GET_BIT(PINA_REG, Copy_u8Pin);break;
    24b4:	e9 e3       	ldi	r30, 0x39	; 57
    24b6:	f0 e0       	ldi	r31, 0x00	; 0
    24b8:	80 81       	ld	r24, Z
    24ba:	28 2f       	mov	r18, r24
    24bc:	30 e0       	ldi	r19, 0x00	; 0
    24be:	8b 81       	ldd	r24, Y+3	; 0x03
    24c0:	88 2f       	mov	r24, r24
    24c2:	90 e0       	ldi	r25, 0x00	; 0
    24c4:	a9 01       	movw	r20, r18
    24c6:	02 c0       	rjmp	.+4      	; 0x24cc <MDIO_u8GetPinValue+0x7a>
    24c8:	55 95       	asr	r21
    24ca:	47 95       	ror	r20
    24cc:	8a 95       	dec	r24
    24ce:	e2 f7       	brpl	.-8      	; 0x24c8 <MDIO_u8GetPinValue+0x76>
    24d0:	ca 01       	movw	r24, r20
    24d2:	81 70       	andi	r24, 0x01	; 1
    24d4:	89 83       	std	Y+1, r24	; 0x01
    24d6:	38 c0       	rjmp	.+112    	; 0x2548 <MDIO_u8GetPinValue+0xf6>
			case DIO_PORTB: LOC_u8RetValue_var1 = GET_BIT(PINB_REG, Copy_u8Pin);break;
    24d8:	e6 e3       	ldi	r30, 0x36	; 54
    24da:	f0 e0       	ldi	r31, 0x00	; 0
    24dc:	80 81       	ld	r24, Z
    24de:	28 2f       	mov	r18, r24
    24e0:	30 e0       	ldi	r19, 0x00	; 0
    24e2:	8b 81       	ldd	r24, Y+3	; 0x03
    24e4:	88 2f       	mov	r24, r24
    24e6:	90 e0       	ldi	r25, 0x00	; 0
    24e8:	a9 01       	movw	r20, r18
    24ea:	02 c0       	rjmp	.+4      	; 0x24f0 <MDIO_u8GetPinValue+0x9e>
    24ec:	55 95       	asr	r21
    24ee:	47 95       	ror	r20
    24f0:	8a 95       	dec	r24
    24f2:	e2 f7       	brpl	.-8      	; 0x24ec <MDIO_u8GetPinValue+0x9a>
    24f4:	ca 01       	movw	r24, r20
    24f6:	81 70       	andi	r24, 0x01	; 1
    24f8:	89 83       	std	Y+1, r24	; 0x01
    24fa:	26 c0       	rjmp	.+76     	; 0x2548 <MDIO_u8GetPinValue+0xf6>
			case DIO_PORTC: LOC_u8RetValue_var1 = GET_BIT(PINC_REG, Copy_u8Pin);break;
    24fc:	e3 e3       	ldi	r30, 0x33	; 51
    24fe:	f0 e0       	ldi	r31, 0x00	; 0
    2500:	80 81       	ld	r24, Z
    2502:	28 2f       	mov	r18, r24
    2504:	30 e0       	ldi	r19, 0x00	; 0
    2506:	8b 81       	ldd	r24, Y+3	; 0x03
    2508:	88 2f       	mov	r24, r24
    250a:	90 e0       	ldi	r25, 0x00	; 0
    250c:	a9 01       	movw	r20, r18
    250e:	02 c0       	rjmp	.+4      	; 0x2514 <MDIO_u8GetPinValue+0xc2>
    2510:	55 95       	asr	r21
    2512:	47 95       	ror	r20
    2514:	8a 95       	dec	r24
    2516:	e2 f7       	brpl	.-8      	; 0x2510 <MDIO_u8GetPinValue+0xbe>
    2518:	ca 01       	movw	r24, r20
    251a:	81 70       	andi	r24, 0x01	; 1
    251c:	89 83       	std	Y+1, r24	; 0x01
    251e:	14 c0       	rjmp	.+40     	; 0x2548 <MDIO_u8GetPinValue+0xf6>
			case DIO_PORTD: LOC_u8RetValue_var1 = GET_BIT(PIND_REG, Copy_u8Pin);break;
    2520:	e0 e3       	ldi	r30, 0x30	; 48
    2522:	f0 e0       	ldi	r31, 0x00	; 0
    2524:	80 81       	ld	r24, Z
    2526:	28 2f       	mov	r18, r24
    2528:	30 e0       	ldi	r19, 0x00	; 0
    252a:	8b 81       	ldd	r24, Y+3	; 0x03
    252c:	88 2f       	mov	r24, r24
    252e:	90 e0       	ldi	r25, 0x00	; 0
    2530:	a9 01       	movw	r20, r18
    2532:	02 c0       	rjmp	.+4      	; 0x2538 <MDIO_u8GetPinValue+0xe6>
    2534:	55 95       	asr	r21
    2536:	47 95       	ror	r20
    2538:	8a 95       	dec	r24
    253a:	e2 f7       	brpl	.-8      	; 0x2534 <MDIO_u8GetPinValue+0xe2>
    253c:	ca 01       	movw	r24, r20
    253e:	81 70       	andi	r24, 0x01	; 1
    2540:	89 83       	std	Y+1, r24	; 0x01
    2542:	02 c0       	rjmp	.+4      	; 0x2548 <MDIO_u8GetPinValue+0xf6>
		}
	}
	else
	{
		/*Wrong PIN ID or POrt ID*/
		LOC_u8RetValue_var1 = DIO_UNDEFINED_VAL;
    2544:	8f ef       	ldi	r24, 0xFF	; 255
    2546:	89 83       	std	Y+1, r24	; 0x01
	}
	return LOC_u8RetValue_var1;
    2548:	89 81       	ldd	r24, Y+1	; 0x01

}
    254a:	0f 90       	pop	r0
    254c:	0f 90       	pop	r0
    254e:	0f 90       	pop	r0
    2550:	0f 90       	pop	r0
    2552:	0f 90       	pop	r0
    2554:	cf 91       	pop	r28
    2556:	df 91       	pop	r29
    2558:	08 95       	ret

0000255a <MDIO_VoidSetPortDirection>:
 *
 * 			Here we Set the port direction of the given port to 1 or 0
 *
 *************************************************************************/
void MDIO_VoidSetPortDirection(u8 Copy_u8Port, u8 Copy_u8Direc)
{
    255a:	df 93       	push	r29
    255c:	cf 93       	push	r28
    255e:	00 d0       	rcall	.+0      	; 0x2560 <MDIO_VoidSetPortDirection+0x6>
    2560:	00 d0       	rcall	.+0      	; 0x2562 <MDIO_VoidSetPortDirection+0x8>
    2562:	cd b7       	in	r28, 0x3d	; 61
    2564:	de b7       	in	r29, 0x3e	; 62
    2566:	89 83       	std	Y+1, r24	; 0x01
    2568:	6a 83       	std	Y+2, r22	; 0x02
	/*							check for Port							*/
	switch(Copy_u8Port)
    256a:	89 81       	ldd	r24, Y+1	; 0x01
    256c:	28 2f       	mov	r18, r24
    256e:	30 e0       	ldi	r19, 0x00	; 0
    2570:	3c 83       	std	Y+4, r19	; 0x04
    2572:	2b 83       	std	Y+3, r18	; 0x03
    2574:	8b 81       	ldd	r24, Y+3	; 0x03
    2576:	9c 81       	ldd	r25, Y+4	; 0x04
    2578:	81 30       	cpi	r24, 0x01	; 1
    257a:	91 05       	cpc	r25, r1
    257c:	d1 f0       	breq	.+52     	; 0x25b2 <MDIO_VoidSetPortDirection+0x58>
    257e:	2b 81       	ldd	r18, Y+3	; 0x03
    2580:	3c 81       	ldd	r19, Y+4	; 0x04
    2582:	22 30       	cpi	r18, 0x02	; 2
    2584:	31 05       	cpc	r19, r1
    2586:	2c f4       	brge	.+10     	; 0x2592 <MDIO_VoidSetPortDirection+0x38>
    2588:	8b 81       	ldd	r24, Y+3	; 0x03
    258a:	9c 81       	ldd	r25, Y+4	; 0x04
    258c:	00 97       	sbiw	r24, 0x00	; 0
    258e:	61 f0       	breq	.+24     	; 0x25a8 <MDIO_VoidSetPortDirection+0x4e>
    2590:	1e c0       	rjmp	.+60     	; 0x25ce <MDIO_VoidSetPortDirection+0x74>
    2592:	2b 81       	ldd	r18, Y+3	; 0x03
    2594:	3c 81       	ldd	r19, Y+4	; 0x04
    2596:	22 30       	cpi	r18, 0x02	; 2
    2598:	31 05       	cpc	r19, r1
    259a:	81 f0       	breq	.+32     	; 0x25bc <MDIO_VoidSetPortDirection+0x62>
    259c:	8b 81       	ldd	r24, Y+3	; 0x03
    259e:	9c 81       	ldd	r25, Y+4	; 0x04
    25a0:	83 30       	cpi	r24, 0x03	; 3
    25a2:	91 05       	cpc	r25, r1
    25a4:	81 f0       	breq	.+32     	; 0x25c6 <MDIO_VoidSetPortDirection+0x6c>
    25a6:	13 c0       	rjmp	.+38     	; 0x25ce <MDIO_VoidSetPortDirection+0x74>
	{
		case DIO_PORTA:  DDRA_REG =  Copy_u8Direc; break;
    25a8:	ea e3       	ldi	r30, 0x3A	; 58
    25aa:	f0 e0       	ldi	r31, 0x00	; 0
    25ac:	8a 81       	ldd	r24, Y+2	; 0x02
    25ae:	80 83       	st	Z, r24
    25b0:	0e c0       	rjmp	.+28     	; 0x25ce <MDIO_VoidSetPortDirection+0x74>
		case DIO_PORTB:  DDRB_REG =  Copy_u8Direc; break;
    25b2:	e7 e3       	ldi	r30, 0x37	; 55
    25b4:	f0 e0       	ldi	r31, 0x00	; 0
    25b6:	8a 81       	ldd	r24, Y+2	; 0x02
    25b8:	80 83       	st	Z, r24
    25ba:	09 c0       	rjmp	.+18     	; 0x25ce <MDIO_VoidSetPortDirection+0x74>
		case DIO_PORTC:  DDRC_REG =  Copy_u8Direc; break;
    25bc:	e4 e3       	ldi	r30, 0x34	; 52
    25be:	f0 e0       	ldi	r31, 0x00	; 0
    25c0:	8a 81       	ldd	r24, Y+2	; 0x02
    25c2:	80 83       	st	Z, r24
    25c4:	04 c0       	rjmp	.+8      	; 0x25ce <MDIO_VoidSetPortDirection+0x74>
		case DIO_PORTD:  DDRD_REG =  Copy_u8Direc; break;
    25c6:	e1 e3       	ldi	r30, 0x31	; 49
    25c8:	f0 e0       	ldi	r31, 0x00	; 0
    25ca:	8a 81       	ldd	r24, Y+2	; 0x02
    25cc:	80 83       	st	Z, r24
		default: /*		Wrong POrt ID		*/	   break;
	}
}
    25ce:	0f 90       	pop	r0
    25d0:	0f 90       	pop	r0
    25d2:	0f 90       	pop	r0
    25d4:	0f 90       	pop	r0
    25d6:	cf 91       	pop	r28
    25d8:	df 91       	pop	r29
    25da:	08 95       	ret

000025dc <MDIO_VoidSetPortValue>:
 *
 * 			Here we Set the port value of the given port to 1 or 0
 *
 *************************************************************************/
void MDIO_VoidSetPortValue(u8 Copy_u8Port ,u8 Copy_u8Value)
{
    25dc:	df 93       	push	r29
    25de:	cf 93       	push	r28
    25e0:	00 d0       	rcall	.+0      	; 0x25e2 <MDIO_VoidSetPortValue+0x6>
    25e2:	00 d0       	rcall	.+0      	; 0x25e4 <MDIO_VoidSetPortValue+0x8>
    25e4:	cd b7       	in	r28, 0x3d	; 61
    25e6:	de b7       	in	r29, 0x3e	; 62
    25e8:	89 83       	std	Y+1, r24	; 0x01
    25ea:	6a 83       	std	Y+2, r22	; 0x02
	/*						check for Port								*/
	switch(Copy_u8Port)
    25ec:	89 81       	ldd	r24, Y+1	; 0x01
    25ee:	28 2f       	mov	r18, r24
    25f0:	30 e0       	ldi	r19, 0x00	; 0
    25f2:	3c 83       	std	Y+4, r19	; 0x04
    25f4:	2b 83       	std	Y+3, r18	; 0x03
    25f6:	8b 81       	ldd	r24, Y+3	; 0x03
    25f8:	9c 81       	ldd	r25, Y+4	; 0x04
    25fa:	81 30       	cpi	r24, 0x01	; 1
    25fc:	91 05       	cpc	r25, r1
    25fe:	d1 f0       	breq	.+52     	; 0x2634 <MDIO_VoidSetPortValue+0x58>
    2600:	2b 81       	ldd	r18, Y+3	; 0x03
    2602:	3c 81       	ldd	r19, Y+4	; 0x04
    2604:	22 30       	cpi	r18, 0x02	; 2
    2606:	31 05       	cpc	r19, r1
    2608:	2c f4       	brge	.+10     	; 0x2614 <MDIO_VoidSetPortValue+0x38>
    260a:	8b 81       	ldd	r24, Y+3	; 0x03
    260c:	9c 81       	ldd	r25, Y+4	; 0x04
    260e:	00 97       	sbiw	r24, 0x00	; 0
    2610:	61 f0       	breq	.+24     	; 0x262a <MDIO_VoidSetPortValue+0x4e>
    2612:	1e c0       	rjmp	.+60     	; 0x2650 <MDIO_VoidSetPortValue+0x74>
    2614:	2b 81       	ldd	r18, Y+3	; 0x03
    2616:	3c 81       	ldd	r19, Y+4	; 0x04
    2618:	22 30       	cpi	r18, 0x02	; 2
    261a:	31 05       	cpc	r19, r1
    261c:	81 f0       	breq	.+32     	; 0x263e <MDIO_VoidSetPortValue+0x62>
    261e:	8b 81       	ldd	r24, Y+3	; 0x03
    2620:	9c 81       	ldd	r25, Y+4	; 0x04
    2622:	83 30       	cpi	r24, 0x03	; 3
    2624:	91 05       	cpc	r25, r1
    2626:	81 f0       	breq	.+32     	; 0x2648 <MDIO_VoidSetPortValue+0x6c>
    2628:	13 c0       	rjmp	.+38     	; 0x2650 <MDIO_VoidSetPortValue+0x74>
	{
		case DIO_PORTA:  PORTA_REG =  Copy_u8Value; break;
    262a:	eb e3       	ldi	r30, 0x3B	; 59
    262c:	f0 e0       	ldi	r31, 0x00	; 0
    262e:	8a 81       	ldd	r24, Y+2	; 0x02
    2630:	80 83       	st	Z, r24
    2632:	0e c0       	rjmp	.+28     	; 0x2650 <MDIO_VoidSetPortValue+0x74>
		case DIO_PORTB:  PORTB_REG =  Copy_u8Value; break;
    2634:	e8 e3       	ldi	r30, 0x38	; 56
    2636:	f0 e0       	ldi	r31, 0x00	; 0
    2638:	8a 81       	ldd	r24, Y+2	; 0x02
    263a:	80 83       	st	Z, r24
    263c:	09 c0       	rjmp	.+18     	; 0x2650 <MDIO_VoidSetPortValue+0x74>
		case DIO_PORTC:  PORTC_REG =  Copy_u8Value; break;
    263e:	e5 e3       	ldi	r30, 0x35	; 53
    2640:	f0 e0       	ldi	r31, 0x00	; 0
    2642:	8a 81       	ldd	r24, Y+2	; 0x02
    2644:	80 83       	st	Z, r24
    2646:	04 c0       	rjmp	.+8      	; 0x2650 <MDIO_VoidSetPortValue+0x74>
		case DIO_PORTD:  PORTD_REG =  Copy_u8Value; break;
    2648:	e2 e3       	ldi	r30, 0x32	; 50
    264a:	f0 e0       	ldi	r31, 0x00	; 0
    264c:	8a 81       	ldd	r24, Y+2	; 0x02
    264e:	80 83       	st	Z, r24
		default: /*		Wrong POrt ID		*/		break;
	}
}
    2650:	0f 90       	pop	r0
    2652:	0f 90       	pop	r0
    2654:	0f 90       	pop	r0
    2656:	0f 90       	pop	r0
    2658:	cf 91       	pop	r28
    265a:	df 91       	pop	r29
    265c:	08 95       	ret

0000265e <MDIO_VoidTogglePin>:
 *
 * 			Here we toggle the Pin
 *
 *************************************************************************/
void MDIO_VoidTogglePin(u8 Copy_u8Port ,u8 Copy_u8Pin)
{
    265e:	df 93       	push	r29
    2660:	cf 93       	push	r28
    2662:	00 d0       	rcall	.+0      	; 0x2664 <MDIO_VoidTogglePin+0x6>
    2664:	00 d0       	rcall	.+0      	; 0x2666 <MDIO_VoidTogglePin+0x8>
    2666:	cd b7       	in	r28, 0x3d	; 61
    2668:	de b7       	in	r29, 0x3e	; 62
    266a:	89 83       	std	Y+1, r24	; 0x01
    266c:	6a 83       	std	Y+2, r22	; 0x02
	/*					check for pins and ports					*/
	if(Copy_u8Port <= DIO_PORTD  && Copy_u8Pin <= DIO_PIN7)
    266e:	89 81       	ldd	r24, Y+1	; 0x01
    2670:	84 30       	cpi	r24, 0x04	; 4
    2672:	08 f0       	brcs	.+2      	; 0x2676 <MDIO_VoidTogglePin+0x18>
    2674:	72 c0       	rjmp	.+228    	; 0x275a <MDIO_VoidTogglePin+0xfc>
    2676:	8a 81       	ldd	r24, Y+2	; 0x02
    2678:	88 30       	cpi	r24, 0x08	; 8
    267a:	08 f0       	brcs	.+2      	; 0x267e <MDIO_VoidTogglePin+0x20>
    267c:	6e c0       	rjmp	.+220    	; 0x275a <MDIO_VoidTogglePin+0xfc>
	{
		switch(Copy_u8Port)
    267e:	89 81       	ldd	r24, Y+1	; 0x01
    2680:	28 2f       	mov	r18, r24
    2682:	30 e0       	ldi	r19, 0x00	; 0
    2684:	3c 83       	std	Y+4, r19	; 0x04
    2686:	2b 83       	std	Y+3, r18	; 0x03
    2688:	8b 81       	ldd	r24, Y+3	; 0x03
    268a:	9c 81       	ldd	r25, Y+4	; 0x04
    268c:	81 30       	cpi	r24, 0x01	; 1
    268e:	91 05       	cpc	r25, r1
    2690:	49 f1       	breq	.+82     	; 0x26e4 <MDIO_VoidTogglePin+0x86>
    2692:	2b 81       	ldd	r18, Y+3	; 0x03
    2694:	3c 81       	ldd	r19, Y+4	; 0x04
    2696:	22 30       	cpi	r18, 0x02	; 2
    2698:	31 05       	cpc	r19, r1
    269a:	2c f4       	brge	.+10     	; 0x26a6 <MDIO_VoidTogglePin+0x48>
    269c:	8b 81       	ldd	r24, Y+3	; 0x03
    269e:	9c 81       	ldd	r25, Y+4	; 0x04
    26a0:	00 97       	sbiw	r24, 0x00	; 0
    26a2:	61 f0       	breq	.+24     	; 0x26bc <MDIO_VoidTogglePin+0x5e>
    26a4:	5a c0       	rjmp	.+180    	; 0x275a <MDIO_VoidTogglePin+0xfc>
    26a6:	2b 81       	ldd	r18, Y+3	; 0x03
    26a8:	3c 81       	ldd	r19, Y+4	; 0x04
    26aa:	22 30       	cpi	r18, 0x02	; 2
    26ac:	31 05       	cpc	r19, r1
    26ae:	71 f1       	breq	.+92     	; 0x270c <MDIO_VoidTogglePin+0xae>
    26b0:	8b 81       	ldd	r24, Y+3	; 0x03
    26b2:	9c 81       	ldd	r25, Y+4	; 0x04
    26b4:	83 30       	cpi	r24, 0x03	; 3
    26b6:	91 05       	cpc	r25, r1
    26b8:	e9 f1       	breq	.+122    	; 0x2734 <MDIO_VoidTogglePin+0xd6>
    26ba:	4f c0       	rjmp	.+158    	; 0x275a <MDIO_VoidTogglePin+0xfc>
		{
			case DIO_PORTA:TOGGLE_BIT(PORTA_REG, Copy_u8Pin); break;
    26bc:	ab e3       	ldi	r26, 0x3B	; 59
    26be:	b0 e0       	ldi	r27, 0x00	; 0
    26c0:	eb e3       	ldi	r30, 0x3B	; 59
    26c2:	f0 e0       	ldi	r31, 0x00	; 0
    26c4:	80 81       	ld	r24, Z
    26c6:	48 2f       	mov	r20, r24
    26c8:	8a 81       	ldd	r24, Y+2	; 0x02
    26ca:	28 2f       	mov	r18, r24
    26cc:	30 e0       	ldi	r19, 0x00	; 0
    26ce:	81 e0       	ldi	r24, 0x01	; 1
    26d0:	90 e0       	ldi	r25, 0x00	; 0
    26d2:	02 2e       	mov	r0, r18
    26d4:	02 c0       	rjmp	.+4      	; 0x26da <MDIO_VoidTogglePin+0x7c>
    26d6:	88 0f       	add	r24, r24
    26d8:	99 1f       	adc	r25, r25
    26da:	0a 94       	dec	r0
    26dc:	e2 f7       	brpl	.-8      	; 0x26d6 <MDIO_VoidTogglePin+0x78>
    26de:	84 27       	eor	r24, r20
    26e0:	8c 93       	st	X, r24
    26e2:	3b c0       	rjmp	.+118    	; 0x275a <MDIO_VoidTogglePin+0xfc>
			case DIO_PORTB:TOGGLE_BIT(PORTB_REG, Copy_u8Pin); break;
    26e4:	a8 e3       	ldi	r26, 0x38	; 56
    26e6:	b0 e0       	ldi	r27, 0x00	; 0
    26e8:	e8 e3       	ldi	r30, 0x38	; 56
    26ea:	f0 e0       	ldi	r31, 0x00	; 0
    26ec:	80 81       	ld	r24, Z
    26ee:	48 2f       	mov	r20, r24
    26f0:	8a 81       	ldd	r24, Y+2	; 0x02
    26f2:	28 2f       	mov	r18, r24
    26f4:	30 e0       	ldi	r19, 0x00	; 0
    26f6:	81 e0       	ldi	r24, 0x01	; 1
    26f8:	90 e0       	ldi	r25, 0x00	; 0
    26fa:	02 2e       	mov	r0, r18
    26fc:	02 c0       	rjmp	.+4      	; 0x2702 <MDIO_VoidTogglePin+0xa4>
    26fe:	88 0f       	add	r24, r24
    2700:	99 1f       	adc	r25, r25
    2702:	0a 94       	dec	r0
    2704:	e2 f7       	brpl	.-8      	; 0x26fe <MDIO_VoidTogglePin+0xa0>
    2706:	84 27       	eor	r24, r20
    2708:	8c 93       	st	X, r24
    270a:	27 c0       	rjmp	.+78     	; 0x275a <MDIO_VoidTogglePin+0xfc>
			case DIO_PORTC:TOGGLE_BIT(PORTC_REG, Copy_u8Pin); break;
    270c:	a5 e3       	ldi	r26, 0x35	; 53
    270e:	b0 e0       	ldi	r27, 0x00	; 0
    2710:	e5 e3       	ldi	r30, 0x35	; 53
    2712:	f0 e0       	ldi	r31, 0x00	; 0
    2714:	80 81       	ld	r24, Z
    2716:	48 2f       	mov	r20, r24
    2718:	8a 81       	ldd	r24, Y+2	; 0x02
    271a:	28 2f       	mov	r18, r24
    271c:	30 e0       	ldi	r19, 0x00	; 0
    271e:	81 e0       	ldi	r24, 0x01	; 1
    2720:	90 e0       	ldi	r25, 0x00	; 0
    2722:	02 2e       	mov	r0, r18
    2724:	02 c0       	rjmp	.+4      	; 0x272a <MDIO_VoidTogglePin+0xcc>
    2726:	88 0f       	add	r24, r24
    2728:	99 1f       	adc	r25, r25
    272a:	0a 94       	dec	r0
    272c:	e2 f7       	brpl	.-8      	; 0x2726 <MDIO_VoidTogglePin+0xc8>
    272e:	84 27       	eor	r24, r20
    2730:	8c 93       	st	X, r24
    2732:	13 c0       	rjmp	.+38     	; 0x275a <MDIO_VoidTogglePin+0xfc>
			case DIO_PORTD:TOGGLE_BIT(PORTD_REG, Copy_u8Pin); break;
    2734:	a2 e3       	ldi	r26, 0x32	; 50
    2736:	b0 e0       	ldi	r27, 0x00	; 0
    2738:	e2 e3       	ldi	r30, 0x32	; 50
    273a:	f0 e0       	ldi	r31, 0x00	; 0
    273c:	80 81       	ld	r24, Z
    273e:	48 2f       	mov	r20, r24
    2740:	8a 81       	ldd	r24, Y+2	; 0x02
    2742:	28 2f       	mov	r18, r24
    2744:	30 e0       	ldi	r19, 0x00	; 0
    2746:	81 e0       	ldi	r24, 0x01	; 1
    2748:	90 e0       	ldi	r25, 0x00	; 0
    274a:	02 2e       	mov	r0, r18
    274c:	02 c0       	rjmp	.+4      	; 0x2752 <MDIO_VoidTogglePin+0xf4>
    274e:	88 0f       	add	r24, r24
    2750:	99 1f       	adc	r25, r25
    2752:	0a 94       	dec	r0
    2754:	e2 f7       	brpl	.-8      	; 0x274e <MDIO_VoidTogglePin+0xf0>
    2756:	84 27       	eor	r24, r20
    2758:	8c 93       	st	X, r24
	}
	else
	{
		/*Wrong PIN ID or POrt ID*/
	}
}
    275a:	0f 90       	pop	r0
    275c:	0f 90       	pop	r0
    275e:	0f 90       	pop	r0
    2760:	0f 90       	pop	r0
    2762:	cf 91       	pop	r28
    2764:	df 91       	pop	r29
    2766:	08 95       	ret

00002768 <MDIO_VoidEnablePullUpResistor>:
 *
 * 			Here we Enable the pull up resistor
 *
 *************************************************************************/
void MDIO_VoidEnablePullUpResistor(u8 Copy_u8Port,u8 Copy_u8Pin)
{
    2768:	df 93       	push	r29
    276a:	cf 93       	push	r28
    276c:	00 d0       	rcall	.+0      	; 0x276e <MDIO_VoidEnablePullUpResistor+0x6>
    276e:	00 d0       	rcall	.+0      	; 0x2770 <MDIO_VoidEnablePullUpResistor+0x8>
    2770:	cd b7       	in	r28, 0x3d	; 61
    2772:	de b7       	in	r29, 0x3e	; 62
    2774:	89 83       	std	Y+1, r24	; 0x01
    2776:	6a 83       	std	Y+2, r22	; 0x02
	/*					check for pins and ports					*/
	if(Copy_u8Port <= DIO_PORTD  && Copy_u8Pin <= DIO_PIN7)
    2778:	89 81       	ldd	r24, Y+1	; 0x01
    277a:	84 30       	cpi	r24, 0x04	; 4
    277c:	08 f0       	brcs	.+2      	; 0x2780 <MDIO_VoidEnablePullUpResistor+0x18>
    277e:	72 c0       	rjmp	.+228    	; 0x2864 <MDIO_VoidEnablePullUpResistor+0xfc>
    2780:	8a 81       	ldd	r24, Y+2	; 0x02
    2782:	88 30       	cpi	r24, 0x08	; 8
    2784:	08 f0       	brcs	.+2      	; 0x2788 <MDIO_VoidEnablePullUpResistor+0x20>
    2786:	6e c0       	rjmp	.+220    	; 0x2864 <MDIO_VoidEnablePullUpResistor+0xfc>
	{
		switch(Copy_u8Port)
    2788:	89 81       	ldd	r24, Y+1	; 0x01
    278a:	28 2f       	mov	r18, r24
    278c:	30 e0       	ldi	r19, 0x00	; 0
    278e:	3c 83       	std	Y+4, r19	; 0x04
    2790:	2b 83       	std	Y+3, r18	; 0x03
    2792:	8b 81       	ldd	r24, Y+3	; 0x03
    2794:	9c 81       	ldd	r25, Y+4	; 0x04
    2796:	81 30       	cpi	r24, 0x01	; 1
    2798:	91 05       	cpc	r25, r1
    279a:	49 f1       	breq	.+82     	; 0x27ee <MDIO_VoidEnablePullUpResistor+0x86>
    279c:	2b 81       	ldd	r18, Y+3	; 0x03
    279e:	3c 81       	ldd	r19, Y+4	; 0x04
    27a0:	22 30       	cpi	r18, 0x02	; 2
    27a2:	31 05       	cpc	r19, r1
    27a4:	2c f4       	brge	.+10     	; 0x27b0 <MDIO_VoidEnablePullUpResistor+0x48>
    27a6:	8b 81       	ldd	r24, Y+3	; 0x03
    27a8:	9c 81       	ldd	r25, Y+4	; 0x04
    27aa:	00 97       	sbiw	r24, 0x00	; 0
    27ac:	61 f0       	breq	.+24     	; 0x27c6 <MDIO_VoidEnablePullUpResistor+0x5e>
    27ae:	5a c0       	rjmp	.+180    	; 0x2864 <MDIO_VoidEnablePullUpResistor+0xfc>
    27b0:	2b 81       	ldd	r18, Y+3	; 0x03
    27b2:	3c 81       	ldd	r19, Y+4	; 0x04
    27b4:	22 30       	cpi	r18, 0x02	; 2
    27b6:	31 05       	cpc	r19, r1
    27b8:	71 f1       	breq	.+92     	; 0x2816 <MDIO_VoidEnablePullUpResistor+0xae>
    27ba:	8b 81       	ldd	r24, Y+3	; 0x03
    27bc:	9c 81       	ldd	r25, Y+4	; 0x04
    27be:	83 30       	cpi	r24, 0x03	; 3
    27c0:	91 05       	cpc	r25, r1
    27c2:	e9 f1       	breq	.+122    	; 0x283e <MDIO_VoidEnablePullUpResistor+0xd6>
    27c4:	4f c0       	rjmp	.+158    	; 0x2864 <MDIO_VoidEnablePullUpResistor+0xfc>
		{
			case DIO_PORTA:SET_BIT(PORTA_REG, Copy_u8Pin); break;
    27c6:	ab e3       	ldi	r26, 0x3B	; 59
    27c8:	b0 e0       	ldi	r27, 0x00	; 0
    27ca:	eb e3       	ldi	r30, 0x3B	; 59
    27cc:	f0 e0       	ldi	r31, 0x00	; 0
    27ce:	80 81       	ld	r24, Z
    27d0:	48 2f       	mov	r20, r24
    27d2:	8a 81       	ldd	r24, Y+2	; 0x02
    27d4:	28 2f       	mov	r18, r24
    27d6:	30 e0       	ldi	r19, 0x00	; 0
    27d8:	81 e0       	ldi	r24, 0x01	; 1
    27da:	90 e0       	ldi	r25, 0x00	; 0
    27dc:	02 2e       	mov	r0, r18
    27de:	02 c0       	rjmp	.+4      	; 0x27e4 <MDIO_VoidEnablePullUpResistor+0x7c>
    27e0:	88 0f       	add	r24, r24
    27e2:	99 1f       	adc	r25, r25
    27e4:	0a 94       	dec	r0
    27e6:	e2 f7       	brpl	.-8      	; 0x27e0 <MDIO_VoidEnablePullUpResistor+0x78>
    27e8:	84 2b       	or	r24, r20
    27ea:	8c 93       	st	X, r24
    27ec:	3b c0       	rjmp	.+118    	; 0x2864 <MDIO_VoidEnablePullUpResistor+0xfc>
			case DIO_PORTB:SET_BIT(PORTB_REG, Copy_u8Pin); break;
    27ee:	a8 e3       	ldi	r26, 0x38	; 56
    27f0:	b0 e0       	ldi	r27, 0x00	; 0
    27f2:	e8 e3       	ldi	r30, 0x38	; 56
    27f4:	f0 e0       	ldi	r31, 0x00	; 0
    27f6:	80 81       	ld	r24, Z
    27f8:	48 2f       	mov	r20, r24
    27fa:	8a 81       	ldd	r24, Y+2	; 0x02
    27fc:	28 2f       	mov	r18, r24
    27fe:	30 e0       	ldi	r19, 0x00	; 0
    2800:	81 e0       	ldi	r24, 0x01	; 1
    2802:	90 e0       	ldi	r25, 0x00	; 0
    2804:	02 2e       	mov	r0, r18
    2806:	02 c0       	rjmp	.+4      	; 0x280c <MDIO_VoidEnablePullUpResistor+0xa4>
    2808:	88 0f       	add	r24, r24
    280a:	99 1f       	adc	r25, r25
    280c:	0a 94       	dec	r0
    280e:	e2 f7       	brpl	.-8      	; 0x2808 <MDIO_VoidEnablePullUpResistor+0xa0>
    2810:	84 2b       	or	r24, r20
    2812:	8c 93       	st	X, r24
    2814:	27 c0       	rjmp	.+78     	; 0x2864 <MDIO_VoidEnablePullUpResistor+0xfc>
			case DIO_PORTC:SET_BIT(PORTC_REG, Copy_u8Pin); break;
    2816:	a5 e3       	ldi	r26, 0x35	; 53
    2818:	b0 e0       	ldi	r27, 0x00	; 0
    281a:	e5 e3       	ldi	r30, 0x35	; 53
    281c:	f0 e0       	ldi	r31, 0x00	; 0
    281e:	80 81       	ld	r24, Z
    2820:	48 2f       	mov	r20, r24
    2822:	8a 81       	ldd	r24, Y+2	; 0x02
    2824:	28 2f       	mov	r18, r24
    2826:	30 e0       	ldi	r19, 0x00	; 0
    2828:	81 e0       	ldi	r24, 0x01	; 1
    282a:	90 e0       	ldi	r25, 0x00	; 0
    282c:	02 2e       	mov	r0, r18
    282e:	02 c0       	rjmp	.+4      	; 0x2834 <MDIO_VoidEnablePullUpResistor+0xcc>
    2830:	88 0f       	add	r24, r24
    2832:	99 1f       	adc	r25, r25
    2834:	0a 94       	dec	r0
    2836:	e2 f7       	brpl	.-8      	; 0x2830 <MDIO_VoidEnablePullUpResistor+0xc8>
    2838:	84 2b       	or	r24, r20
    283a:	8c 93       	st	X, r24
    283c:	13 c0       	rjmp	.+38     	; 0x2864 <MDIO_VoidEnablePullUpResistor+0xfc>
			case DIO_PORTD:SET_BIT(PORTD_REG, Copy_u8Pin); break;
    283e:	a2 e3       	ldi	r26, 0x32	; 50
    2840:	b0 e0       	ldi	r27, 0x00	; 0
    2842:	e2 e3       	ldi	r30, 0x32	; 50
    2844:	f0 e0       	ldi	r31, 0x00	; 0
    2846:	80 81       	ld	r24, Z
    2848:	48 2f       	mov	r20, r24
    284a:	8a 81       	ldd	r24, Y+2	; 0x02
    284c:	28 2f       	mov	r18, r24
    284e:	30 e0       	ldi	r19, 0x00	; 0
    2850:	81 e0       	ldi	r24, 0x01	; 1
    2852:	90 e0       	ldi	r25, 0x00	; 0
    2854:	02 2e       	mov	r0, r18
    2856:	02 c0       	rjmp	.+4      	; 0x285c <MDIO_VoidEnablePullUpResistor+0xf4>
    2858:	88 0f       	add	r24, r24
    285a:	99 1f       	adc	r25, r25
    285c:	0a 94       	dec	r0
    285e:	e2 f7       	brpl	.-8      	; 0x2858 <MDIO_VoidEnablePullUpResistor+0xf0>
    2860:	84 2b       	or	r24, r20
    2862:	8c 93       	st	X, r24
	}
	else
	{
		/*Wrong PIN ID or POrt ID*/
	}
}
    2864:	0f 90       	pop	r0
    2866:	0f 90       	pop	r0
    2868:	0f 90       	pop	r0
    286a:	0f 90       	pop	r0
    286c:	cf 91       	pop	r28
    286e:	df 91       	pop	r29
    2870:	08 95       	ret

00002872 <xCoRoutineCreate>:
static void prvCheckDelayedList( void );

/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineCreate( crCOROUTINE_CODE pxCoRoutineCode, unsigned portBASE_TYPE uxPriority, unsigned portBASE_TYPE uxIndex )
{
    2872:	df 93       	push	r29
    2874:	cf 93       	push	r28
    2876:	cd b7       	in	r28, 0x3d	; 61
    2878:	de b7       	in	r29, 0x3e	; 62
    287a:	27 97       	sbiw	r28, 0x07	; 7
    287c:	0f b6       	in	r0, 0x3f	; 63
    287e:	f8 94       	cli
    2880:	de bf       	out	0x3e, r29	; 62
    2882:	0f be       	out	0x3f, r0	; 63
    2884:	cd bf       	out	0x3d, r28	; 61
    2886:	9d 83       	std	Y+5, r25	; 0x05
    2888:	8c 83       	std	Y+4, r24	; 0x04
    288a:	6e 83       	std	Y+6, r22	; 0x06
    288c:	4f 83       	std	Y+7, r20	; 0x07
signed portBASE_TYPE xReturn;
corCRCB *pxCoRoutine;

	/* Allocate the memory that will store the co-routine control block. */
	pxCoRoutine = ( corCRCB * ) pvPortMalloc( sizeof( corCRCB ) );
    288e:	8a e1       	ldi	r24, 0x1A	; 26
    2890:	90 e0       	ldi	r25, 0x00	; 0
    2892:	0e 94 11 17 	call	0x2e22	; 0x2e22 <pvPortMalloc>
    2896:	9a 83       	std	Y+2, r25	; 0x02
    2898:	89 83       	std	Y+1, r24	; 0x01
	if( pxCoRoutine )
    289a:	89 81       	ldd	r24, Y+1	; 0x01
    289c:	9a 81       	ldd	r25, Y+2	; 0x02
    289e:	00 97       	sbiw	r24, 0x00	; 0
    28a0:	09 f4       	brne	.+2      	; 0x28a4 <xCoRoutineCreate+0x32>
    28a2:	6f c0       	rjmp	.+222    	; 0x2982 <xCoRoutineCreate+0x110>
	{
		/* If pxCurrentCoRoutine is NULL then this is the first co-routine to
		be created and the co-routine data structures need initialising. */
		if( pxCurrentCoRoutine == NULL )
    28a4:	80 91 92 01 	lds	r24, 0x0192
    28a8:	90 91 93 01 	lds	r25, 0x0193
    28ac:	00 97       	sbiw	r24, 0x00	; 0
    28ae:	41 f4       	brne	.+16     	; 0x28c0 <xCoRoutineCreate+0x4e>
		{
			pxCurrentCoRoutine = pxCoRoutine;
    28b0:	89 81       	ldd	r24, Y+1	; 0x01
    28b2:	9a 81       	ldd	r25, Y+2	; 0x02
    28b4:	90 93 93 01 	sts	0x0193, r25
    28b8:	80 93 92 01 	sts	0x0192, r24
			prvInitialiseCoRoutineLists();
    28bc:	0e 94 a0 16 	call	0x2d40	; 0x2d40 <prvInitialiseCoRoutineLists>
		}

		/* Check the priority is within limits. */
		if( uxPriority >= configMAX_CO_ROUTINE_PRIORITIES )
    28c0:	8e 81       	ldd	r24, Y+6	; 0x06
    28c2:	82 30       	cpi	r24, 0x02	; 2
    28c4:	10 f0       	brcs	.+4      	; 0x28ca <xCoRoutineCreate+0x58>
		{
			uxPriority = configMAX_CO_ROUTINE_PRIORITIES - 1;
    28c6:	81 e0       	ldi	r24, 0x01	; 1
    28c8:	8e 83       	std	Y+6, r24	; 0x06
		}

		/* Fill out the co-routine control block from the function parameters. */
		pxCoRoutine->uxState = corINITIAL_STATE;
    28ca:	e9 81       	ldd	r30, Y+1	; 0x01
    28cc:	fa 81       	ldd	r31, Y+2	; 0x02
    28ce:	11 8e       	std	Z+25, r1	; 0x19
    28d0:	10 8e       	std	Z+24, r1	; 0x18
		pxCoRoutine->uxPriority = uxPriority;
    28d2:	e9 81       	ldd	r30, Y+1	; 0x01
    28d4:	fa 81       	ldd	r31, Y+2	; 0x02
    28d6:	8e 81       	ldd	r24, Y+6	; 0x06
    28d8:	86 8b       	std	Z+22, r24	; 0x16
		pxCoRoutine->uxIndex = uxIndex;
    28da:	e9 81       	ldd	r30, Y+1	; 0x01
    28dc:	fa 81       	ldd	r31, Y+2	; 0x02
    28de:	8f 81       	ldd	r24, Y+7	; 0x07
    28e0:	87 8b       	std	Z+23, r24	; 0x17
		pxCoRoutine->pxCoRoutineFunction = pxCoRoutineCode;
    28e2:	e9 81       	ldd	r30, Y+1	; 0x01
    28e4:	fa 81       	ldd	r31, Y+2	; 0x02
    28e6:	8c 81       	ldd	r24, Y+4	; 0x04
    28e8:	9d 81       	ldd	r25, Y+5	; 0x05
    28ea:	91 83       	std	Z+1, r25	; 0x01
    28ec:	80 83       	st	Z, r24

		/* Initialise all the other co-routine control block parameters. */
		vListInitialiseItem( &( pxCoRoutine->xGenericListItem ) );
    28ee:	89 81       	ldd	r24, Y+1	; 0x01
    28f0:	9a 81       	ldd	r25, Y+2	; 0x02
    28f2:	02 96       	adiw	r24, 0x02	; 2
    28f4:	0e 94 a7 17 	call	0x2f4e	; 0x2f4e <vListInitialiseItem>
		vListInitialiseItem( &( pxCoRoutine->xEventListItem ) );
    28f8:	89 81       	ldd	r24, Y+1	; 0x01
    28fa:	9a 81       	ldd	r25, Y+2	; 0x02
    28fc:	0c 96       	adiw	r24, 0x0c	; 12
    28fe:	0e 94 a7 17 	call	0x2f4e	; 0x2f4e <vListInitialiseItem>

		/* Set the co-routine control block as a link back from the xListItem.
		This is so we can get back to the containing CRCB from a generic item
		in a list. */
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xGenericListItem ), pxCoRoutine );
    2902:	e9 81       	ldd	r30, Y+1	; 0x01
    2904:	fa 81       	ldd	r31, Y+2	; 0x02
    2906:	89 81       	ldd	r24, Y+1	; 0x01
    2908:	9a 81       	ldd	r25, Y+2	; 0x02
    290a:	91 87       	std	Z+9, r25	; 0x09
    290c:	80 87       	std	Z+8, r24	; 0x08
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xEventListItem ), pxCoRoutine );
    290e:	e9 81       	ldd	r30, Y+1	; 0x01
    2910:	fa 81       	ldd	r31, Y+2	; 0x02
    2912:	89 81       	ldd	r24, Y+1	; 0x01
    2914:	9a 81       	ldd	r25, Y+2	; 0x02
    2916:	93 8b       	std	Z+19, r25	; 0x13
    2918:	82 8b       	std	Z+18, r24	; 0x12
	
		/* Event lists are always in priority order. */
		listSET_LIST_ITEM_VALUE( &( pxCoRoutine->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
    291a:	8e 81       	ldd	r24, Y+6	; 0x06
    291c:	28 2f       	mov	r18, r24
    291e:	30 e0       	ldi	r19, 0x00	; 0
    2920:	85 e0       	ldi	r24, 0x05	; 5
    2922:	90 e0       	ldi	r25, 0x00	; 0
    2924:	82 1b       	sub	r24, r18
    2926:	93 0b       	sbc	r25, r19
    2928:	e9 81       	ldd	r30, Y+1	; 0x01
    292a:	fa 81       	ldd	r31, Y+2	; 0x02
    292c:	95 87       	std	Z+13, r25	; 0x0d
    292e:	84 87       	std	Z+12, r24	; 0x0c
		
		/* Now the co-routine has been initialised it can be added to the ready
		list at the correct priority. */
		prvAddCoRoutineToReadyQueue( pxCoRoutine );
    2930:	e9 81       	ldd	r30, Y+1	; 0x01
    2932:	fa 81       	ldd	r31, Y+2	; 0x02
    2934:	96 89       	ldd	r25, Z+22	; 0x16
    2936:	80 91 94 01 	lds	r24, 0x0194
    293a:	89 17       	cp	r24, r25
    293c:	28 f4       	brcc	.+10     	; 0x2948 <xCoRoutineCreate+0xd6>
    293e:	e9 81       	ldd	r30, Y+1	; 0x01
    2940:	fa 81       	ldd	r31, Y+2	; 0x02
    2942:	86 89       	ldd	r24, Z+22	; 0x16
    2944:	80 93 94 01 	sts	0x0194, r24
    2948:	e9 81       	ldd	r30, Y+1	; 0x01
    294a:	fa 81       	ldd	r31, Y+2	; 0x02
    294c:	86 89       	ldd	r24, Z+22	; 0x16
    294e:	28 2f       	mov	r18, r24
    2950:	30 e0       	ldi	r19, 0x00	; 0
    2952:	c9 01       	movw	r24, r18
    2954:	88 0f       	add	r24, r24
    2956:	99 1f       	adc	r25, r25
    2958:	88 0f       	add	r24, r24
    295a:	99 1f       	adc	r25, r25
    295c:	88 0f       	add	r24, r24
    295e:	99 1f       	adc	r25, r25
    2960:	82 0f       	add	r24, r18
    2962:	93 1f       	adc	r25, r19
    2964:	ac 01       	movw	r20, r24
    2966:	45 56       	subi	r20, 0x65	; 101
    2968:	5e 4f       	sbci	r21, 0xFE	; 254
    296a:	89 81       	ldd	r24, Y+1	; 0x01
    296c:	9a 81       	ldd	r25, Y+2	; 0x02
    296e:	9c 01       	movw	r18, r24
    2970:	2e 5f       	subi	r18, 0xFE	; 254
    2972:	3f 4f       	sbci	r19, 0xFF	; 255
    2974:	ca 01       	movw	r24, r20
    2976:	b9 01       	movw	r22, r18
    2978:	0e 94 b7 17 	call	0x2f6e	; 0x2f6e <vListInsertEnd>

		xReturn = pdPASS;
    297c:	81 e0       	ldi	r24, 0x01	; 1
    297e:	8b 83       	std	Y+3, r24	; 0x03
    2980:	02 c0       	rjmp	.+4      	; 0x2986 <xCoRoutineCreate+0x114>
	}
	else
	{		
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    2982:	8f ef       	ldi	r24, 0xFF	; 255
    2984:	8b 83       	std	Y+3, r24	; 0x03
	}
	
	return xReturn;	
    2986:	8b 81       	ldd	r24, Y+3	; 0x03
}
    2988:	27 96       	adiw	r28, 0x07	; 7
    298a:	0f b6       	in	r0, 0x3f	; 63
    298c:	f8 94       	cli
    298e:	de bf       	out	0x3e, r29	; 62
    2990:	0f be       	out	0x3f, r0	; 63
    2992:	cd bf       	out	0x3d, r28	; 61
    2994:	cf 91       	pop	r28
    2996:	df 91       	pop	r29
    2998:	08 95       	ret

0000299a <vCoRoutineAddToDelayedList>:
/*-----------------------------------------------------------*/

void vCoRoutineAddToDelayedList( portTickType xTicksToDelay, xList *pxEventList )
{
    299a:	df 93       	push	r29
    299c:	cf 93       	push	r28
    299e:	00 d0       	rcall	.+0      	; 0x29a0 <vCoRoutineAddToDelayedList+0x6>
    29a0:	00 d0       	rcall	.+0      	; 0x29a2 <vCoRoutineAddToDelayedList+0x8>
    29a2:	00 d0       	rcall	.+0      	; 0x29a4 <vCoRoutineAddToDelayedList+0xa>
    29a4:	cd b7       	in	r28, 0x3d	; 61
    29a6:	de b7       	in	r29, 0x3e	; 62
    29a8:	9c 83       	std	Y+4, r25	; 0x04
    29aa:	8b 83       	std	Y+3, r24	; 0x03
    29ac:	7e 83       	std	Y+6, r23	; 0x06
    29ae:	6d 83       	std	Y+5, r22	; 0x05
portTickType xTimeToWake;

	/* Calculate the time to wake - this may overflow but this is
	not a problem. */
	xTimeToWake = xCoRoutineTickCount + xTicksToDelay;
    29b0:	20 91 95 01 	lds	r18, 0x0195
    29b4:	30 91 96 01 	lds	r19, 0x0196
    29b8:	8b 81       	ldd	r24, Y+3	; 0x03
    29ba:	9c 81       	ldd	r25, Y+4	; 0x04
    29bc:	82 0f       	add	r24, r18
    29be:	93 1f       	adc	r25, r19
    29c0:	9a 83       	std	Y+2, r25	; 0x02
    29c2:	89 83       	std	Y+1, r24	; 0x01

	/* We must remove ourselves from the ready list before adding
	ourselves to the blocked list as the same list item is used for
	both lists. */
	vListRemove( ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    29c4:	80 91 92 01 	lds	r24, 0x0192
    29c8:	90 91 93 01 	lds	r25, 0x0193
    29cc:	02 96       	adiw	r24, 0x02	; 2
    29ce:	0e 94 6f 18 	call	0x30de	; 0x30de <vListRemove>

	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentCoRoutine->xGenericListItem ), xTimeToWake );
    29d2:	e0 91 92 01 	lds	r30, 0x0192
    29d6:	f0 91 93 01 	lds	r31, 0x0193
    29da:	89 81       	ldd	r24, Y+1	; 0x01
    29dc:	9a 81       	ldd	r25, Y+2	; 0x02
    29de:	93 83       	std	Z+3, r25	; 0x03
    29e0:	82 83       	std	Z+2, r24	; 0x02

	if( xTimeToWake < xCoRoutineTickCount )
    29e2:	20 91 95 01 	lds	r18, 0x0195
    29e6:	30 91 96 01 	lds	r19, 0x0196
    29ea:	89 81       	ldd	r24, Y+1	; 0x01
    29ec:	9a 81       	ldd	r25, Y+2	; 0x02
    29ee:	82 17       	cp	r24, r18
    29f0:	93 07       	cpc	r25, r19
    29f2:	70 f4       	brcc	.+28     	; 0x2a10 <vCoRoutineAddToDelayedList+0x76>
	{
		/* Wake time has overflowed.  Place this item in the
		overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    29f4:	80 91 c1 01 	lds	r24, 0x01C1
    29f8:	90 91 c2 01 	lds	r25, 0x01C2
    29fc:	20 91 92 01 	lds	r18, 0x0192
    2a00:	30 91 93 01 	lds	r19, 0x0193
    2a04:	2e 5f       	subi	r18, 0xFE	; 254
    2a06:	3f 4f       	sbci	r19, 0xFF	; 255
    2a08:	b9 01       	movw	r22, r18
    2a0a:	0e 94 03 18 	call	0x3006	; 0x3006 <vListInsert>
    2a0e:	0d c0       	rjmp	.+26     	; 0x2a2a <vCoRoutineAddToDelayedList+0x90>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the
		current block list. */
		vListInsert( ( xList * ) pxDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    2a10:	80 91 bf 01 	lds	r24, 0x01BF
    2a14:	90 91 c0 01 	lds	r25, 0x01C0
    2a18:	20 91 92 01 	lds	r18, 0x0192
    2a1c:	30 91 93 01 	lds	r19, 0x0193
    2a20:	2e 5f       	subi	r18, 0xFE	; 254
    2a22:	3f 4f       	sbci	r19, 0xFF	; 255
    2a24:	b9 01       	movw	r22, r18
    2a26:	0e 94 03 18 	call	0x3006	; 0x3006 <vListInsert>
	}

	if( pxEventList )
    2a2a:	8d 81       	ldd	r24, Y+5	; 0x05
    2a2c:	9e 81       	ldd	r25, Y+6	; 0x06
    2a2e:	00 97       	sbiw	r24, 0x00	; 0
    2a30:	61 f0       	breq	.+24     	; 0x2a4a <vCoRoutineAddToDelayedList+0xb0>
	{
		/* Also add the co-routine to an event list.  If this is done then the
		function must be called with interrupts disabled. */
		vListInsert( pxEventList, &( pxCurrentCoRoutine->xEventListItem ) );
    2a32:	80 91 92 01 	lds	r24, 0x0192
    2a36:	90 91 93 01 	lds	r25, 0x0193
    2a3a:	9c 01       	movw	r18, r24
    2a3c:	24 5f       	subi	r18, 0xF4	; 244
    2a3e:	3f 4f       	sbci	r19, 0xFF	; 255
    2a40:	8d 81       	ldd	r24, Y+5	; 0x05
    2a42:	9e 81       	ldd	r25, Y+6	; 0x06
    2a44:	b9 01       	movw	r22, r18
    2a46:	0e 94 03 18 	call	0x3006	; 0x3006 <vListInsert>
	}
}
    2a4a:	26 96       	adiw	r28, 0x06	; 6
    2a4c:	0f b6       	in	r0, 0x3f	; 63
    2a4e:	f8 94       	cli
    2a50:	de bf       	out	0x3e, r29	; 62
    2a52:	0f be       	out	0x3f, r0	; 63
    2a54:	cd bf       	out	0x3d, r28	; 61
    2a56:	cf 91       	pop	r28
    2a58:	df 91       	pop	r29
    2a5a:	08 95       	ret

00002a5c <prvCheckPendingReadyList>:
/*-----------------------------------------------------------*/

static void prvCheckPendingReadyList( void )
{
    2a5c:	df 93       	push	r29
    2a5e:	cf 93       	push	r28
    2a60:	00 d0       	rcall	.+0      	; 0x2a62 <prvCheckPendingReadyList+0x6>
    2a62:	cd b7       	in	r28, 0x3d	; 61
    2a64:	de b7       	in	r29, 0x3e	; 62
    2a66:	3a c0       	rjmp	.+116    	; 0x2adc <prvCheckPendingReadyList+0x80>
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
	{
		corCRCB *pxUnblockedCRCB;

		/* The pending ready list can be accessed by an ISR. */
		portDISABLE_INTERRUPTS();
    2a68:	f8 94       	cli
		{	
			pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( (&xPendingReadyCoRoutineList) );			
    2a6a:	e0 91 c8 01 	lds	r30, 0x01C8
    2a6e:	f0 91 c9 01 	lds	r31, 0x01C9
    2a72:	86 81       	ldd	r24, Z+6	; 0x06
    2a74:	97 81       	ldd	r25, Z+7	; 0x07
    2a76:	9a 83       	std	Y+2, r25	; 0x02
    2a78:	89 83       	std	Y+1, r24	; 0x01
			vListRemove( &( pxUnblockedCRCB->xEventListItem ) );
    2a7a:	89 81       	ldd	r24, Y+1	; 0x01
    2a7c:	9a 81       	ldd	r25, Y+2	; 0x02
    2a7e:	0c 96       	adiw	r24, 0x0c	; 12
    2a80:	0e 94 6f 18 	call	0x30de	; 0x30de <vListRemove>
		}
		portENABLE_INTERRUPTS();
    2a84:	78 94       	sei

		vListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
    2a86:	89 81       	ldd	r24, Y+1	; 0x01
    2a88:	9a 81       	ldd	r25, Y+2	; 0x02
    2a8a:	02 96       	adiw	r24, 0x02	; 2
    2a8c:	0e 94 6f 18 	call	0x30de	; 0x30de <vListRemove>
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );	
    2a90:	e9 81       	ldd	r30, Y+1	; 0x01
    2a92:	fa 81       	ldd	r31, Y+2	; 0x02
    2a94:	96 89       	ldd	r25, Z+22	; 0x16
    2a96:	80 91 94 01 	lds	r24, 0x0194
    2a9a:	89 17       	cp	r24, r25
    2a9c:	28 f4       	brcc	.+10     	; 0x2aa8 <prvCheckPendingReadyList+0x4c>
    2a9e:	e9 81       	ldd	r30, Y+1	; 0x01
    2aa0:	fa 81       	ldd	r31, Y+2	; 0x02
    2aa2:	86 89       	ldd	r24, Z+22	; 0x16
    2aa4:	80 93 94 01 	sts	0x0194, r24
    2aa8:	e9 81       	ldd	r30, Y+1	; 0x01
    2aaa:	fa 81       	ldd	r31, Y+2	; 0x02
    2aac:	86 89       	ldd	r24, Z+22	; 0x16
    2aae:	28 2f       	mov	r18, r24
    2ab0:	30 e0       	ldi	r19, 0x00	; 0
    2ab2:	c9 01       	movw	r24, r18
    2ab4:	88 0f       	add	r24, r24
    2ab6:	99 1f       	adc	r25, r25
    2ab8:	88 0f       	add	r24, r24
    2aba:	99 1f       	adc	r25, r25
    2abc:	88 0f       	add	r24, r24
    2abe:	99 1f       	adc	r25, r25
    2ac0:	82 0f       	add	r24, r18
    2ac2:	93 1f       	adc	r25, r19
    2ac4:	ac 01       	movw	r20, r24
    2ac6:	45 56       	subi	r20, 0x65	; 101
    2ac8:	5e 4f       	sbci	r21, 0xFE	; 254
    2aca:	89 81       	ldd	r24, Y+1	; 0x01
    2acc:	9a 81       	ldd	r25, Y+2	; 0x02
    2ace:	9c 01       	movw	r18, r24
    2ad0:	2e 5f       	subi	r18, 0xFE	; 254
    2ad2:	3f 4f       	sbci	r19, 0xFF	; 255
    2ad4:	ca 01       	movw	r24, r20
    2ad6:	b9 01       	movw	r22, r18
    2ad8:	0e 94 b7 17 	call	0x2f6e	; 0x2f6e <vListInsertEnd>
static void prvCheckPendingReadyList( void )
{
	/* Are there any co-routines waiting to get moved to the ready list?  These
	are co-routines that have been readied by an ISR.  The ISR cannot access
	the	ready lists itself. */
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
    2adc:	80 91 c3 01 	lds	r24, 0x01C3
    2ae0:	88 23       	and	r24, r24
    2ae2:	09 f0       	breq	.+2      	; 0x2ae6 <prvCheckPendingReadyList+0x8a>
    2ae4:	c1 cf       	rjmp	.-126    	; 0x2a68 <prvCheckPendingReadyList+0xc>
		portENABLE_INTERRUPTS();

		vListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );	
	}
}
    2ae6:	0f 90       	pop	r0
    2ae8:	0f 90       	pop	r0
    2aea:	cf 91       	pop	r28
    2aec:	df 91       	pop	r29
    2aee:	08 95       	ret

00002af0 <prvCheckDelayedList>:
/*-----------------------------------------------------------*/

static void prvCheckDelayedList( void )
{
    2af0:	df 93       	push	r29
    2af2:	cf 93       	push	r28
    2af4:	00 d0       	rcall	.+0      	; 0x2af6 <prvCheckDelayedList+0x6>
    2af6:	00 d0       	rcall	.+0      	; 0x2af8 <prvCheckDelayedList+0x8>
    2af8:	cd b7       	in	r28, 0x3d	; 61
    2afa:	de b7       	in	r29, 0x3e	; 62
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
    2afc:	0e 94 ce 23 	call	0x479c	; 0x479c <xTaskGetTickCount>
    2b00:	20 91 97 01 	lds	r18, 0x0197
    2b04:	30 91 98 01 	lds	r19, 0x0198
    2b08:	82 1b       	sub	r24, r18
    2b0a:	93 0b       	sbc	r25, r19
    2b0c:	90 93 9a 01 	sts	0x019A, r25
    2b10:	80 93 99 01 	sts	0x0199, r24
    2b14:	85 c0       	rjmp	.+266    	; 0x2c20 <prvCheckDelayedList+0x130>
	while( xPassedTicks )
	{
		xCoRoutineTickCount++;
    2b16:	80 91 95 01 	lds	r24, 0x0195
    2b1a:	90 91 96 01 	lds	r25, 0x0196
    2b1e:	01 96       	adiw	r24, 0x01	; 1
    2b20:	90 93 96 01 	sts	0x0196, r25
    2b24:	80 93 95 01 	sts	0x0195, r24
		xPassedTicks--;
    2b28:	80 91 99 01 	lds	r24, 0x0199
    2b2c:	90 91 9a 01 	lds	r25, 0x019A
    2b30:	01 97       	sbiw	r24, 0x01	; 1
    2b32:	90 93 9a 01 	sts	0x019A, r25
    2b36:	80 93 99 01 	sts	0x0199, r24

		/* If the tick count has overflowed we need to swap the ready lists. */
		if( xCoRoutineTickCount == 0 )
    2b3a:	80 91 95 01 	lds	r24, 0x0195
    2b3e:	90 91 96 01 	lds	r25, 0x0196
    2b42:	00 97       	sbiw	r24, 0x00	; 0
    2b44:	09 f0       	breq	.+2      	; 0x2b48 <prvCheckDelayedList+0x58>
    2b46:	64 c0       	rjmp	.+200    	; 0x2c10 <prvCheckDelayedList+0x120>
		{
			xList * pxTemp;

			/* Tick count has overflowed so we need to swap the delay lists.  If there are
			any items in pxDelayedCoRoutineList here then there is an error! */
			pxTemp = pxDelayedCoRoutineList;
    2b48:	80 91 bf 01 	lds	r24, 0x01BF
    2b4c:	90 91 c0 01 	lds	r25, 0x01C0
    2b50:	9a 83       	std	Y+2, r25	; 0x02
    2b52:	89 83       	std	Y+1, r24	; 0x01
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
    2b54:	80 91 c1 01 	lds	r24, 0x01C1
    2b58:	90 91 c2 01 	lds	r25, 0x01C2
    2b5c:	90 93 c0 01 	sts	0x01C0, r25
    2b60:	80 93 bf 01 	sts	0x01BF, r24
			pxOverflowDelayedCoRoutineList = pxTemp;
    2b64:	89 81       	ldd	r24, Y+1	; 0x01
    2b66:	9a 81       	ldd	r25, Y+2	; 0x02
    2b68:	90 93 c2 01 	sts	0x01C2, r25
    2b6c:	80 93 c1 01 	sts	0x01C1, r24
    2b70:	4f c0       	rjmp	.+158    	; 0x2c10 <prvCheckDelayedList+0x120>
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
		{
			pxCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList );
    2b72:	e0 91 bf 01 	lds	r30, 0x01BF
    2b76:	f0 91 c0 01 	lds	r31, 0x01C0
    2b7a:	05 80       	ldd	r0, Z+5	; 0x05
    2b7c:	f6 81       	ldd	r31, Z+6	; 0x06
    2b7e:	e0 2d       	mov	r30, r0
    2b80:	86 81       	ldd	r24, Z+6	; 0x06
    2b82:	97 81       	ldd	r25, Z+7	; 0x07
    2b84:	9c 83       	std	Y+4, r25	; 0x04
    2b86:	8b 83       	std	Y+3, r24	; 0x03

			if( xCoRoutineTickCount < listGET_LIST_ITEM_VALUE( &( pxCRCB->xGenericListItem ) ) )				
    2b88:	eb 81       	ldd	r30, Y+3	; 0x03
    2b8a:	fc 81       	ldd	r31, Y+4	; 0x04
    2b8c:	22 81       	ldd	r18, Z+2	; 0x02
    2b8e:	33 81       	ldd	r19, Z+3	; 0x03
    2b90:	80 91 95 01 	lds	r24, 0x0195
    2b94:	90 91 96 01 	lds	r25, 0x0196
    2b98:	82 17       	cp	r24, r18
    2b9a:	93 07       	cpc	r25, r19
    2b9c:	08 f4       	brcc	.+2      	; 0x2ba0 <prvCheckDelayedList+0xb0>
    2b9e:	40 c0       	rjmp	.+128    	; 0x2c20 <prvCheckDelayedList+0x130>
			{			
				/* Timeout not yet expired. */																			
				break;																				
			}																						

			portDISABLE_INTERRUPTS();
    2ba0:	f8 94       	cli
				/* The event could have occurred just before this critical
				section.  If this is the case then the generic list item will
				have been moved to the pending ready list and the following
				line is still valid.  Also the pvContainer parameter will have
				been set to NULL so the following lines are also valid. */
				vListRemove( &( pxCRCB->xGenericListItem ) );											
    2ba2:	8b 81       	ldd	r24, Y+3	; 0x03
    2ba4:	9c 81       	ldd	r25, Y+4	; 0x04
    2ba6:	02 96       	adiw	r24, 0x02	; 2
    2ba8:	0e 94 6f 18 	call	0x30de	; 0x30de <vListRemove>

				/* Is the co-routine waiting on an event also? */												
				if( pxCRCB->xEventListItem.pvContainer )													
    2bac:	eb 81       	ldd	r30, Y+3	; 0x03
    2bae:	fc 81       	ldd	r31, Y+4	; 0x04
    2bb0:	84 89       	ldd	r24, Z+20	; 0x14
    2bb2:	95 89       	ldd	r25, Z+21	; 0x15
    2bb4:	00 97       	sbiw	r24, 0x00	; 0
    2bb6:	29 f0       	breq	.+10     	; 0x2bc2 <prvCheckDelayedList+0xd2>
				{															
					vListRemove( &( pxCRCB->xEventListItem ) );											
    2bb8:	8b 81       	ldd	r24, Y+3	; 0x03
    2bba:	9c 81       	ldd	r25, Y+4	; 0x04
    2bbc:	0c 96       	adiw	r24, 0x0c	; 12
    2bbe:	0e 94 6f 18 	call	0x30de	; 0x30de <vListRemove>
				}
			}
			portENABLE_INTERRUPTS();
    2bc2:	78 94       	sei

			prvAddCoRoutineToReadyQueue( pxCRCB );													
    2bc4:	eb 81       	ldd	r30, Y+3	; 0x03
    2bc6:	fc 81       	ldd	r31, Y+4	; 0x04
    2bc8:	96 89       	ldd	r25, Z+22	; 0x16
    2bca:	80 91 94 01 	lds	r24, 0x0194
    2bce:	89 17       	cp	r24, r25
    2bd0:	28 f4       	brcc	.+10     	; 0x2bdc <prvCheckDelayedList+0xec>
    2bd2:	eb 81       	ldd	r30, Y+3	; 0x03
    2bd4:	fc 81       	ldd	r31, Y+4	; 0x04
    2bd6:	86 89       	ldd	r24, Z+22	; 0x16
    2bd8:	80 93 94 01 	sts	0x0194, r24
    2bdc:	eb 81       	ldd	r30, Y+3	; 0x03
    2bde:	fc 81       	ldd	r31, Y+4	; 0x04
    2be0:	86 89       	ldd	r24, Z+22	; 0x16
    2be2:	28 2f       	mov	r18, r24
    2be4:	30 e0       	ldi	r19, 0x00	; 0
    2be6:	c9 01       	movw	r24, r18
    2be8:	88 0f       	add	r24, r24
    2bea:	99 1f       	adc	r25, r25
    2bec:	88 0f       	add	r24, r24
    2bee:	99 1f       	adc	r25, r25
    2bf0:	88 0f       	add	r24, r24
    2bf2:	99 1f       	adc	r25, r25
    2bf4:	82 0f       	add	r24, r18
    2bf6:	93 1f       	adc	r25, r19
    2bf8:	ac 01       	movw	r20, r24
    2bfa:	45 56       	subi	r20, 0x65	; 101
    2bfc:	5e 4f       	sbci	r21, 0xFE	; 254
    2bfe:	8b 81       	ldd	r24, Y+3	; 0x03
    2c00:	9c 81       	ldd	r25, Y+4	; 0x04
    2c02:	9c 01       	movw	r18, r24
    2c04:	2e 5f       	subi	r18, 0xFE	; 254
    2c06:	3f 4f       	sbci	r19, 0xFF	; 255
    2c08:	ca 01       	movw	r24, r20
    2c0a:	b9 01       	movw	r22, r18
    2c0c:	0e 94 b7 17 	call	0x2f6e	; 0x2f6e <vListInsertEnd>
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
			pxOverflowDelayedCoRoutineList = pxTemp;
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
    2c10:	e0 91 bf 01 	lds	r30, 0x01BF
    2c14:	f0 91 c0 01 	lds	r31, 0x01C0
    2c18:	80 81       	ld	r24, Z
    2c1a:	88 23       	and	r24, r24
    2c1c:	09 f0       	breq	.+2      	; 0x2c20 <prvCheckDelayedList+0x130>
    2c1e:	a9 cf       	rjmp	.-174    	; 0x2b72 <prvCheckDelayedList+0x82>
static void prvCheckDelayedList( void )
{
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
	while( xPassedTicks )
    2c20:	80 91 99 01 	lds	r24, 0x0199
    2c24:	90 91 9a 01 	lds	r25, 0x019A
    2c28:	00 97       	sbiw	r24, 0x00	; 0
    2c2a:	09 f0       	breq	.+2      	; 0x2c2e <prvCheckDelayedList+0x13e>
    2c2c:	74 cf       	rjmp	.-280    	; 0x2b16 <prvCheckDelayedList+0x26>

			prvAddCoRoutineToReadyQueue( pxCRCB );													
		}																									
	}

	xLastTickCount = xCoRoutineTickCount;
    2c2e:	80 91 95 01 	lds	r24, 0x0195
    2c32:	90 91 96 01 	lds	r25, 0x0196
    2c36:	90 93 98 01 	sts	0x0198, r25
    2c3a:	80 93 97 01 	sts	0x0197, r24
}
    2c3e:	0f 90       	pop	r0
    2c40:	0f 90       	pop	r0
    2c42:	0f 90       	pop	r0
    2c44:	0f 90       	pop	r0
    2c46:	cf 91       	pop	r28
    2c48:	df 91       	pop	r29
    2c4a:	08 95       	ret

00002c4c <vCoRoutineSchedule>:
/*-----------------------------------------------------------*/

void vCoRoutineSchedule( void )
{
    2c4c:	df 93       	push	r29
    2c4e:	cf 93       	push	r28
    2c50:	00 d0       	rcall	.+0      	; 0x2c52 <vCoRoutineSchedule+0x6>
    2c52:	cd b7       	in	r28, 0x3d	; 61
    2c54:	de b7       	in	r29, 0x3e	; 62
	/* See if any co-routines readied by events need moving to the ready lists. */
	prvCheckPendingReadyList();
    2c56:	0e 94 2e 15 	call	0x2a5c	; 0x2a5c <prvCheckPendingReadyList>

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();
    2c5a:	0e 94 78 15 	call	0x2af0	; 0x2af0 <prvCheckDelayedList>
    2c5e:	0a c0       	rjmp	.+20     	; 0x2c74 <vCoRoutineSchedule+0x28>

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
	{
		if( uxTopCoRoutineReadyPriority == 0 )
    2c60:	80 91 94 01 	lds	r24, 0x0194
    2c64:	88 23       	and	r24, r24
    2c66:	09 f4       	brne	.+2      	; 0x2c6a <vCoRoutineSchedule+0x1e>
    2c68:	66 c0       	rjmp	.+204    	; 0x2d36 <vCoRoutineSchedule+0xea>
		{
			/* No more co-routines to check. */
			return;
		}
		--uxTopCoRoutineReadyPriority;
    2c6a:	80 91 94 01 	lds	r24, 0x0194
    2c6e:	81 50       	subi	r24, 0x01	; 1
    2c70:	80 93 94 01 	sts	0x0194, r24

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
    2c74:	80 91 94 01 	lds	r24, 0x0194
    2c78:	28 2f       	mov	r18, r24
    2c7a:	30 e0       	ldi	r19, 0x00	; 0
    2c7c:	c9 01       	movw	r24, r18
    2c7e:	88 0f       	add	r24, r24
    2c80:	99 1f       	adc	r25, r25
    2c82:	88 0f       	add	r24, r24
    2c84:	99 1f       	adc	r25, r25
    2c86:	88 0f       	add	r24, r24
    2c88:	99 1f       	adc	r25, r25
    2c8a:	82 0f       	add	r24, r18
    2c8c:	93 1f       	adc	r25, r19
    2c8e:	fc 01       	movw	r30, r24
    2c90:	e5 56       	subi	r30, 0x65	; 101
    2c92:	fe 4f       	sbci	r31, 0xFE	; 254
    2c94:	80 81       	ld	r24, Z
    2c96:	88 23       	and	r24, r24
    2c98:	19 f3       	breq	.-58     	; 0x2c60 <vCoRoutineSchedule+0x14>
		--uxTopCoRoutineReadyPriority;
	}

	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the co-routines
	 of the	same priority get an equal share of the processor time. */
	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentCoRoutine, &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) );
    2c9a:	80 91 94 01 	lds	r24, 0x0194
    2c9e:	28 2f       	mov	r18, r24
    2ca0:	30 e0       	ldi	r19, 0x00	; 0
    2ca2:	c9 01       	movw	r24, r18
    2ca4:	88 0f       	add	r24, r24
    2ca6:	99 1f       	adc	r25, r25
    2ca8:	88 0f       	add	r24, r24
    2caa:	99 1f       	adc	r25, r25
    2cac:	88 0f       	add	r24, r24
    2cae:	99 1f       	adc	r25, r25
    2cb0:	82 0f       	add	r24, r18
    2cb2:	93 1f       	adc	r25, r19
    2cb4:	85 56       	subi	r24, 0x65	; 101
    2cb6:	9e 4f       	sbci	r25, 0xFE	; 254
    2cb8:	9a 83       	std	Y+2, r25	; 0x02
    2cba:	89 83       	std	Y+1, r24	; 0x01
    2cbc:	e9 81       	ldd	r30, Y+1	; 0x01
    2cbe:	fa 81       	ldd	r31, Y+2	; 0x02
    2cc0:	01 80       	ldd	r0, Z+1	; 0x01
    2cc2:	f2 81       	ldd	r31, Z+2	; 0x02
    2cc4:	e0 2d       	mov	r30, r0
    2cc6:	82 81       	ldd	r24, Z+2	; 0x02
    2cc8:	93 81       	ldd	r25, Z+3	; 0x03
    2cca:	e9 81       	ldd	r30, Y+1	; 0x01
    2ccc:	fa 81       	ldd	r31, Y+2	; 0x02
    2cce:	92 83       	std	Z+2, r25	; 0x02
    2cd0:	81 83       	std	Z+1, r24	; 0x01
    2cd2:	e9 81       	ldd	r30, Y+1	; 0x01
    2cd4:	fa 81       	ldd	r31, Y+2	; 0x02
    2cd6:	21 81       	ldd	r18, Z+1	; 0x01
    2cd8:	32 81       	ldd	r19, Z+2	; 0x02
    2cda:	89 81       	ldd	r24, Y+1	; 0x01
    2cdc:	9a 81       	ldd	r25, Y+2	; 0x02
    2cde:	03 96       	adiw	r24, 0x03	; 3
    2ce0:	28 17       	cp	r18, r24
    2ce2:	39 07       	cpc	r19, r25
    2ce4:	59 f4       	brne	.+22     	; 0x2cfc <vCoRoutineSchedule+0xb0>
    2ce6:	e9 81       	ldd	r30, Y+1	; 0x01
    2ce8:	fa 81       	ldd	r31, Y+2	; 0x02
    2cea:	01 80       	ldd	r0, Z+1	; 0x01
    2cec:	f2 81       	ldd	r31, Z+2	; 0x02
    2cee:	e0 2d       	mov	r30, r0
    2cf0:	82 81       	ldd	r24, Z+2	; 0x02
    2cf2:	93 81       	ldd	r25, Z+3	; 0x03
    2cf4:	e9 81       	ldd	r30, Y+1	; 0x01
    2cf6:	fa 81       	ldd	r31, Y+2	; 0x02
    2cf8:	92 83       	std	Z+2, r25	; 0x02
    2cfa:	81 83       	std	Z+1, r24	; 0x01
    2cfc:	e9 81       	ldd	r30, Y+1	; 0x01
    2cfe:	fa 81       	ldd	r31, Y+2	; 0x02
    2d00:	01 80       	ldd	r0, Z+1	; 0x01
    2d02:	f2 81       	ldd	r31, Z+2	; 0x02
    2d04:	e0 2d       	mov	r30, r0
    2d06:	86 81       	ldd	r24, Z+6	; 0x06
    2d08:	97 81       	ldd	r25, Z+7	; 0x07
    2d0a:	90 93 93 01 	sts	0x0193, r25
    2d0e:	80 93 92 01 	sts	0x0192, r24

	/* Call the co-routine. */
	( pxCurrentCoRoutine->pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine->uxIndex );
    2d12:	e0 91 92 01 	lds	r30, 0x0192
    2d16:	f0 91 93 01 	lds	r31, 0x0193
    2d1a:	40 81       	ld	r20, Z
    2d1c:	51 81       	ldd	r21, Z+1	; 0x01
    2d1e:	80 91 92 01 	lds	r24, 0x0192
    2d22:	90 91 93 01 	lds	r25, 0x0193
    2d26:	e0 91 92 01 	lds	r30, 0x0192
    2d2a:	f0 91 93 01 	lds	r31, 0x0193
    2d2e:	27 89       	ldd	r18, Z+23	; 0x17
    2d30:	62 2f       	mov	r22, r18
    2d32:	fa 01       	movw	r30, r20
    2d34:	09 95       	icall

	return;
}
    2d36:	0f 90       	pop	r0
    2d38:	0f 90       	pop	r0
    2d3a:	cf 91       	pop	r28
    2d3c:	df 91       	pop	r29
    2d3e:	08 95       	ret

00002d40 <prvInitialiseCoRoutineLists>:
/*-----------------------------------------------------------*/

static void prvInitialiseCoRoutineLists( void )
{
    2d40:	df 93       	push	r29
    2d42:	cf 93       	push	r28
    2d44:	0f 92       	push	r0
    2d46:	cd b7       	in	r28, 0x3d	; 61
    2d48:	de b7       	in	r29, 0x3e	; 62
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
    2d4a:	19 82       	std	Y+1, r1	; 0x01
    2d4c:	13 c0       	rjmp	.+38     	; 0x2d74 <prvInitialiseCoRoutineLists+0x34>
	{
		vListInitialise( ( xList * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
    2d4e:	89 81       	ldd	r24, Y+1	; 0x01
    2d50:	28 2f       	mov	r18, r24
    2d52:	30 e0       	ldi	r19, 0x00	; 0
    2d54:	c9 01       	movw	r24, r18
    2d56:	88 0f       	add	r24, r24
    2d58:	99 1f       	adc	r25, r25
    2d5a:	88 0f       	add	r24, r24
    2d5c:	99 1f       	adc	r25, r25
    2d5e:	88 0f       	add	r24, r24
    2d60:	99 1f       	adc	r25, r25
    2d62:	82 0f       	add	r24, r18
    2d64:	93 1f       	adc	r25, r19
    2d66:	85 56       	subi	r24, 0x65	; 101
    2d68:	9e 4f       	sbci	r25, 0xFE	; 254
    2d6a:	0e 94 7d 17 	call	0x2efa	; 0x2efa <vListInitialise>

static void prvInitialiseCoRoutineLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
    2d6e:	89 81       	ldd	r24, Y+1	; 0x01
    2d70:	8f 5f       	subi	r24, 0xFF	; 255
    2d72:	89 83       	std	Y+1, r24	; 0x01
    2d74:	89 81       	ldd	r24, Y+1	; 0x01
    2d76:	82 30       	cpi	r24, 0x02	; 2
    2d78:	50 f3       	brcs	.-44     	; 0x2d4e <prvInitialiseCoRoutineLists+0xe>
	{
		vListInitialise( ( xList * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedCoRoutineList1 );
    2d7a:	8d ea       	ldi	r24, 0xAD	; 173
    2d7c:	91 e0       	ldi	r25, 0x01	; 1
    2d7e:	0e 94 7d 17 	call	0x2efa	; 0x2efa <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedCoRoutineList2 );
    2d82:	86 eb       	ldi	r24, 0xB6	; 182
    2d84:	91 e0       	ldi	r25, 0x01	; 1
    2d86:	0e 94 7d 17 	call	0x2efa	; 0x2efa <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyCoRoutineList );
    2d8a:	83 ec       	ldi	r24, 0xC3	; 195
    2d8c:	91 e0       	ldi	r25, 0x01	; 1
    2d8e:	0e 94 7d 17 	call	0x2efa	; 0x2efa <vListInitialise>

	/* Start with pxDelayedCoRoutineList using list1 and the
	pxOverflowDelayedCoRoutineList using list2. */
	pxDelayedCoRoutineList = &xDelayedCoRoutineList1;
    2d92:	8d ea       	ldi	r24, 0xAD	; 173
    2d94:	91 e0       	ldi	r25, 0x01	; 1
    2d96:	90 93 c0 01 	sts	0x01C0, r25
    2d9a:	80 93 bf 01 	sts	0x01BF, r24
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
    2d9e:	86 eb       	ldi	r24, 0xB6	; 182
    2da0:	91 e0       	ldi	r25, 0x01	; 1
    2da2:	90 93 c2 01 	sts	0x01C2, r25
    2da6:	80 93 c1 01 	sts	0x01C1, r24
}
    2daa:	0f 90       	pop	r0
    2dac:	cf 91       	pop	r28
    2dae:	df 91       	pop	r29
    2db0:	08 95       	ret

00002db2 <xCoRoutineRemoveFromEventList>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineRemoveFromEventList( const xList *pxEventList )
{
    2db2:	df 93       	push	r29
    2db4:	cf 93       	push	r28
    2db6:	00 d0       	rcall	.+0      	; 0x2db8 <xCoRoutineRemoveFromEventList+0x6>
    2db8:	00 d0       	rcall	.+0      	; 0x2dba <xCoRoutineRemoveFromEventList+0x8>
    2dba:	0f 92       	push	r0
    2dbc:	cd b7       	in	r28, 0x3d	; 61
    2dbe:	de b7       	in	r29, 0x3e	; 62
    2dc0:	9d 83       	std	Y+5, r25	; 0x05
    2dc2:	8c 83       	std	Y+4, r24	; 0x04
signed portBASE_TYPE xReturn;

	/* This function is called from within an interrupt.  It can only access
	event lists and the pending ready list.  This function assumes that a
	check has already been made to ensure pxEventList is not empty. */
	pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    2dc4:	ec 81       	ldd	r30, Y+4	; 0x04
    2dc6:	fd 81       	ldd	r31, Y+5	; 0x05
    2dc8:	05 80       	ldd	r0, Z+5	; 0x05
    2dca:	f6 81       	ldd	r31, Z+6	; 0x06
    2dcc:	e0 2d       	mov	r30, r0
    2dce:	86 81       	ldd	r24, Z+6	; 0x06
    2dd0:	97 81       	ldd	r25, Z+7	; 0x07
    2dd2:	9b 83       	std	Y+3, r25	; 0x03
    2dd4:	8a 83       	std	Y+2, r24	; 0x02
	vListRemove( &( pxUnblockedCRCB->xEventListItem ) );
    2dd6:	8a 81       	ldd	r24, Y+2	; 0x02
    2dd8:	9b 81       	ldd	r25, Y+3	; 0x03
    2dda:	0c 96       	adiw	r24, 0x0c	; 12
    2ddc:	0e 94 6f 18 	call	0x30de	; 0x30de <vListRemove>
	vListInsertEnd( ( xList * ) &( xPendingReadyCoRoutineList ), &( pxUnblockedCRCB->xEventListItem ) );
    2de0:	8a 81       	ldd	r24, Y+2	; 0x02
    2de2:	9b 81       	ldd	r25, Y+3	; 0x03
    2de4:	9c 01       	movw	r18, r24
    2de6:	24 5f       	subi	r18, 0xF4	; 244
    2de8:	3f 4f       	sbci	r19, 0xFF	; 255
    2dea:	83 ec       	ldi	r24, 0xC3	; 195
    2dec:	91 e0       	ldi	r25, 0x01	; 1
    2dee:	b9 01       	movw	r22, r18
    2df0:	0e 94 b7 17 	call	0x2f6e	; 0x2f6e <vListInsertEnd>

	if( pxUnblockedCRCB->uxPriority >= pxCurrentCoRoutine->uxPriority )
    2df4:	ea 81       	ldd	r30, Y+2	; 0x02
    2df6:	fb 81       	ldd	r31, Y+3	; 0x03
    2df8:	96 89       	ldd	r25, Z+22	; 0x16
    2dfa:	e0 91 92 01 	lds	r30, 0x0192
    2dfe:	f0 91 93 01 	lds	r31, 0x0193
    2e02:	86 89       	ldd	r24, Z+22	; 0x16
    2e04:	98 17       	cp	r25, r24
    2e06:	18 f0       	brcs	.+6      	; 0x2e0e <xCoRoutineRemoveFromEventList+0x5c>
	{
		xReturn = pdTRUE;
    2e08:	81 e0       	ldi	r24, 0x01	; 1
    2e0a:	89 83       	std	Y+1, r24	; 0x01
    2e0c:	01 c0       	rjmp	.+2      	; 0x2e10 <xCoRoutineRemoveFromEventList+0x5e>
	}
	else
	{
		xReturn = pdFALSE;
    2e0e:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    2e10:	89 81       	ldd	r24, Y+1	; 0x01
}
    2e12:	0f 90       	pop	r0
    2e14:	0f 90       	pop	r0
    2e16:	0f 90       	pop	r0
    2e18:	0f 90       	pop	r0
    2e1a:	0f 90       	pop	r0
    2e1c:	cf 91       	pop	r28
    2e1e:	df 91       	pop	r29
    2e20:	08 95       	ret

00002e22 <pvPortMalloc>:

static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    2e22:	df 93       	push	r29
    2e24:	cf 93       	push	r28
    2e26:	00 d0       	rcall	.+0      	; 0x2e28 <pvPortMalloc+0x6>
    2e28:	00 d0       	rcall	.+0      	; 0x2e2a <pvPortMalloc+0x8>
    2e2a:	cd b7       	in	r28, 0x3d	; 61
    2e2c:	de b7       	in	r29, 0x3e	; 62
    2e2e:	9c 83       	std	Y+4, r25	; 0x04
    2e30:	8b 83       	std	Y+3, r24	; 0x03
void *pvReturn = NULL; 
    2e32:	1a 82       	std	Y+2, r1	; 0x02
    2e34:	19 82       	std	Y+1, r1	; 0x01
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
    2e36:	0e 94 38 23 	call	0x4670	; 0x4670 <vTaskSuspendAll>
	{
		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configTOTAL_HEAP_SIZE ) &&
    2e3a:	80 91 cc 01 	lds	r24, 0x01CC
    2e3e:	90 91 cd 01 	lds	r25, 0x01CD
    2e42:	2b 81       	ldd	r18, Y+3	; 0x03
    2e44:	3c 81       	ldd	r19, Y+4	; 0x04
    2e46:	82 0f       	add	r24, r18
    2e48:	93 1f       	adc	r25, r19
    2e4a:	22 e0       	ldi	r18, 0x02	; 2
    2e4c:	88 35       	cpi	r24, 0x58	; 88
    2e4e:	92 07       	cpc	r25, r18
    2e50:	18 f5       	brcc	.+70     	; 0x2e98 <pvPortMalloc+0x76>
    2e52:	20 91 cc 01 	lds	r18, 0x01CC
    2e56:	30 91 cd 01 	lds	r19, 0x01CD
    2e5a:	8b 81       	ldd	r24, Y+3	; 0x03
    2e5c:	9c 81       	ldd	r25, Y+4	; 0x04
    2e5e:	28 0f       	add	r18, r24
    2e60:	39 1f       	adc	r19, r25
    2e62:	80 91 cc 01 	lds	r24, 0x01CC
    2e66:	90 91 cd 01 	lds	r25, 0x01CD
    2e6a:	82 17       	cp	r24, r18
    2e6c:	93 07       	cpc	r25, r19
    2e6e:	a0 f4       	brcc	.+40     	; 0x2e98 <pvPortMalloc+0x76>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
    2e70:	80 91 cc 01 	lds	r24, 0x01CC
    2e74:	90 91 cd 01 	lds	r25, 0x01CD
    2e78:	82 53       	subi	r24, 0x32	; 50
    2e7a:	9e 4f       	sbci	r25, 0xFE	; 254
    2e7c:	9a 83       	std	Y+2, r25	; 0x02
    2e7e:	89 83       	std	Y+1, r24	; 0x01
			xNextFreeByte += xWantedSize;			
    2e80:	20 91 cc 01 	lds	r18, 0x01CC
    2e84:	30 91 cd 01 	lds	r19, 0x01CD
    2e88:	8b 81       	ldd	r24, Y+3	; 0x03
    2e8a:	9c 81       	ldd	r25, Y+4	; 0x04
    2e8c:	82 0f       	add	r24, r18
    2e8e:	93 1f       	adc	r25, r19
    2e90:	90 93 cd 01 	sts	0x01CD, r25
    2e94:	80 93 cc 01 	sts	0x01CC, r24
		}	
	}
	xTaskResumeAll();
    2e98:	0e 94 44 23 	call	0x4688	; 0x4688 <xTaskResumeAll>
			vApplicationMallocFailedHook();
		}
	}
	#endif	

	return pvReturn;
    2e9c:	89 81       	ldd	r24, Y+1	; 0x01
    2e9e:	9a 81       	ldd	r25, Y+2	; 0x02
}
    2ea0:	0f 90       	pop	r0
    2ea2:	0f 90       	pop	r0
    2ea4:	0f 90       	pop	r0
    2ea6:	0f 90       	pop	r0
    2ea8:	cf 91       	pop	r28
    2eaa:	df 91       	pop	r29
    2eac:	08 95       	ret

00002eae <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    2eae:	df 93       	push	r29
    2eb0:	cf 93       	push	r28
    2eb2:	00 d0       	rcall	.+0      	; 0x2eb4 <vPortFree+0x6>
    2eb4:	cd b7       	in	r28, 0x3d	; 61
    2eb6:	de b7       	in	r29, 0x3e	; 62
    2eb8:	9a 83       	std	Y+2, r25	; 0x02
    2eba:	89 83       	std	Y+1, r24	; 0x01
	/* Memory cannot be freed using this scheme.  See heap_2.c and heap_3.c 
	for alternative implementations, and the memory management pages of 
	http://www.FreeRTOS.org for more information. */
	( void ) pv;
}
    2ebc:	0f 90       	pop	r0
    2ebe:	0f 90       	pop	r0
    2ec0:	cf 91       	pop	r28
    2ec2:	df 91       	pop	r29
    2ec4:	08 95       	ret

00002ec6 <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
    2ec6:	df 93       	push	r29
    2ec8:	cf 93       	push	r28
    2eca:	cd b7       	in	r28, 0x3d	; 61
    2ecc:	de b7       	in	r29, 0x3e	; 62
	/* Only required when static memory is not cleared. */
	xNextFreeByte = ( size_t ) 0;
    2ece:	10 92 cd 01 	sts	0x01CD, r1
    2ed2:	10 92 cc 01 	sts	0x01CC, r1
}
    2ed6:	cf 91       	pop	r28
    2ed8:	df 91       	pop	r29
    2eda:	08 95       	ret

00002edc <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
    2edc:	df 93       	push	r29
    2ede:	cf 93       	push	r28
    2ee0:	cd b7       	in	r28, 0x3d	; 61
    2ee2:	de b7       	in	r29, 0x3e	; 62
	return ( configTOTAL_HEAP_SIZE - xNextFreeByte );
    2ee4:	20 91 cc 01 	lds	r18, 0x01CC
    2ee8:	30 91 cd 01 	lds	r19, 0x01CD
    2eec:	88 e5       	ldi	r24, 0x58	; 88
    2eee:	92 e0       	ldi	r25, 0x02	; 2
    2ef0:	82 1b       	sub	r24, r18
    2ef2:	93 0b       	sbc	r25, r19
}
    2ef4:	cf 91       	pop	r28
    2ef6:	df 91       	pop	r29
    2ef8:	08 95       	ret

00002efa <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
    2efa:	df 93       	push	r29
    2efc:	cf 93       	push	r28
    2efe:	00 d0       	rcall	.+0      	; 0x2f00 <vListInitialise+0x6>
    2f00:	cd b7       	in	r28, 0x3d	; 61
    2f02:	de b7       	in	r29, 0x3e	; 62
    2f04:	9a 83       	std	Y+2, r25	; 0x02
    2f06:	89 83       	std	Y+1, r24	; 0x01
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
    2f08:	89 81       	ldd	r24, Y+1	; 0x01
    2f0a:	9a 81       	ldd	r25, Y+2	; 0x02
    2f0c:	03 96       	adiw	r24, 0x03	; 3
    2f0e:	e9 81       	ldd	r30, Y+1	; 0x01
    2f10:	fa 81       	ldd	r31, Y+2	; 0x02
    2f12:	92 83       	std	Z+2, r25	; 0x02
    2f14:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    2f16:	e9 81       	ldd	r30, Y+1	; 0x01
    2f18:	fa 81       	ldd	r31, Y+2	; 0x02
    2f1a:	8f ef       	ldi	r24, 0xFF	; 255
    2f1c:	9f ef       	ldi	r25, 0xFF	; 255
    2f1e:	94 83       	std	Z+4, r25	; 0x04
    2f20:	83 83       	std	Z+3, r24	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
    2f22:	89 81       	ldd	r24, Y+1	; 0x01
    2f24:	9a 81       	ldd	r25, Y+2	; 0x02
    2f26:	03 96       	adiw	r24, 0x03	; 3
    2f28:	e9 81       	ldd	r30, Y+1	; 0x01
    2f2a:	fa 81       	ldd	r31, Y+2	; 0x02
    2f2c:	96 83       	std	Z+6, r25	; 0x06
    2f2e:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
    2f30:	89 81       	ldd	r24, Y+1	; 0x01
    2f32:	9a 81       	ldd	r25, Y+2	; 0x02
    2f34:	03 96       	adiw	r24, 0x03	; 3
    2f36:	e9 81       	ldd	r30, Y+1	; 0x01
    2f38:	fa 81       	ldd	r31, Y+2	; 0x02
    2f3a:	90 87       	std	Z+8, r25	; 0x08
    2f3c:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
    2f3e:	e9 81       	ldd	r30, Y+1	; 0x01
    2f40:	fa 81       	ldd	r31, Y+2	; 0x02
    2f42:	10 82       	st	Z, r1
}
    2f44:	0f 90       	pop	r0
    2f46:	0f 90       	pop	r0
    2f48:	cf 91       	pop	r28
    2f4a:	df 91       	pop	r29
    2f4c:	08 95       	ret

00002f4e <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
    2f4e:	df 93       	push	r29
    2f50:	cf 93       	push	r28
    2f52:	00 d0       	rcall	.+0      	; 0x2f54 <vListInitialiseItem+0x6>
    2f54:	cd b7       	in	r28, 0x3d	; 61
    2f56:	de b7       	in	r29, 0x3e	; 62
    2f58:	9a 83       	std	Y+2, r25	; 0x02
    2f5a:	89 83       	std	Y+1, r24	; 0x01
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
    2f5c:	e9 81       	ldd	r30, Y+1	; 0x01
    2f5e:	fa 81       	ldd	r31, Y+2	; 0x02
    2f60:	11 86       	std	Z+9, r1	; 0x09
    2f62:	10 86       	std	Z+8, r1	; 0x08
}
    2f64:	0f 90       	pop	r0
    2f66:	0f 90       	pop	r0
    2f68:	cf 91       	pop	r28
    2f6a:	df 91       	pop	r29
    2f6c:	08 95       	ret

00002f6e <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
    2f6e:	df 93       	push	r29
    2f70:	cf 93       	push	r28
    2f72:	00 d0       	rcall	.+0      	; 0x2f74 <vListInsertEnd+0x6>
    2f74:	00 d0       	rcall	.+0      	; 0x2f76 <vListInsertEnd+0x8>
    2f76:	00 d0       	rcall	.+0      	; 0x2f78 <vListInsertEnd+0xa>
    2f78:	cd b7       	in	r28, 0x3d	; 61
    2f7a:	de b7       	in	r29, 0x3e	; 62
    2f7c:	9c 83       	std	Y+4, r25	; 0x04
    2f7e:	8b 83       	std	Y+3, r24	; 0x03
    2f80:	7e 83       	std	Y+6, r23	; 0x06
    2f82:	6d 83       	std	Y+5, r22	; 0x05

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
    2f84:	eb 81       	ldd	r30, Y+3	; 0x03
    2f86:	fc 81       	ldd	r31, Y+4	; 0x04
    2f88:	81 81       	ldd	r24, Z+1	; 0x01
    2f8a:	92 81       	ldd	r25, Z+2	; 0x02
    2f8c:	9a 83       	std	Y+2, r25	; 0x02
    2f8e:	89 83       	std	Y+1, r24	; 0x01

	pxNewListItem->pxNext = pxIndex->pxNext;
    2f90:	e9 81       	ldd	r30, Y+1	; 0x01
    2f92:	fa 81       	ldd	r31, Y+2	; 0x02
    2f94:	82 81       	ldd	r24, Z+2	; 0x02
    2f96:	93 81       	ldd	r25, Z+3	; 0x03
    2f98:	ed 81       	ldd	r30, Y+5	; 0x05
    2f9a:	fe 81       	ldd	r31, Y+6	; 0x06
    2f9c:	93 83       	std	Z+3, r25	; 0x03
    2f9e:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxPrevious = pxList->pxIndex;
    2fa0:	eb 81       	ldd	r30, Y+3	; 0x03
    2fa2:	fc 81       	ldd	r31, Y+4	; 0x04
    2fa4:	81 81       	ldd	r24, Z+1	; 0x01
    2fa6:	92 81       	ldd	r25, Z+2	; 0x02
    2fa8:	ed 81       	ldd	r30, Y+5	; 0x05
    2faa:	fe 81       	ldd	r31, Y+6	; 0x06
    2fac:	95 83       	std	Z+5, r25	; 0x05
    2fae:	84 83       	std	Z+4, r24	; 0x04
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    2fb0:	e9 81       	ldd	r30, Y+1	; 0x01
    2fb2:	fa 81       	ldd	r31, Y+2	; 0x02
    2fb4:	02 80       	ldd	r0, Z+2	; 0x02
    2fb6:	f3 81       	ldd	r31, Z+3	; 0x03
    2fb8:	e0 2d       	mov	r30, r0
    2fba:	8d 81       	ldd	r24, Y+5	; 0x05
    2fbc:	9e 81       	ldd	r25, Y+6	; 0x06
    2fbe:	95 83       	std	Z+5, r25	; 0x05
    2fc0:	84 83       	std	Z+4, r24	; 0x04
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
    2fc2:	8d 81       	ldd	r24, Y+5	; 0x05
    2fc4:	9e 81       	ldd	r25, Y+6	; 0x06
    2fc6:	e9 81       	ldd	r30, Y+1	; 0x01
    2fc8:	fa 81       	ldd	r31, Y+2	; 0x02
    2fca:	93 83       	std	Z+3, r25	; 0x03
    2fcc:	82 83       	std	Z+2, r24	; 0x02
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
    2fce:	8d 81       	ldd	r24, Y+5	; 0x05
    2fd0:	9e 81       	ldd	r25, Y+6	; 0x06
    2fd2:	eb 81       	ldd	r30, Y+3	; 0x03
    2fd4:	fc 81       	ldd	r31, Y+4	; 0x04
    2fd6:	92 83       	std	Z+2, r25	; 0x02
    2fd8:	81 83       	std	Z+1, r24	; 0x01

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    2fda:	ed 81       	ldd	r30, Y+5	; 0x05
    2fdc:	fe 81       	ldd	r31, Y+6	; 0x06
    2fde:	8b 81       	ldd	r24, Y+3	; 0x03
    2fe0:	9c 81       	ldd	r25, Y+4	; 0x04
    2fe2:	91 87       	std	Z+9, r25	; 0x09
    2fe4:	80 87       	std	Z+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
    2fe6:	eb 81       	ldd	r30, Y+3	; 0x03
    2fe8:	fc 81       	ldd	r31, Y+4	; 0x04
    2fea:	80 81       	ld	r24, Z
    2fec:	8f 5f       	subi	r24, 0xFF	; 255
    2fee:	eb 81       	ldd	r30, Y+3	; 0x03
    2ff0:	fc 81       	ldd	r31, Y+4	; 0x04
    2ff2:	80 83       	st	Z, r24
}
    2ff4:	26 96       	adiw	r28, 0x06	; 6
    2ff6:	0f b6       	in	r0, 0x3f	; 63
    2ff8:	f8 94       	cli
    2ffa:	de bf       	out	0x3e, r29	; 62
    2ffc:	0f be       	out	0x3f, r0	; 63
    2ffe:	cd bf       	out	0x3d, r28	; 61
    3000:	cf 91       	pop	r28
    3002:	df 91       	pop	r29
    3004:	08 95       	ret

00003006 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
    3006:	df 93       	push	r29
    3008:	cf 93       	push	r28
    300a:	cd b7       	in	r28, 0x3d	; 61
    300c:	de b7       	in	r29, 0x3e	; 62
    300e:	28 97       	sbiw	r28, 0x08	; 8
    3010:	0f b6       	in	r0, 0x3f	; 63
    3012:	f8 94       	cli
    3014:	de bf       	out	0x3e, r29	; 62
    3016:	0f be       	out	0x3f, r0	; 63
    3018:	cd bf       	out	0x3d, r28	; 61
    301a:	9e 83       	std	Y+6, r25	; 0x06
    301c:	8d 83       	std	Y+5, r24	; 0x05
    301e:	78 87       	std	Y+8, r23	; 0x08
    3020:	6f 83       	std	Y+7, r22	; 0x07
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
    3022:	ef 81       	ldd	r30, Y+7	; 0x07
    3024:	f8 85       	ldd	r31, Y+8	; 0x08
    3026:	80 81       	ld	r24, Z
    3028:	91 81       	ldd	r25, Z+1	; 0x01
    302a:	9a 83       	std	Y+2, r25	; 0x02
    302c:	89 83       	std	Y+1, r24	; 0x01
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    302e:	89 81       	ldd	r24, Y+1	; 0x01
    3030:	9a 81       	ldd	r25, Y+2	; 0x02
    3032:	2f ef       	ldi	r18, 0xFF	; 255
    3034:	8f 3f       	cpi	r24, 0xFF	; 255
    3036:	92 07       	cpc	r25, r18
    3038:	39 f4       	brne	.+14     	; 0x3048 <vListInsert+0x42>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    303a:	ed 81       	ldd	r30, Y+5	; 0x05
    303c:	fe 81       	ldd	r31, Y+6	; 0x06
    303e:	87 81       	ldd	r24, Z+7	; 0x07
    3040:	90 85       	ldd	r25, Z+8	; 0x08
    3042:	9c 83       	std	Y+4, r25	; 0x04
    3044:	8b 83       	std	Y+3, r24	; 0x03
    3046:	18 c0       	rjmp	.+48     	; 0x3078 <vListInsert+0x72>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/
		
		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
    3048:	8d 81       	ldd	r24, Y+5	; 0x05
    304a:	9e 81       	ldd	r25, Y+6	; 0x06
    304c:	03 96       	adiw	r24, 0x03	; 3
    304e:	9c 83       	std	Y+4, r25	; 0x04
    3050:	8b 83       	std	Y+3, r24	; 0x03
    3052:	06 c0       	rjmp	.+12     	; 0x3060 <vListInsert+0x5a>
    3054:	eb 81       	ldd	r30, Y+3	; 0x03
    3056:	fc 81       	ldd	r31, Y+4	; 0x04
    3058:	82 81       	ldd	r24, Z+2	; 0x02
    305a:	93 81       	ldd	r25, Z+3	; 0x03
    305c:	9c 83       	std	Y+4, r25	; 0x04
    305e:	8b 83       	std	Y+3, r24	; 0x03
    3060:	eb 81       	ldd	r30, Y+3	; 0x03
    3062:	fc 81       	ldd	r31, Y+4	; 0x04
    3064:	02 80       	ldd	r0, Z+2	; 0x02
    3066:	f3 81       	ldd	r31, Z+3	; 0x03
    3068:	e0 2d       	mov	r30, r0
    306a:	20 81       	ld	r18, Z
    306c:	31 81       	ldd	r19, Z+1	; 0x01
    306e:	89 81       	ldd	r24, Y+1	; 0x01
    3070:	9a 81       	ldd	r25, Y+2	; 0x02
    3072:	82 17       	cp	r24, r18
    3074:	93 07       	cpc	r25, r19
    3076:	70 f7       	brcc	.-36     	; 0x3054 <vListInsert+0x4e>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    3078:	eb 81       	ldd	r30, Y+3	; 0x03
    307a:	fc 81       	ldd	r31, Y+4	; 0x04
    307c:	82 81       	ldd	r24, Z+2	; 0x02
    307e:	93 81       	ldd	r25, Z+3	; 0x03
    3080:	ef 81       	ldd	r30, Y+7	; 0x07
    3082:	f8 85       	ldd	r31, Y+8	; 0x08
    3084:	93 83       	std	Z+3, r25	; 0x03
    3086:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    3088:	ef 81       	ldd	r30, Y+7	; 0x07
    308a:	f8 85       	ldd	r31, Y+8	; 0x08
    308c:	02 80       	ldd	r0, Z+2	; 0x02
    308e:	f3 81       	ldd	r31, Z+3	; 0x03
    3090:	e0 2d       	mov	r30, r0
    3092:	8f 81       	ldd	r24, Y+7	; 0x07
    3094:	98 85       	ldd	r25, Y+8	; 0x08
    3096:	95 83       	std	Z+5, r25	; 0x05
    3098:	84 83       	std	Z+4, r24	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
    309a:	ef 81       	ldd	r30, Y+7	; 0x07
    309c:	f8 85       	ldd	r31, Y+8	; 0x08
    309e:	8b 81       	ldd	r24, Y+3	; 0x03
    30a0:	9c 81       	ldd	r25, Y+4	; 0x04
    30a2:	95 83       	std	Z+5, r25	; 0x05
    30a4:	84 83       	std	Z+4, r24	; 0x04
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
    30a6:	8f 81       	ldd	r24, Y+7	; 0x07
    30a8:	98 85       	ldd	r25, Y+8	; 0x08
    30aa:	eb 81       	ldd	r30, Y+3	; 0x03
    30ac:	fc 81       	ldd	r31, Y+4	; 0x04
    30ae:	93 83       	std	Z+3, r25	; 0x03
    30b0:	82 83       	std	Z+2, r24	; 0x02

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    30b2:	ef 81       	ldd	r30, Y+7	; 0x07
    30b4:	f8 85       	ldd	r31, Y+8	; 0x08
    30b6:	8d 81       	ldd	r24, Y+5	; 0x05
    30b8:	9e 81       	ldd	r25, Y+6	; 0x06
    30ba:	91 87       	std	Z+9, r25	; 0x09
    30bc:	80 87       	std	Z+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
    30be:	ed 81       	ldd	r30, Y+5	; 0x05
    30c0:	fe 81       	ldd	r31, Y+6	; 0x06
    30c2:	80 81       	ld	r24, Z
    30c4:	8f 5f       	subi	r24, 0xFF	; 255
    30c6:	ed 81       	ldd	r30, Y+5	; 0x05
    30c8:	fe 81       	ldd	r31, Y+6	; 0x06
    30ca:	80 83       	st	Z, r24
}
    30cc:	28 96       	adiw	r28, 0x08	; 8
    30ce:	0f b6       	in	r0, 0x3f	; 63
    30d0:	f8 94       	cli
    30d2:	de bf       	out	0x3e, r29	; 62
    30d4:	0f be       	out	0x3f, r0	; 63
    30d6:	cd bf       	out	0x3d, r28	; 61
    30d8:	cf 91       	pop	r28
    30da:	df 91       	pop	r29
    30dc:	08 95       	ret

000030de <vListRemove>:
/*-----------------------------------------------------------*/

void vListRemove( xListItem *pxItemToRemove )
{
    30de:	df 93       	push	r29
    30e0:	cf 93       	push	r28
    30e2:	00 d0       	rcall	.+0      	; 0x30e4 <vListRemove+0x6>
    30e4:	00 d0       	rcall	.+0      	; 0x30e6 <vListRemove+0x8>
    30e6:	cd b7       	in	r28, 0x3d	; 61
    30e8:	de b7       	in	r29, 0x3e	; 62
    30ea:	9c 83       	std	Y+4, r25	; 0x04
    30ec:	8b 83       	std	Y+3, r24	; 0x03
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    30ee:	eb 81       	ldd	r30, Y+3	; 0x03
    30f0:	fc 81       	ldd	r31, Y+4	; 0x04
    30f2:	a2 81       	ldd	r26, Z+2	; 0x02
    30f4:	b3 81       	ldd	r27, Z+3	; 0x03
    30f6:	eb 81       	ldd	r30, Y+3	; 0x03
    30f8:	fc 81       	ldd	r31, Y+4	; 0x04
    30fa:	84 81       	ldd	r24, Z+4	; 0x04
    30fc:	95 81       	ldd	r25, Z+5	; 0x05
    30fe:	15 96       	adiw	r26, 0x05	; 5
    3100:	9c 93       	st	X, r25
    3102:	8e 93       	st	-X, r24
    3104:	14 97       	sbiw	r26, 0x04	; 4
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    3106:	eb 81       	ldd	r30, Y+3	; 0x03
    3108:	fc 81       	ldd	r31, Y+4	; 0x04
    310a:	a4 81       	ldd	r26, Z+4	; 0x04
    310c:	b5 81       	ldd	r27, Z+5	; 0x05
    310e:	eb 81       	ldd	r30, Y+3	; 0x03
    3110:	fc 81       	ldd	r31, Y+4	; 0x04
    3112:	82 81       	ldd	r24, Z+2	; 0x02
    3114:	93 81       	ldd	r25, Z+3	; 0x03
    3116:	13 96       	adiw	r26, 0x03	; 3
    3118:	9c 93       	st	X, r25
    311a:	8e 93       	st	-X, r24
    311c:	12 97       	sbiw	r26, 0x02	; 2
	
	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
    311e:	eb 81       	ldd	r30, Y+3	; 0x03
    3120:	fc 81       	ldd	r31, Y+4	; 0x04
    3122:	80 85       	ldd	r24, Z+8	; 0x08
    3124:	91 85       	ldd	r25, Z+9	; 0x09
    3126:	9a 83       	std	Y+2, r25	; 0x02
    3128:	89 83       	std	Y+1, r24	; 0x01

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    312a:	e9 81       	ldd	r30, Y+1	; 0x01
    312c:	fa 81       	ldd	r31, Y+2	; 0x02
    312e:	21 81       	ldd	r18, Z+1	; 0x01
    3130:	32 81       	ldd	r19, Z+2	; 0x02
    3132:	8b 81       	ldd	r24, Y+3	; 0x03
    3134:	9c 81       	ldd	r25, Y+4	; 0x04
    3136:	28 17       	cp	r18, r24
    3138:	39 07       	cpc	r19, r25
    313a:	41 f4       	brne	.+16     	; 0x314c <vListRemove+0x6e>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    313c:	eb 81       	ldd	r30, Y+3	; 0x03
    313e:	fc 81       	ldd	r31, Y+4	; 0x04
    3140:	84 81       	ldd	r24, Z+4	; 0x04
    3142:	95 81       	ldd	r25, Z+5	; 0x05
    3144:	e9 81       	ldd	r30, Y+1	; 0x01
    3146:	fa 81       	ldd	r31, Y+2	; 0x02
    3148:	92 83       	std	Z+2, r25	; 0x02
    314a:	81 83       	std	Z+1, r24	; 0x01
	}

	pxItemToRemove->pvContainer = NULL;
    314c:	eb 81       	ldd	r30, Y+3	; 0x03
    314e:	fc 81       	ldd	r31, Y+4	; 0x04
    3150:	11 86       	std	Z+9, r1	; 0x09
    3152:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
    3154:	e9 81       	ldd	r30, Y+1	; 0x01
    3156:	fa 81       	ldd	r31, Y+2	; 0x02
    3158:	80 81       	ld	r24, Z
    315a:	81 50       	subi	r24, 0x01	; 1
    315c:	e9 81       	ldd	r30, Y+1	; 0x01
    315e:	fa 81       	ldd	r31, Y+2	; 0x02
    3160:	80 83       	st	Z, r24
}
    3162:	0f 90       	pop	r0
    3164:	0f 90       	pop	r0
    3166:	0f 90       	pop	r0
    3168:	0f 90       	pop	r0
    316a:	cf 91       	pop	r28
    316c:	df 91       	pop	r29
    316e:	08 95       	ret

00003170 <main>:
u8 LCD_FLAG = 0;



void main(void)
{
    3170:	af 92       	push	r10
    3172:	bf 92       	push	r11
    3174:	cf 92       	push	r12
    3176:	df 92       	push	r13
    3178:	ef 92       	push	r14
    317a:	ff 92       	push	r15
    317c:	0f 93       	push	r16
    317e:	df 93       	push	r29
    3180:	cf 93       	push	r28
    3182:	cd b7       	in	r28, 0x3d	; 61
    3184:	de b7       	in	r29, 0x3e	; 62


	MDIO_VoidSetPinDirection(DIO_PORTA,DIO_PIN0,DIO_OUTPUT);
    3186:	80 e0       	ldi	r24, 0x00	; 0
    3188:	60 e0       	ldi	r22, 0x00	; 0
    318a:	41 e0       	ldi	r20, 0x01	; 1
    318c:	0e 94 19 10 	call	0x2032	; 0x2032 <MDIO_VoidSetPinDirection>

	MDIO_VoidSetPinDirection(DIO_PORTA,DIO_PIN1,DIO_OUTPUT);
    3190:	80 e0       	ldi	r24, 0x00	; 0
    3192:	61 e0       	ldi	r22, 0x01	; 1
    3194:	41 e0       	ldi	r20, 0x01	; 1
    3196:	0e 94 19 10 	call	0x2032	; 0x2032 <MDIO_VoidSetPinDirection>
	MDIO_VoidSetPinDirection(DIO_PORTA,DIO_PIN2,DIO_OUTPUT);
    319a:	80 e0       	ldi	r24, 0x00	; 0
    319c:	62 e0       	ldi	r22, 0x02	; 2
    319e:	41 e0       	ldi	r20, 0x01	; 1
    31a0:	0e 94 19 10 	call	0x2032	; 0x2032 <MDIO_VoidSetPinDirection>


	/*			In this function i handled the port direction for the LCD			*/
	HLCD_enuInit();
    31a4:	0e 94 70 08 	call	0x10e0	; 0x10e0 <HLCD_enuInit>
	 *
	 * #define xTaskCreate( pvTaskCode, pcName, usStackDepth, pvParameters, uxPriority, pxCreatedTask ) xTaskGenericCreate( ( pvTaskCode ), ( pcName ), ( usStackDepth ), ( pvParameters ), ( uxPriority ), ( pxCreatedTask ), ( NULL ), ( NULL ) )
	 *
	 *
	 ***********************************************************************************************************************/
	xTaskCreate(&LED1, NULL, 100, NULL, 0, NULL);
    31a8:	8c e2       	ldi	r24, 0x2C	; 44
    31aa:	99 e1       	ldi	r25, 0x19	; 25
    31ac:	60 e0       	ldi	r22, 0x00	; 0
    31ae:	70 e0       	ldi	r23, 0x00	; 0
    31b0:	44 e6       	ldi	r20, 0x64	; 100
    31b2:	50 e0       	ldi	r21, 0x00	; 0
    31b4:	20 e0       	ldi	r18, 0x00	; 0
    31b6:	30 e0       	ldi	r19, 0x00	; 0
    31b8:	00 e0       	ldi	r16, 0x00	; 0
    31ba:	ee 24       	eor	r14, r14
    31bc:	ff 24       	eor	r15, r15
    31be:	cc 24       	eor	r12, r12
    31c0:	dd 24       	eor	r13, r13
    31c2:	aa 24       	eor	r10, r10
    31c4:	bb 24       	eor	r11, r11
    31c6:	0e 94 fc 20 	call	0x41f8	; 0x41f8 <xTaskGenericCreate>
	xTaskCreate(&LED2, NULL, 100, NULL, 1, NULL);
    31ca:	85 e4       	ldi	r24, 0x45	; 69
    31cc:	99 e1       	ldi	r25, 0x19	; 25
    31ce:	60 e0       	ldi	r22, 0x00	; 0
    31d0:	70 e0       	ldi	r23, 0x00	; 0
    31d2:	44 e6       	ldi	r20, 0x64	; 100
    31d4:	50 e0       	ldi	r21, 0x00	; 0
    31d6:	20 e0       	ldi	r18, 0x00	; 0
    31d8:	30 e0       	ldi	r19, 0x00	; 0
    31da:	01 e0       	ldi	r16, 0x01	; 1
    31dc:	ee 24       	eor	r14, r14
    31de:	ff 24       	eor	r15, r15
    31e0:	cc 24       	eor	r12, r12
    31e2:	dd 24       	eor	r13, r13
    31e4:	aa 24       	eor	r10, r10
    31e6:	bb 24       	eor	r11, r11
    31e8:	0e 94 fc 20 	call	0x41f8	; 0x41f8 <xTaskGenericCreate>
	xTaskCreate(&LED3, NULL, 100, NULL, 2, NULL);
    31ec:	8e e5       	ldi	r24, 0x5E	; 94
    31ee:	99 e1       	ldi	r25, 0x19	; 25
    31f0:	60 e0       	ldi	r22, 0x00	; 0
    31f2:	70 e0       	ldi	r23, 0x00	; 0
    31f4:	44 e6       	ldi	r20, 0x64	; 100
    31f6:	50 e0       	ldi	r21, 0x00	; 0
    31f8:	20 e0       	ldi	r18, 0x00	; 0
    31fa:	30 e0       	ldi	r19, 0x00	; 0
    31fc:	02 e0       	ldi	r16, 0x02	; 2
    31fe:	ee 24       	eor	r14, r14
    3200:	ff 24       	eor	r15, r15
    3202:	cc 24       	eor	r12, r12
    3204:	dd 24       	eor	r13, r13
    3206:	aa 24       	eor	r10, r10
    3208:	bb 24       	eor	r11, r11
    320a:	0e 94 fc 20 	call	0x41f8	; 0x41f8 <xTaskGenericCreate>


	xTaskCreate(&LCD1, NULL, 250, NULL, 0, NULL);
    320e:	87 e7       	ldi	r24, 0x77	; 119
    3210:	99 e1       	ldi	r25, 0x19	; 25
    3212:	60 e0       	ldi	r22, 0x00	; 0
    3214:	70 e0       	ldi	r23, 0x00	; 0
    3216:	4a ef       	ldi	r20, 0xFA	; 250
    3218:	50 e0       	ldi	r21, 0x00	; 0
    321a:	20 e0       	ldi	r18, 0x00	; 0
    321c:	30 e0       	ldi	r19, 0x00	; 0
    321e:	00 e0       	ldi	r16, 0x00	; 0
    3220:	ee 24       	eor	r14, r14
    3222:	ff 24       	eor	r15, r15
    3224:	cc 24       	eor	r12, r12
    3226:	dd 24       	eor	r13, r13
    3228:	aa 24       	eor	r10, r10
    322a:	bb 24       	eor	r11, r11
    322c:	0e 94 fc 20 	call	0x41f8	; 0x41f8 <xTaskGenericCreate>
	xTaskCreate(&LCD2, NULL, 250, NULL, 0, NULL);
    3230:	80 e9       	ldi	r24, 0x90	; 144
    3232:	99 e1       	ldi	r25, 0x19	; 25
    3234:	60 e0       	ldi	r22, 0x00	; 0
    3236:	70 e0       	ldi	r23, 0x00	; 0
    3238:	4a ef       	ldi	r20, 0xFA	; 250
    323a:	50 e0       	ldi	r21, 0x00	; 0
    323c:	20 e0       	ldi	r18, 0x00	; 0
    323e:	30 e0       	ldi	r19, 0x00	; 0
    3240:	00 e0       	ldi	r16, 0x00	; 0
    3242:	ee 24       	eor	r14, r14
    3244:	ff 24       	eor	r15, r15
    3246:	cc 24       	eor	r12, r12
    3248:	dd 24       	eor	r13, r13
    324a:	aa 24       	eor	r10, r10
    324c:	bb 24       	eor	r11, r11
    324e:	0e 94 fc 20 	call	0x41f8	; 0x41f8 <xTaskGenericCreate>
	/*						This is the function to initialize the scheduler of the tasks					*/
	vTaskStartScheduler();
    3252:	0e 94 f5 22 	call	0x45ea	; 0x45ea <vTaskStartScheduler>
    3256:	ff cf       	rjmp	.-2      	; 0x3256 <main+0xe6>

00003258 <LED1>:
}



void LED1(void * pv)
{
    3258:	df 93       	push	r29
    325a:	cf 93       	push	r28
    325c:	00 d0       	rcall	.+0      	; 0x325e <LED1+0x6>
    325e:	cd b7       	in	r28, 0x3d	; 61
    3260:	de b7       	in	r29, 0x3e	; 62
    3262:	9a 83       	std	Y+2, r25	; 0x02
    3264:	89 83       	std	Y+1, r24	; 0x01
	static u8 Local_u8LedState = 0;
	while(1)
	{

		TOGGLE_BIT(Local_u8LedState,0);
    3266:	90 91 27 04 	lds	r25, 0x0427
    326a:	81 e0       	ldi	r24, 0x01	; 1
    326c:	89 27       	eor	r24, r25
    326e:	80 93 27 04 	sts	0x0427, r24
		MDIO_VoidSetPinValue(DIO_PORTA,DIO_PIN0,Local_u8LedState);
    3272:	90 91 27 04 	lds	r25, 0x0427
    3276:	80 e0       	ldi	r24, 0x00	; 0
    3278:	60 e0       	ldi	r22, 0x00	; 0
    327a:	49 2f       	mov	r20, r25
    327c:	0e 94 21 11 	call	0x2242	; 0x2242 <MDIO_VoidSetPinValue>

		vTaskDelay(1000);
    3280:	88 ee       	ldi	r24, 0xE8	; 232
    3282:	93 e0       	ldi	r25, 0x03	; 3
    3284:	0e 94 c0 22 	call	0x4580	; 0x4580 <vTaskDelay>
    3288:	ee cf       	rjmp	.-36     	; 0x3266 <LED1+0xe>

0000328a <LED2>:
}



void LED2(void * pv)
{
    328a:	df 93       	push	r29
    328c:	cf 93       	push	r28
    328e:	00 d0       	rcall	.+0      	; 0x3290 <LED2+0x6>
    3290:	cd b7       	in	r28, 0x3d	; 61
    3292:	de b7       	in	r29, 0x3e	; 62
    3294:	9a 83       	std	Y+2, r25	; 0x02
    3296:	89 83       	std	Y+1, r24	; 0x01

	static u8 Local_u8LedState = 0;
	while(1)
	{

		TOGGLE_BIT(Local_u8LedState,0);
    3298:	90 91 28 04 	lds	r25, 0x0428
    329c:	81 e0       	ldi	r24, 0x01	; 1
    329e:	89 27       	eor	r24, r25
    32a0:	80 93 28 04 	sts	0x0428, r24
		MDIO_VoidSetPinValue(DIO_PORTA,DIO_PIN1,Local_u8LedState);
    32a4:	90 91 28 04 	lds	r25, 0x0428
    32a8:	80 e0       	ldi	r24, 0x00	; 0
    32aa:	61 e0       	ldi	r22, 0x01	; 1
    32ac:	49 2f       	mov	r20, r25
    32ae:	0e 94 21 11 	call	0x2242	; 0x2242 <MDIO_VoidSetPinValue>

		vTaskDelay(2000);
    32b2:	80 ed       	ldi	r24, 0xD0	; 208
    32b4:	97 e0       	ldi	r25, 0x07	; 7
    32b6:	0e 94 c0 22 	call	0x4580	; 0x4580 <vTaskDelay>
    32ba:	ee cf       	rjmp	.-36     	; 0x3298 <LED2+0xe>

000032bc <LED3>:
}



void LED3(void * pv)
{
    32bc:	df 93       	push	r29
    32be:	cf 93       	push	r28
    32c0:	00 d0       	rcall	.+0      	; 0x32c2 <LED3+0x6>
    32c2:	cd b7       	in	r28, 0x3d	; 61
    32c4:	de b7       	in	r29, 0x3e	; 62
    32c6:	9a 83       	std	Y+2, r25	; 0x02
    32c8:	89 83       	std	Y+1, r24	; 0x01

	static u8 Local_u8LedState = 0;
	while(1)
	{

		TOGGLE_BIT(Local_u8LedState,0);
    32ca:	90 91 29 04 	lds	r25, 0x0429
    32ce:	81 e0       	ldi	r24, 0x01	; 1
    32d0:	89 27       	eor	r24, r25
    32d2:	80 93 29 04 	sts	0x0429, r24
		MDIO_VoidSetPinValue(DIO_PORTA,DIO_PIN2,Local_u8LedState);
    32d6:	90 91 29 04 	lds	r25, 0x0429
    32da:	80 e0       	ldi	r24, 0x00	; 0
    32dc:	62 e0       	ldi	r22, 0x02	; 2
    32de:	49 2f       	mov	r20, r25
    32e0:	0e 94 21 11 	call	0x2242	; 0x2242 <MDIO_VoidSetPinValue>

		vTaskDelay(3000);
    32e4:	88 eb       	ldi	r24, 0xB8	; 184
    32e6:	9b e0       	ldi	r25, 0x0B	; 11
    32e8:	0e 94 c0 22 	call	0x4580	; 0x4580 <vTaskDelay>
    32ec:	ee cf       	rjmp	.-36     	; 0x32ca <LED3+0xe>

000032ee <LCD1>:
}



void LCD1(void * pv)
{
    32ee:	df 93       	push	r29
    32f0:	cf 93       	push	r28
    32f2:	00 d0       	rcall	.+0      	; 0x32f4 <LCD1+0x6>
    32f4:	cd b7       	in	r28, 0x3d	; 61
    32f6:	de b7       	in	r29, 0x3e	; 62
    32f8:	9a 83       	std	Y+2, r25	; 0x02
    32fa:	89 83       	std	Y+1, r24	; 0x01

	while(1)
	{
		if(LCD_FLAG == 0)
    32fc:	80 91 26 04 	lds	r24, 0x0426
    3300:	88 23       	and	r24, r24
    3302:	49 f4       	brne	.+18     	; 0x3316 <LCD1+0x28>
		{
			LCD_FLAG = 1;
    3304:	81 e0       	ldi	r24, 0x01	; 1
    3306:	80 93 26 04 	sts	0x0426, r24
			HLCD_VoidWriteStr("I AM MOAMEN");
    330a:	80 e6       	ldi	r24, 0x60	; 96
    330c:	90 e0       	ldi	r25, 0x00	; 0
    330e:	0e 94 67 0a 	call	0x14ce	; 0x14ce <HLCD_VoidWriteStr>


			LCD_FLAG = 0;
    3312:	10 92 26 04 	sts	0x0426, r1
		}
		vTaskDelay(1000);
    3316:	88 ee       	ldi	r24, 0xE8	; 232
    3318:	93 e0       	ldi	r25, 0x03	; 3
    331a:	0e 94 c0 22 	call	0x4580	; 0x4580 <vTaskDelay>
    331e:	ee cf       	rjmp	.-36     	; 0x32fc <LCD1+0xe>

00003320 <LCD2>:

}


void LCD2(void * pv)
{
    3320:	df 93       	push	r29
    3322:	cf 93       	push	r28
    3324:	00 d0       	rcall	.+0      	; 0x3326 <LCD2+0x6>
    3326:	cd b7       	in	r28, 0x3d	; 61
    3328:	de b7       	in	r29, 0x3e	; 62
    332a:	9a 83       	std	Y+2, r25	; 0x02
    332c:	89 83       	std	Y+1, r24	; 0x01

	while(1)
	{
		if(LCD_FLAG == 0)
    332e:	80 91 26 04 	lds	r24, 0x0426
    3332:	88 23       	and	r24, r24
    3334:	49 f4       	brne	.+18     	; 0x3348 <LCD2+0x28>
		{
			LCD_FLAG = 1;
    3336:	81 e0       	ldi	r24, 0x01	; 1
    3338:	80 93 26 04 	sts	0x0426, r24
		HLCD_VoidWriteStr("I AM MOAMEN number 2");
    333c:	8c e6       	ldi	r24, 0x6C	; 108
    333e:	90 e0       	ldi	r25, 0x00	; 0
    3340:	0e 94 67 0a 	call	0x14ce	; 0x14ce <HLCD_VoidWriteStr>

		LCD_FLAG = 0;
    3344:	10 92 26 04 	sts	0x0426, r1
		}
		vTaskDelay(1000);
    3348:	88 ee       	ldi	r24, 0xE8	; 232
    334a:	93 e0       	ldi	r25, 0x03	; 3
    334c:	0e 94 c0 22 	call	0x4580	; 0x4580 <vTaskDelay>
    3350:	ee cf       	rjmp	.-36     	; 0x332e <LCD2+0xe>

00003352 <pxPortInitialiseStack>:

/* 
 * See header file for description. 
 */
portSTACK_TYPE *pxPortInitialiseStack( portSTACK_TYPE *pxTopOfStack, pdTASK_CODE pxCode, void *pvParameters )
{
    3352:	df 93       	push	r29
    3354:	cf 93       	push	r28
    3356:	cd b7       	in	r28, 0x3d	; 61
    3358:	de b7       	in	r29, 0x3e	; 62
    335a:	28 97       	sbiw	r28, 0x08	; 8
    335c:	0f b6       	in	r0, 0x3f	; 63
    335e:	f8 94       	cli
    3360:	de bf       	out	0x3e, r29	; 62
    3362:	0f be       	out	0x3f, r0	; 63
    3364:	cd bf       	out	0x3d, r28	; 61
    3366:	9c 83       	std	Y+4, r25	; 0x04
    3368:	8b 83       	std	Y+3, r24	; 0x03
    336a:	7e 83       	std	Y+6, r23	; 0x06
    336c:	6d 83       	std	Y+5, r22	; 0x05
    336e:	58 87       	std	Y+8, r21	; 0x08
    3370:	4f 83       	std	Y+7, r20	; 0x07
unsigned short usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
    3372:	eb 81       	ldd	r30, Y+3	; 0x03
    3374:	fc 81       	ldd	r31, Y+4	; 0x04
    3376:	81 e1       	ldi	r24, 0x11	; 17
    3378:	80 83       	st	Z, r24
	pxTopOfStack--;
    337a:	8b 81       	ldd	r24, Y+3	; 0x03
    337c:	9c 81       	ldd	r25, Y+4	; 0x04
    337e:	01 97       	sbiw	r24, 0x01	; 1
    3380:	9c 83       	std	Y+4, r25	; 0x04
    3382:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x22;
    3384:	eb 81       	ldd	r30, Y+3	; 0x03
    3386:	fc 81       	ldd	r31, Y+4	; 0x04
    3388:	82 e2       	ldi	r24, 0x22	; 34
    338a:	80 83       	st	Z, r24
	pxTopOfStack--;
    338c:	8b 81       	ldd	r24, Y+3	; 0x03
    338e:	9c 81       	ldd	r25, Y+4	; 0x04
    3390:	01 97       	sbiw	r24, 0x01	; 1
    3392:	9c 83       	std	Y+4, r25	; 0x04
    3394:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x33;
    3396:	eb 81       	ldd	r30, Y+3	; 0x03
    3398:	fc 81       	ldd	r31, Y+4	; 0x04
    339a:	83 e3       	ldi	r24, 0x33	; 51
    339c:	80 83       	st	Z, r24
	pxTopOfStack--;
    339e:	8b 81       	ldd	r24, Y+3	; 0x03
    33a0:	9c 81       	ldd	r25, Y+4	; 0x04
    33a2:	01 97       	sbiw	r24, 0x01	; 1
    33a4:	9c 83       	std	Y+4, r25	; 0x04
    33a6:	8b 83       	std	Y+3, r24	; 0x03

	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( unsigned short ) pxCode;
    33a8:	8d 81       	ldd	r24, Y+5	; 0x05
    33aa:	9e 81       	ldd	r25, Y+6	; 0x06
    33ac:	9a 83       	std	Y+2, r25	; 0x02
    33ae:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    33b0:	89 81       	ldd	r24, Y+1	; 0x01
    33b2:	eb 81       	ldd	r30, Y+3	; 0x03
    33b4:	fc 81       	ldd	r31, Y+4	; 0x04
    33b6:	80 83       	st	Z, r24
	pxTopOfStack--;
    33b8:	8b 81       	ldd	r24, Y+3	; 0x03
    33ba:	9c 81       	ldd	r25, Y+4	; 0x04
    33bc:	01 97       	sbiw	r24, 0x01	; 1
    33be:	9c 83       	std	Y+4, r25	; 0x04
    33c0:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
    33c2:	89 81       	ldd	r24, Y+1	; 0x01
    33c4:	9a 81       	ldd	r25, Y+2	; 0x02
    33c6:	89 2f       	mov	r24, r25
    33c8:	99 27       	eor	r25, r25
    33ca:	9a 83       	std	Y+2, r25	; 0x02
    33cc:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    33ce:	89 81       	ldd	r24, Y+1	; 0x01
    33d0:	eb 81       	ldd	r30, Y+3	; 0x03
    33d2:	fc 81       	ldd	r31, Y+4	; 0x04
    33d4:	80 83       	st	Z, r24
	pxTopOfStack--;
    33d6:	8b 81       	ldd	r24, Y+3	; 0x03
    33d8:	9c 81       	ldd	r25, Y+4	; 0x04
    33da:	01 97       	sbiw	r24, 0x01	; 1
    33dc:	9c 83       	std	Y+4, r25	; 0x04
    33de:	8b 83       	std	Y+3, r24	; 0x03

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R0 */
    33e0:	eb 81       	ldd	r30, Y+3	; 0x03
    33e2:	fc 81       	ldd	r31, Y+4	; 0x04
    33e4:	10 82       	st	Z, r1
	pxTopOfStack--;
    33e6:	8b 81       	ldd	r24, Y+3	; 0x03
    33e8:	9c 81       	ldd	r25, Y+4	; 0x04
    33ea:	01 97       	sbiw	r24, 0x01	; 1
    33ec:	9c 83       	std	Y+4, r25	; 0x04
    33ee:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = portFLAGS_INT_ENABLED;
    33f0:	eb 81       	ldd	r30, Y+3	; 0x03
    33f2:	fc 81       	ldd	r31, Y+4	; 0x04
    33f4:	80 e8       	ldi	r24, 0x80	; 128
    33f6:	80 83       	st	Z, r24
	pxTopOfStack--;
    33f8:	8b 81       	ldd	r24, Y+3	; 0x03
    33fa:	9c 81       	ldd	r25, Y+4	; 0x04
    33fc:	01 97       	sbiw	r24, 0x01	; 1
    33fe:	9c 83       	std	Y+4, r25	; 0x04
    3400:	8b 83       	std	Y+3, r24	; 0x03


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R1 */
    3402:	eb 81       	ldd	r30, Y+3	; 0x03
    3404:	fc 81       	ldd	r31, Y+4	; 0x04
    3406:	10 82       	st	Z, r1
	pxTopOfStack--;
    3408:	8b 81       	ldd	r24, Y+3	; 0x03
    340a:	9c 81       	ldd	r25, Y+4	; 0x04
    340c:	01 97       	sbiw	r24, 0x01	; 1
    340e:	9c 83       	std	Y+4, r25	; 0x04
    3410:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x02;	/* R2 */
    3412:	eb 81       	ldd	r30, Y+3	; 0x03
    3414:	fc 81       	ldd	r31, Y+4	; 0x04
    3416:	82 e0       	ldi	r24, 0x02	; 2
    3418:	80 83       	st	Z, r24
	pxTopOfStack--;
    341a:	8b 81       	ldd	r24, Y+3	; 0x03
    341c:	9c 81       	ldd	r25, Y+4	; 0x04
    341e:	01 97       	sbiw	r24, 0x01	; 1
    3420:	9c 83       	std	Y+4, r25	; 0x04
    3422:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x03;	/* R3 */
    3424:	eb 81       	ldd	r30, Y+3	; 0x03
    3426:	fc 81       	ldd	r31, Y+4	; 0x04
    3428:	83 e0       	ldi	r24, 0x03	; 3
    342a:	80 83       	st	Z, r24
	pxTopOfStack--;
    342c:	8b 81       	ldd	r24, Y+3	; 0x03
    342e:	9c 81       	ldd	r25, Y+4	; 0x04
    3430:	01 97       	sbiw	r24, 0x01	; 1
    3432:	9c 83       	std	Y+4, r25	; 0x04
    3434:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x04;	/* R4 */
    3436:	eb 81       	ldd	r30, Y+3	; 0x03
    3438:	fc 81       	ldd	r31, Y+4	; 0x04
    343a:	84 e0       	ldi	r24, 0x04	; 4
    343c:	80 83       	st	Z, r24
	pxTopOfStack--;
    343e:	8b 81       	ldd	r24, Y+3	; 0x03
    3440:	9c 81       	ldd	r25, Y+4	; 0x04
    3442:	01 97       	sbiw	r24, 0x01	; 1
    3444:	9c 83       	std	Y+4, r25	; 0x04
    3446:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x05;	/* R5 */
    3448:	eb 81       	ldd	r30, Y+3	; 0x03
    344a:	fc 81       	ldd	r31, Y+4	; 0x04
    344c:	85 e0       	ldi	r24, 0x05	; 5
    344e:	80 83       	st	Z, r24
	pxTopOfStack--;
    3450:	8b 81       	ldd	r24, Y+3	; 0x03
    3452:	9c 81       	ldd	r25, Y+4	; 0x04
    3454:	01 97       	sbiw	r24, 0x01	; 1
    3456:	9c 83       	std	Y+4, r25	; 0x04
    3458:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x06;	/* R6 */
    345a:	eb 81       	ldd	r30, Y+3	; 0x03
    345c:	fc 81       	ldd	r31, Y+4	; 0x04
    345e:	86 e0       	ldi	r24, 0x06	; 6
    3460:	80 83       	st	Z, r24
	pxTopOfStack--;
    3462:	8b 81       	ldd	r24, Y+3	; 0x03
    3464:	9c 81       	ldd	r25, Y+4	; 0x04
    3466:	01 97       	sbiw	r24, 0x01	; 1
    3468:	9c 83       	std	Y+4, r25	; 0x04
    346a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x07;	/* R7 */
    346c:	eb 81       	ldd	r30, Y+3	; 0x03
    346e:	fc 81       	ldd	r31, Y+4	; 0x04
    3470:	87 e0       	ldi	r24, 0x07	; 7
    3472:	80 83       	st	Z, r24
	pxTopOfStack--;
    3474:	8b 81       	ldd	r24, Y+3	; 0x03
    3476:	9c 81       	ldd	r25, Y+4	; 0x04
    3478:	01 97       	sbiw	r24, 0x01	; 1
    347a:	9c 83       	std	Y+4, r25	; 0x04
    347c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x08;	/* R8 */
    347e:	eb 81       	ldd	r30, Y+3	; 0x03
    3480:	fc 81       	ldd	r31, Y+4	; 0x04
    3482:	88 e0       	ldi	r24, 0x08	; 8
    3484:	80 83       	st	Z, r24
	pxTopOfStack--;
    3486:	8b 81       	ldd	r24, Y+3	; 0x03
    3488:	9c 81       	ldd	r25, Y+4	; 0x04
    348a:	01 97       	sbiw	r24, 0x01	; 1
    348c:	9c 83       	std	Y+4, r25	; 0x04
    348e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x09;	/* R9 */
    3490:	eb 81       	ldd	r30, Y+3	; 0x03
    3492:	fc 81       	ldd	r31, Y+4	; 0x04
    3494:	89 e0       	ldi	r24, 0x09	; 9
    3496:	80 83       	st	Z, r24
	pxTopOfStack--;
    3498:	8b 81       	ldd	r24, Y+3	; 0x03
    349a:	9c 81       	ldd	r25, Y+4	; 0x04
    349c:	01 97       	sbiw	r24, 0x01	; 1
    349e:	9c 83       	std	Y+4, r25	; 0x04
    34a0:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x10;	/* R10 */
    34a2:	eb 81       	ldd	r30, Y+3	; 0x03
    34a4:	fc 81       	ldd	r31, Y+4	; 0x04
    34a6:	80 e1       	ldi	r24, 0x10	; 16
    34a8:	80 83       	st	Z, r24
	pxTopOfStack--;
    34aa:	8b 81       	ldd	r24, Y+3	; 0x03
    34ac:	9c 81       	ldd	r25, Y+4	; 0x04
    34ae:	01 97       	sbiw	r24, 0x01	; 1
    34b0:	9c 83       	std	Y+4, r25	; 0x04
    34b2:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x11;	/* R11 */
    34b4:	eb 81       	ldd	r30, Y+3	; 0x03
    34b6:	fc 81       	ldd	r31, Y+4	; 0x04
    34b8:	81 e1       	ldi	r24, 0x11	; 17
    34ba:	80 83       	st	Z, r24
	pxTopOfStack--;
    34bc:	8b 81       	ldd	r24, Y+3	; 0x03
    34be:	9c 81       	ldd	r25, Y+4	; 0x04
    34c0:	01 97       	sbiw	r24, 0x01	; 1
    34c2:	9c 83       	std	Y+4, r25	; 0x04
    34c4:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x12;	/* R12 */
    34c6:	eb 81       	ldd	r30, Y+3	; 0x03
    34c8:	fc 81       	ldd	r31, Y+4	; 0x04
    34ca:	82 e1       	ldi	r24, 0x12	; 18
    34cc:	80 83       	st	Z, r24
	pxTopOfStack--;
    34ce:	8b 81       	ldd	r24, Y+3	; 0x03
    34d0:	9c 81       	ldd	r25, Y+4	; 0x04
    34d2:	01 97       	sbiw	r24, 0x01	; 1
    34d4:	9c 83       	std	Y+4, r25	; 0x04
    34d6:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x13;	/* R13 */
    34d8:	eb 81       	ldd	r30, Y+3	; 0x03
    34da:	fc 81       	ldd	r31, Y+4	; 0x04
    34dc:	83 e1       	ldi	r24, 0x13	; 19
    34de:	80 83       	st	Z, r24
	pxTopOfStack--;
    34e0:	8b 81       	ldd	r24, Y+3	; 0x03
    34e2:	9c 81       	ldd	r25, Y+4	; 0x04
    34e4:	01 97       	sbiw	r24, 0x01	; 1
    34e6:	9c 83       	std	Y+4, r25	; 0x04
    34e8:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x14;	/* R14 */
    34ea:	eb 81       	ldd	r30, Y+3	; 0x03
    34ec:	fc 81       	ldd	r31, Y+4	; 0x04
    34ee:	84 e1       	ldi	r24, 0x14	; 20
    34f0:	80 83       	st	Z, r24
	pxTopOfStack--;
    34f2:	8b 81       	ldd	r24, Y+3	; 0x03
    34f4:	9c 81       	ldd	r25, Y+4	; 0x04
    34f6:	01 97       	sbiw	r24, 0x01	; 1
    34f8:	9c 83       	std	Y+4, r25	; 0x04
    34fa:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x15;	/* R15 */
    34fc:	eb 81       	ldd	r30, Y+3	; 0x03
    34fe:	fc 81       	ldd	r31, Y+4	; 0x04
    3500:	85 e1       	ldi	r24, 0x15	; 21
    3502:	80 83       	st	Z, r24
	pxTopOfStack--;
    3504:	8b 81       	ldd	r24, Y+3	; 0x03
    3506:	9c 81       	ldd	r25, Y+4	; 0x04
    3508:	01 97       	sbiw	r24, 0x01	; 1
    350a:	9c 83       	std	Y+4, r25	; 0x04
    350c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x16;	/* R16 */
    350e:	eb 81       	ldd	r30, Y+3	; 0x03
    3510:	fc 81       	ldd	r31, Y+4	; 0x04
    3512:	86 e1       	ldi	r24, 0x16	; 22
    3514:	80 83       	st	Z, r24
	pxTopOfStack--;
    3516:	8b 81       	ldd	r24, Y+3	; 0x03
    3518:	9c 81       	ldd	r25, Y+4	; 0x04
    351a:	01 97       	sbiw	r24, 0x01	; 1
    351c:	9c 83       	std	Y+4, r25	; 0x04
    351e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x17;	/* R17 */
    3520:	eb 81       	ldd	r30, Y+3	; 0x03
    3522:	fc 81       	ldd	r31, Y+4	; 0x04
    3524:	87 e1       	ldi	r24, 0x17	; 23
    3526:	80 83       	st	Z, r24
	pxTopOfStack--;
    3528:	8b 81       	ldd	r24, Y+3	; 0x03
    352a:	9c 81       	ldd	r25, Y+4	; 0x04
    352c:	01 97       	sbiw	r24, 0x01	; 1
    352e:	9c 83       	std	Y+4, r25	; 0x04
    3530:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x18;	/* R18 */
    3532:	eb 81       	ldd	r30, Y+3	; 0x03
    3534:	fc 81       	ldd	r31, Y+4	; 0x04
    3536:	88 e1       	ldi	r24, 0x18	; 24
    3538:	80 83       	st	Z, r24
	pxTopOfStack--;
    353a:	8b 81       	ldd	r24, Y+3	; 0x03
    353c:	9c 81       	ldd	r25, Y+4	; 0x04
    353e:	01 97       	sbiw	r24, 0x01	; 1
    3540:	9c 83       	std	Y+4, r25	; 0x04
    3542:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x19;	/* R19 */
    3544:	eb 81       	ldd	r30, Y+3	; 0x03
    3546:	fc 81       	ldd	r31, Y+4	; 0x04
    3548:	89 e1       	ldi	r24, 0x19	; 25
    354a:	80 83       	st	Z, r24
	pxTopOfStack--;
    354c:	8b 81       	ldd	r24, Y+3	; 0x03
    354e:	9c 81       	ldd	r25, Y+4	; 0x04
    3550:	01 97       	sbiw	r24, 0x01	; 1
    3552:	9c 83       	std	Y+4, r25	; 0x04
    3554:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x20;	/* R20 */
    3556:	eb 81       	ldd	r30, Y+3	; 0x03
    3558:	fc 81       	ldd	r31, Y+4	; 0x04
    355a:	80 e2       	ldi	r24, 0x20	; 32
    355c:	80 83       	st	Z, r24
	pxTopOfStack--;
    355e:	8b 81       	ldd	r24, Y+3	; 0x03
    3560:	9c 81       	ldd	r25, Y+4	; 0x04
    3562:	01 97       	sbiw	r24, 0x01	; 1
    3564:	9c 83       	std	Y+4, r25	; 0x04
    3566:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x21;	/* R21 */
    3568:	eb 81       	ldd	r30, Y+3	; 0x03
    356a:	fc 81       	ldd	r31, Y+4	; 0x04
    356c:	81 e2       	ldi	r24, 0x21	; 33
    356e:	80 83       	st	Z, r24
	pxTopOfStack--;
    3570:	8b 81       	ldd	r24, Y+3	; 0x03
    3572:	9c 81       	ldd	r25, Y+4	; 0x04
    3574:	01 97       	sbiw	r24, 0x01	; 1
    3576:	9c 83       	std	Y+4, r25	; 0x04
    3578:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x22;	/* R22 */
    357a:	eb 81       	ldd	r30, Y+3	; 0x03
    357c:	fc 81       	ldd	r31, Y+4	; 0x04
    357e:	82 e2       	ldi	r24, 0x22	; 34
    3580:	80 83       	st	Z, r24
	pxTopOfStack--;
    3582:	8b 81       	ldd	r24, Y+3	; 0x03
    3584:	9c 81       	ldd	r25, Y+4	; 0x04
    3586:	01 97       	sbiw	r24, 0x01	; 1
    3588:	9c 83       	std	Y+4, r25	; 0x04
    358a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x23;	/* R23 */
    358c:	eb 81       	ldd	r30, Y+3	; 0x03
    358e:	fc 81       	ldd	r31, Y+4	; 0x04
    3590:	83 e2       	ldi	r24, 0x23	; 35
    3592:	80 83       	st	Z, r24
	pxTopOfStack--;
    3594:	8b 81       	ldd	r24, Y+3	; 0x03
    3596:	9c 81       	ldd	r25, Y+4	; 0x04
    3598:	01 97       	sbiw	r24, 0x01	; 1
    359a:	9c 83       	std	Y+4, r25	; 0x04
    359c:	8b 83       	std	Y+3, r24	; 0x03

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( unsigned short ) pvParameters;
    359e:	8f 81       	ldd	r24, Y+7	; 0x07
    35a0:	98 85       	ldd	r25, Y+8	; 0x08
    35a2:	9a 83       	std	Y+2, r25	; 0x02
    35a4:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    35a6:	89 81       	ldd	r24, Y+1	; 0x01
    35a8:	eb 81       	ldd	r30, Y+3	; 0x03
    35aa:	fc 81       	ldd	r31, Y+4	; 0x04
    35ac:	80 83       	st	Z, r24
	pxTopOfStack--;
    35ae:	8b 81       	ldd	r24, Y+3	; 0x03
    35b0:	9c 81       	ldd	r25, Y+4	; 0x04
    35b2:	01 97       	sbiw	r24, 0x01	; 1
    35b4:	9c 83       	std	Y+4, r25	; 0x04
    35b6:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
    35b8:	89 81       	ldd	r24, Y+1	; 0x01
    35ba:	9a 81       	ldd	r25, Y+2	; 0x02
    35bc:	89 2f       	mov	r24, r25
    35be:	99 27       	eor	r25, r25
    35c0:	9a 83       	std	Y+2, r25	; 0x02
    35c2:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    35c4:	89 81       	ldd	r24, Y+1	; 0x01
    35c6:	eb 81       	ldd	r30, Y+3	; 0x03
    35c8:	fc 81       	ldd	r31, Y+4	; 0x04
    35ca:	80 83       	st	Z, r24
	pxTopOfStack--;
    35cc:	8b 81       	ldd	r24, Y+3	; 0x03
    35ce:	9c 81       	ldd	r25, Y+4	; 0x04
    35d0:	01 97       	sbiw	r24, 0x01	; 1
    35d2:	9c 83       	std	Y+4, r25	; 0x04
    35d4:	8b 83       	std	Y+3, r24	; 0x03

	*pxTopOfStack = ( portSTACK_TYPE ) 0x26;	/* R26 X */
    35d6:	eb 81       	ldd	r30, Y+3	; 0x03
    35d8:	fc 81       	ldd	r31, Y+4	; 0x04
    35da:	86 e2       	ldi	r24, 0x26	; 38
    35dc:	80 83       	st	Z, r24
	pxTopOfStack--;
    35de:	8b 81       	ldd	r24, Y+3	; 0x03
    35e0:	9c 81       	ldd	r25, Y+4	; 0x04
    35e2:	01 97       	sbiw	r24, 0x01	; 1
    35e4:	9c 83       	std	Y+4, r25	; 0x04
    35e6:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x27;	/* R27 */
    35e8:	eb 81       	ldd	r30, Y+3	; 0x03
    35ea:	fc 81       	ldd	r31, Y+4	; 0x04
    35ec:	87 e2       	ldi	r24, 0x27	; 39
    35ee:	80 83       	st	Z, r24
	pxTopOfStack--;
    35f0:	8b 81       	ldd	r24, Y+3	; 0x03
    35f2:	9c 81       	ldd	r25, Y+4	; 0x04
    35f4:	01 97       	sbiw	r24, 0x01	; 1
    35f6:	9c 83       	std	Y+4, r25	; 0x04
    35f8:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x28;	/* R28 Y */
    35fa:	eb 81       	ldd	r30, Y+3	; 0x03
    35fc:	fc 81       	ldd	r31, Y+4	; 0x04
    35fe:	88 e2       	ldi	r24, 0x28	; 40
    3600:	80 83       	st	Z, r24
	pxTopOfStack--;
    3602:	8b 81       	ldd	r24, Y+3	; 0x03
    3604:	9c 81       	ldd	r25, Y+4	; 0x04
    3606:	01 97       	sbiw	r24, 0x01	; 1
    3608:	9c 83       	std	Y+4, r25	; 0x04
    360a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x29;	/* R29 */
    360c:	eb 81       	ldd	r30, Y+3	; 0x03
    360e:	fc 81       	ldd	r31, Y+4	; 0x04
    3610:	89 e2       	ldi	r24, 0x29	; 41
    3612:	80 83       	st	Z, r24
	pxTopOfStack--;
    3614:	8b 81       	ldd	r24, Y+3	; 0x03
    3616:	9c 81       	ldd	r25, Y+4	; 0x04
    3618:	01 97       	sbiw	r24, 0x01	; 1
    361a:	9c 83       	std	Y+4, r25	; 0x04
    361c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x30;	/* R30 Z */
    361e:	eb 81       	ldd	r30, Y+3	; 0x03
    3620:	fc 81       	ldd	r31, Y+4	; 0x04
    3622:	80 e3       	ldi	r24, 0x30	; 48
    3624:	80 83       	st	Z, r24
	pxTopOfStack--;
    3626:	8b 81       	ldd	r24, Y+3	; 0x03
    3628:	9c 81       	ldd	r25, Y+4	; 0x04
    362a:	01 97       	sbiw	r24, 0x01	; 1
    362c:	9c 83       	std	Y+4, r25	; 0x04
    362e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x031;	/* R31 */
    3630:	eb 81       	ldd	r30, Y+3	; 0x03
    3632:	fc 81       	ldd	r31, Y+4	; 0x04
    3634:	81 e3       	ldi	r24, 0x31	; 49
    3636:	80 83       	st	Z, r24
	pxTopOfStack--;
    3638:	8b 81       	ldd	r24, Y+3	; 0x03
    363a:	9c 81       	ldd	r25, Y+4	; 0x04
    363c:	01 97       	sbiw	r24, 0x01	; 1
    363e:	9c 83       	std	Y+4, r25	; 0x04
    3640:	8b 83       	std	Y+3, r24	; 0x03

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
    3642:	8b 81       	ldd	r24, Y+3	; 0x03
    3644:	9c 81       	ldd	r25, Y+4	; 0x04
}
    3646:	28 96       	adiw	r28, 0x08	; 8
    3648:	0f b6       	in	r0, 0x3f	; 63
    364a:	f8 94       	cli
    364c:	de bf       	out	0x3e, r29	; 62
    364e:	0f be       	out	0x3f, r0	; 63
    3650:	cd bf       	out	0x3d, r28	; 61
    3652:	cf 91       	pop	r28
    3654:	df 91       	pop	r29
    3656:	08 95       	ret

00003658 <xPortStartScheduler>:
/*-----------------------------------------------------------*/

portBASE_TYPE xPortStartScheduler( void )
{
    3658:	df 93       	push	r29
    365a:	cf 93       	push	r28
    365c:	cd b7       	in	r28, 0x3d	; 61
    365e:	de b7       	in	r29, 0x3e	; 62
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();
    3660:	0e 94 1c 1c 	call	0x3838	; 0x3838 <prvSetupTimerInterrupt>

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
    3664:	a0 91 2a 04 	lds	r26, 0x042A
    3668:	b0 91 2b 04 	lds	r27, 0x042B
    366c:	cd 91       	ld	r28, X+
    366e:	cd bf       	out	0x3d, r28	; 61
    3670:	dd 91       	ld	r29, X+
    3672:	de bf       	out	0x3e, r29	; 62
    3674:	ff 91       	pop	r31
    3676:	ef 91       	pop	r30
    3678:	df 91       	pop	r29
    367a:	cf 91       	pop	r28
    367c:	bf 91       	pop	r27
    367e:	af 91       	pop	r26
    3680:	9f 91       	pop	r25
    3682:	8f 91       	pop	r24
    3684:	7f 91       	pop	r23
    3686:	6f 91       	pop	r22
    3688:	5f 91       	pop	r21
    368a:	4f 91       	pop	r20
    368c:	3f 91       	pop	r19
    368e:	2f 91       	pop	r18
    3690:	1f 91       	pop	r17
    3692:	0f 91       	pop	r16
    3694:	ff 90       	pop	r15
    3696:	ef 90       	pop	r14
    3698:	df 90       	pop	r13
    369a:	cf 90       	pop	r12
    369c:	bf 90       	pop	r11
    369e:	af 90       	pop	r10
    36a0:	9f 90       	pop	r9
    36a2:	8f 90       	pop	r8
    36a4:	7f 90       	pop	r7
    36a6:	6f 90       	pop	r6
    36a8:	5f 90       	pop	r5
    36aa:	4f 90       	pop	r4
    36ac:	3f 90       	pop	r3
    36ae:	2f 90       	pop	r2
    36b0:	1f 90       	pop	r1
    36b2:	0f 90       	pop	r0
    36b4:	0f be       	out	0x3f, r0	; 63
    36b6:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
    36b8:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
    36ba:	81 e0       	ldi	r24, 0x01	; 1
}
    36bc:	cf 91       	pop	r28
    36be:	df 91       	pop	r29
    36c0:	08 95       	ret

000036c2 <vPortEndScheduler>:
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    36c2:	df 93       	push	r29
    36c4:	cf 93       	push	r28
    36c6:	cd b7       	in	r28, 0x3d	; 61
    36c8:	de b7       	in	r29, 0x3e	; 62
	/* It is unlikely that the AVR port will get stopped.  If required simply
	disable the tick interrupt here. */
}
    36ca:	cf 91       	pop	r28
    36cc:	df 91       	pop	r29
    36ce:	08 95       	ret

000036d0 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    36d0:	0f 92       	push	r0
    36d2:	0f b6       	in	r0, 0x3f	; 63
    36d4:	f8 94       	cli
    36d6:	0f 92       	push	r0
    36d8:	1f 92       	push	r1
    36da:	11 24       	eor	r1, r1
    36dc:	2f 92       	push	r2
    36de:	3f 92       	push	r3
    36e0:	4f 92       	push	r4
    36e2:	5f 92       	push	r5
    36e4:	6f 92       	push	r6
    36e6:	7f 92       	push	r7
    36e8:	8f 92       	push	r8
    36ea:	9f 92       	push	r9
    36ec:	af 92       	push	r10
    36ee:	bf 92       	push	r11
    36f0:	cf 92       	push	r12
    36f2:	df 92       	push	r13
    36f4:	ef 92       	push	r14
    36f6:	ff 92       	push	r15
    36f8:	0f 93       	push	r16
    36fa:	1f 93       	push	r17
    36fc:	2f 93       	push	r18
    36fe:	3f 93       	push	r19
    3700:	4f 93       	push	r20
    3702:	5f 93       	push	r21
    3704:	6f 93       	push	r22
    3706:	7f 93       	push	r23
    3708:	8f 93       	push	r24
    370a:	9f 93       	push	r25
    370c:	af 93       	push	r26
    370e:	bf 93       	push	r27
    3710:	cf 93       	push	r28
    3712:	df 93       	push	r29
    3714:	ef 93       	push	r30
    3716:	ff 93       	push	r31
    3718:	a0 91 2a 04 	lds	r26, 0x042A
    371c:	b0 91 2b 04 	lds	r27, 0x042B
    3720:	0d b6       	in	r0, 0x3d	; 61
    3722:	0d 92       	st	X+, r0
    3724:	0e b6       	in	r0, 0x3e	; 62
    3726:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    3728:	0e 94 d8 24 	call	0x49b0	; 0x49b0 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    372c:	a0 91 2a 04 	lds	r26, 0x042A
    3730:	b0 91 2b 04 	lds	r27, 0x042B
    3734:	cd 91       	ld	r28, X+
    3736:	cd bf       	out	0x3d, r28	; 61
    3738:	dd 91       	ld	r29, X+
    373a:	de bf       	out	0x3e, r29	; 62
    373c:	ff 91       	pop	r31
    373e:	ef 91       	pop	r30
    3740:	df 91       	pop	r29
    3742:	cf 91       	pop	r28
    3744:	bf 91       	pop	r27
    3746:	af 91       	pop	r26
    3748:	9f 91       	pop	r25
    374a:	8f 91       	pop	r24
    374c:	7f 91       	pop	r23
    374e:	6f 91       	pop	r22
    3750:	5f 91       	pop	r21
    3752:	4f 91       	pop	r20
    3754:	3f 91       	pop	r19
    3756:	2f 91       	pop	r18
    3758:	1f 91       	pop	r17
    375a:	0f 91       	pop	r16
    375c:	ff 90       	pop	r15
    375e:	ef 90       	pop	r14
    3760:	df 90       	pop	r13
    3762:	cf 90       	pop	r12
    3764:	bf 90       	pop	r11
    3766:	af 90       	pop	r10
    3768:	9f 90       	pop	r9
    376a:	8f 90       	pop	r8
    376c:	7f 90       	pop	r7
    376e:	6f 90       	pop	r6
    3770:	5f 90       	pop	r5
    3772:	4f 90       	pop	r4
    3774:	3f 90       	pop	r3
    3776:	2f 90       	pop	r2
    3778:	1f 90       	pop	r1
    377a:	0f 90       	pop	r0
    377c:	0f be       	out	0x3f, r0	; 63
    377e:	0f 90       	pop	r0

	asm volatile ( "ret" );
    3780:	08 95       	ret

00003782 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    3782:	0f 92       	push	r0
    3784:	0f b6       	in	r0, 0x3f	; 63
    3786:	f8 94       	cli
    3788:	0f 92       	push	r0
    378a:	1f 92       	push	r1
    378c:	11 24       	eor	r1, r1
    378e:	2f 92       	push	r2
    3790:	3f 92       	push	r3
    3792:	4f 92       	push	r4
    3794:	5f 92       	push	r5
    3796:	6f 92       	push	r6
    3798:	7f 92       	push	r7
    379a:	8f 92       	push	r8
    379c:	9f 92       	push	r9
    379e:	af 92       	push	r10
    37a0:	bf 92       	push	r11
    37a2:	cf 92       	push	r12
    37a4:	df 92       	push	r13
    37a6:	ef 92       	push	r14
    37a8:	ff 92       	push	r15
    37aa:	0f 93       	push	r16
    37ac:	1f 93       	push	r17
    37ae:	2f 93       	push	r18
    37b0:	3f 93       	push	r19
    37b2:	4f 93       	push	r20
    37b4:	5f 93       	push	r21
    37b6:	6f 93       	push	r22
    37b8:	7f 93       	push	r23
    37ba:	8f 93       	push	r24
    37bc:	9f 93       	push	r25
    37be:	af 93       	push	r26
    37c0:	bf 93       	push	r27
    37c2:	cf 93       	push	r28
    37c4:	df 93       	push	r29
    37c6:	ef 93       	push	r30
    37c8:	ff 93       	push	r31
    37ca:	a0 91 2a 04 	lds	r26, 0x042A
    37ce:	b0 91 2b 04 	lds	r27, 0x042B
    37d2:	0d b6       	in	r0, 0x3d	; 61
    37d4:	0d 92       	st	X+, r0
    37d6:	0e b6       	in	r0, 0x3e	; 62
    37d8:	0d 92       	st	X+, r0
	vTaskIncrementTick();
    37da:	0e 94 03 24 	call	0x4806	; 0x4806 <vTaskIncrementTick>
	vTaskSwitchContext();
    37de:	0e 94 d8 24 	call	0x49b0	; 0x49b0 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    37e2:	a0 91 2a 04 	lds	r26, 0x042A
    37e6:	b0 91 2b 04 	lds	r27, 0x042B
    37ea:	cd 91       	ld	r28, X+
    37ec:	cd bf       	out	0x3d, r28	; 61
    37ee:	dd 91       	ld	r29, X+
    37f0:	de bf       	out	0x3e, r29	; 62
    37f2:	ff 91       	pop	r31
    37f4:	ef 91       	pop	r30
    37f6:	df 91       	pop	r29
    37f8:	cf 91       	pop	r28
    37fa:	bf 91       	pop	r27
    37fc:	af 91       	pop	r26
    37fe:	9f 91       	pop	r25
    3800:	8f 91       	pop	r24
    3802:	7f 91       	pop	r23
    3804:	6f 91       	pop	r22
    3806:	5f 91       	pop	r21
    3808:	4f 91       	pop	r20
    380a:	3f 91       	pop	r19
    380c:	2f 91       	pop	r18
    380e:	1f 91       	pop	r17
    3810:	0f 91       	pop	r16
    3812:	ff 90       	pop	r15
    3814:	ef 90       	pop	r14
    3816:	df 90       	pop	r13
    3818:	cf 90       	pop	r12
    381a:	bf 90       	pop	r11
    381c:	af 90       	pop	r10
    381e:	9f 90       	pop	r9
    3820:	8f 90       	pop	r8
    3822:	7f 90       	pop	r7
    3824:	6f 90       	pop	r6
    3826:	5f 90       	pop	r5
    3828:	4f 90       	pop	r4
    382a:	3f 90       	pop	r3
    382c:	2f 90       	pop	r2
    382e:	1f 90       	pop	r1
    3830:	0f 90       	pop	r0
    3832:	0f be       	out	0x3f, r0	; 63
    3834:	0f 90       	pop	r0

	asm volatile ( "ret" );
    3836:	08 95       	ret

00003838 <prvSetupTimerInterrupt>:

/*
 * Setup timer 1 compare match A to generate a tick interrupt.
 */
static void prvSetupTimerInterrupt( void )
{
    3838:	df 93       	push	r29
    383a:	cf 93       	push	r28
    383c:	00 d0       	rcall	.+0      	; 0x383e <prvSetupTimerInterrupt+0x6>
    383e:	00 d0       	rcall	.+0      	; 0x3840 <prvSetupTimerInterrupt+0x8>
    3840:	00 d0       	rcall	.+0      	; 0x3842 <prvSetupTimerInterrupt+0xa>
    3842:	cd b7       	in	r28, 0x3d	; 61
    3844:	de b7       	in	r29, 0x3e	; 62
unsigned char ucHighByte, ucLowByte;

	/* Using 16bit timer 1 to generate the tick.  Correct fuses must be
	selected for the configCPU_CLOCK_HZ clock. */

	ulCompareMatch = configCPU_CLOCK_HZ / configTICK_RATE_HZ;
    3846:	80 e4       	ldi	r24, 0x40	; 64
    3848:	9f e1       	ldi	r25, 0x1F	; 31
    384a:	a0 e0       	ldi	r26, 0x00	; 0
    384c:	b0 e0       	ldi	r27, 0x00	; 0
    384e:	8b 83       	std	Y+3, r24	; 0x03
    3850:	9c 83       	std	Y+4, r25	; 0x04
    3852:	ad 83       	std	Y+5, r26	; 0x05
    3854:	be 83       	std	Y+6, r27	; 0x06

	/* We only have 16 bits so have to scale to get our required tick rate. */
	ulCompareMatch /= portCLOCK_PRESCALER;
    3856:	8b 81       	ldd	r24, Y+3	; 0x03
    3858:	9c 81       	ldd	r25, Y+4	; 0x04
    385a:	ad 81       	ldd	r26, Y+5	; 0x05
    385c:	be 81       	ldd	r27, Y+6	; 0x06
    385e:	68 94       	set
    3860:	15 f8       	bld	r1, 5
    3862:	b6 95       	lsr	r27
    3864:	a7 95       	ror	r26
    3866:	97 95       	ror	r25
    3868:	87 95       	ror	r24
    386a:	16 94       	lsr	r1
    386c:	d1 f7       	brne	.-12     	; 0x3862 <prvSetupTimerInterrupt+0x2a>
    386e:	8b 83       	std	Y+3, r24	; 0x03
    3870:	9c 83       	std	Y+4, r25	; 0x04
    3872:	ad 83       	std	Y+5, r26	; 0x05
    3874:	be 83       	std	Y+6, r27	; 0x06

	/* Adjust for correct value. */
	ulCompareMatch -= ( unsigned long ) 1;
    3876:	8b 81       	ldd	r24, Y+3	; 0x03
    3878:	9c 81       	ldd	r25, Y+4	; 0x04
    387a:	ad 81       	ldd	r26, Y+5	; 0x05
    387c:	be 81       	ldd	r27, Y+6	; 0x06
    387e:	01 97       	sbiw	r24, 0x01	; 1
    3880:	a1 09       	sbc	r26, r1
    3882:	b1 09       	sbc	r27, r1
    3884:	8b 83       	std	Y+3, r24	; 0x03
    3886:	9c 83       	std	Y+4, r25	; 0x04
    3888:	ad 83       	std	Y+5, r26	; 0x05
    388a:	be 83       	std	Y+6, r27	; 0x06

	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
	ucLowByte = ( unsigned char ) ( ulCompareMatch & ( unsigned long ) 0xff );
    388c:	8b 81       	ldd	r24, Y+3	; 0x03
    388e:	89 83       	std	Y+1, r24	; 0x01
	ulCompareMatch >>= 8;
    3890:	8b 81       	ldd	r24, Y+3	; 0x03
    3892:	9c 81       	ldd	r25, Y+4	; 0x04
    3894:	ad 81       	ldd	r26, Y+5	; 0x05
    3896:	be 81       	ldd	r27, Y+6	; 0x06
    3898:	89 2f       	mov	r24, r25
    389a:	9a 2f       	mov	r25, r26
    389c:	ab 2f       	mov	r26, r27
    389e:	bb 27       	eor	r27, r27
    38a0:	8b 83       	std	Y+3, r24	; 0x03
    38a2:	9c 83       	std	Y+4, r25	; 0x04
    38a4:	ad 83       	std	Y+5, r26	; 0x05
    38a6:	be 83       	std	Y+6, r27	; 0x06
	ucHighByte = ( unsigned char ) ( ulCompareMatch & ( unsigned long ) 0xff );
    38a8:	8b 81       	ldd	r24, Y+3	; 0x03
    38aa:	8a 83       	std	Y+2, r24	; 0x02
	OCR1AH = ucHighByte;
    38ac:	eb e4       	ldi	r30, 0x4B	; 75
    38ae:	f0 e0       	ldi	r31, 0x00	; 0
    38b0:	8a 81       	ldd	r24, Y+2	; 0x02
    38b2:	80 83       	st	Z, r24
	OCR1AL = ucLowByte;
    38b4:	ea e4       	ldi	r30, 0x4A	; 74
    38b6:	f0 e0       	ldi	r31, 0x00	; 0
    38b8:	89 81       	ldd	r24, Y+1	; 0x01
    38ba:	80 83       	st	Z, r24

	/* Setup clock source and compare match behaviour. */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
    38bc:	8b e0       	ldi	r24, 0x0B	; 11
    38be:	89 83       	std	Y+1, r24	; 0x01
	TCCR1B = ucLowByte;
    38c0:	ee e4       	ldi	r30, 0x4E	; 78
    38c2:	f0 e0       	ldi	r31, 0x00	; 0
    38c4:	89 81       	ldd	r24, Y+1	; 0x01
    38c6:	80 83       	st	Z, r24

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK;
    38c8:	e9 e5       	ldi	r30, 0x59	; 89
    38ca:	f0 e0       	ldi	r31, 0x00	; 0
    38cc:	80 81       	ld	r24, Z
    38ce:	89 83       	std	Y+1, r24	; 0x01
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
    38d0:	89 81       	ldd	r24, Y+1	; 0x01
    38d2:	80 61       	ori	r24, 0x10	; 16
    38d4:	89 83       	std	Y+1, r24	; 0x01
	TIMSK = ucLowByte;
    38d6:	e9 e5       	ldi	r30, 0x59	; 89
    38d8:	f0 e0       	ldi	r31, 0x00	; 0
    38da:	89 81       	ldd	r24, Y+1	; 0x01
    38dc:	80 83       	st	Z, r24
}
    38de:	26 96       	adiw	r28, 0x06	; 6
    38e0:	0f b6       	in	r0, 0x3f	; 63
    38e2:	f8 94       	cli
    38e4:	de bf       	out	0x3e, r29	; 62
    38e6:	0f be       	out	0x3f, r0	; 63
    38e8:	cd bf       	out	0x3d, r28	; 61
    38ea:	cf 91       	pop	r28
    38ec:	df 91       	pop	r29
    38ee:	08 95       	ret

000038f0 <__vector_6>:
	 * count is incremented after the context is saved.
	 */
	void SIG_OUTPUT_COMPARE1A( void ) __attribute__ ( ( signal, naked ) );
	void SIG_OUTPUT_COMPARE1A( void )
	{
		vPortYieldFromTick();
    38f0:	0e 94 c1 1b 	call	0x3782	; 0x3782 <vPortYieldFromTick>
		asm volatile ( "reti" );
    38f4:	18 95       	reti

000038f6 <xQueueCreate>:
/*-----------------------------------------------------------
 * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 *----------------------------------------------------------*/

xQueueHandle xQueueCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize )
{
    38f6:	df 93       	push	r29
    38f8:	cf 93       	push	r28
    38fa:	cd b7       	in	r28, 0x3d	; 61
    38fc:	de b7       	in	r29, 0x3e	; 62
    38fe:	28 97       	sbiw	r28, 0x08	; 8
    3900:	0f b6       	in	r0, 0x3f	; 63
    3902:	f8 94       	cli
    3904:	de bf       	out	0x3e, r29	; 62
    3906:	0f be       	out	0x3f, r0	; 63
    3908:	cd bf       	out	0x3d, r28	; 61
    390a:	8f 83       	std	Y+7, r24	; 0x07
    390c:	68 87       	std	Y+8, r22	; 0x08
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;
xQueueHandle xReturn = NULL;
    390e:	1a 82       	std	Y+2, r1	; 0x02
    3910:	19 82       	std	Y+1, r1	; 0x01

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
    3912:	8f 81       	ldd	r24, Y+7	; 0x07
    3914:	88 23       	and	r24, r24
    3916:	09 f4       	brne	.+2      	; 0x391a <xQueueCreate+0x24>
    3918:	8c c0       	rjmp	.+280    	; 0x3a32 <xQueueCreate+0x13c>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
    391a:	8f e1       	ldi	r24, 0x1F	; 31
    391c:	90 e0       	ldi	r25, 0x00	; 0
    391e:	0e 94 11 17 	call	0x2e22	; 0x2e22 <pvPortMalloc>
    3922:	9e 83       	std	Y+6, r25	; 0x06
    3924:	8d 83       	std	Y+5, r24	; 0x05
		if( pxNewQueue != NULL )
    3926:	8d 81       	ldd	r24, Y+5	; 0x05
    3928:	9e 81       	ldd	r25, Y+6	; 0x06
    392a:	00 97       	sbiw	r24, 0x00	; 0
    392c:	09 f4       	brne	.+2      	; 0x3930 <xQueueCreate+0x3a>
    392e:	81 c0       	rjmp	.+258    	; 0x3a32 <xQueueCreate+0x13c>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
    3930:	8f 81       	ldd	r24, Y+7	; 0x07
    3932:	28 2f       	mov	r18, r24
    3934:	30 e0       	ldi	r19, 0x00	; 0
    3936:	88 85       	ldd	r24, Y+8	; 0x08
    3938:	88 2f       	mov	r24, r24
    393a:	90 e0       	ldi	r25, 0x00	; 0
    393c:	ac 01       	movw	r20, r24
    393e:	24 9f       	mul	r18, r20
    3940:	c0 01       	movw	r24, r0
    3942:	25 9f       	mul	r18, r21
    3944:	90 0d       	add	r25, r0
    3946:	34 9f       	mul	r19, r20
    3948:	90 0d       	add	r25, r0
    394a:	11 24       	eor	r1, r1
    394c:	01 96       	adiw	r24, 0x01	; 1
    394e:	9c 83       	std	Y+4, r25	; 0x04
    3950:	8b 83       	std	Y+3, r24	; 0x03

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
    3952:	8b 81       	ldd	r24, Y+3	; 0x03
    3954:	9c 81       	ldd	r25, Y+4	; 0x04
    3956:	0e 94 11 17 	call	0x2e22	; 0x2e22 <pvPortMalloc>
    395a:	ed 81       	ldd	r30, Y+5	; 0x05
    395c:	fe 81       	ldd	r31, Y+6	; 0x06
    395e:	91 83       	std	Z+1, r25	; 0x01
    3960:	80 83       	st	Z, r24
			if( pxNewQueue->pcHead != NULL )
    3962:	ed 81       	ldd	r30, Y+5	; 0x05
    3964:	fe 81       	ldd	r31, Y+6	; 0x06
    3966:	80 81       	ld	r24, Z
    3968:	91 81       	ldd	r25, Z+1	; 0x01
    396a:	00 97       	sbiw	r24, 0x00	; 0
    396c:	09 f4       	brne	.+2      	; 0x3970 <xQueueCreate+0x7a>
    396e:	5d c0       	rjmp	.+186    	; 0x3a2a <xQueueCreate+0x134>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->pcTail = pxNewQueue->pcHead + ( uxQueueLength * uxItemSize );
    3970:	ed 81       	ldd	r30, Y+5	; 0x05
    3972:	fe 81       	ldd	r31, Y+6	; 0x06
    3974:	40 81       	ld	r20, Z
    3976:	51 81       	ldd	r21, Z+1	; 0x01
    3978:	8f 81       	ldd	r24, Y+7	; 0x07
    397a:	28 2f       	mov	r18, r24
    397c:	30 e0       	ldi	r19, 0x00	; 0
    397e:	88 85       	ldd	r24, Y+8	; 0x08
    3980:	88 2f       	mov	r24, r24
    3982:	90 e0       	ldi	r25, 0x00	; 0
    3984:	bc 01       	movw	r22, r24
    3986:	26 9f       	mul	r18, r22
    3988:	c0 01       	movw	r24, r0
    398a:	27 9f       	mul	r18, r23
    398c:	90 0d       	add	r25, r0
    398e:	36 9f       	mul	r19, r22
    3990:	90 0d       	add	r25, r0
    3992:	11 24       	eor	r1, r1
    3994:	84 0f       	add	r24, r20
    3996:	95 1f       	adc	r25, r21
    3998:	ed 81       	ldd	r30, Y+5	; 0x05
    399a:	fe 81       	ldd	r31, Y+6	; 0x06
    399c:	93 83       	std	Z+3, r25	; 0x03
    399e:	82 83       	std	Z+2, r24	; 0x02
				pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
    39a0:	ed 81       	ldd	r30, Y+5	; 0x05
    39a2:	fe 81       	ldd	r31, Y+6	; 0x06
    39a4:	12 8e       	std	Z+26, r1	; 0x1a
				pxNewQueue->pcWriteTo = pxNewQueue->pcHead;
    39a6:	ed 81       	ldd	r30, Y+5	; 0x05
    39a8:	fe 81       	ldd	r31, Y+6	; 0x06
    39aa:	80 81       	ld	r24, Z
    39ac:	91 81       	ldd	r25, Z+1	; 0x01
    39ae:	ed 81       	ldd	r30, Y+5	; 0x05
    39b0:	fe 81       	ldd	r31, Y+6	; 0x06
    39b2:	95 83       	std	Z+5, r25	; 0x05
    39b4:	84 83       	std	Z+4, r24	; 0x04
				pxNewQueue->pcReadFrom = pxNewQueue->pcHead + ( ( uxQueueLength - ( unsigned portBASE_TYPE ) 1U ) * uxItemSize );
    39b6:	ed 81       	ldd	r30, Y+5	; 0x05
    39b8:	fe 81       	ldd	r31, Y+6	; 0x06
    39ba:	40 81       	ld	r20, Z
    39bc:	51 81       	ldd	r21, Z+1	; 0x01
    39be:	8f 81       	ldd	r24, Y+7	; 0x07
    39c0:	88 2f       	mov	r24, r24
    39c2:	90 e0       	ldi	r25, 0x00	; 0
    39c4:	9c 01       	movw	r18, r24
    39c6:	21 50       	subi	r18, 0x01	; 1
    39c8:	30 40       	sbci	r19, 0x00	; 0
    39ca:	88 85       	ldd	r24, Y+8	; 0x08
    39cc:	88 2f       	mov	r24, r24
    39ce:	90 e0       	ldi	r25, 0x00	; 0
    39d0:	bc 01       	movw	r22, r24
    39d2:	26 9f       	mul	r18, r22
    39d4:	c0 01       	movw	r24, r0
    39d6:	27 9f       	mul	r18, r23
    39d8:	90 0d       	add	r25, r0
    39da:	36 9f       	mul	r19, r22
    39dc:	90 0d       	add	r25, r0
    39de:	11 24       	eor	r1, r1
    39e0:	84 0f       	add	r24, r20
    39e2:	95 1f       	adc	r25, r21
    39e4:	ed 81       	ldd	r30, Y+5	; 0x05
    39e6:	fe 81       	ldd	r31, Y+6	; 0x06
    39e8:	97 83       	std	Z+7, r25	; 0x07
    39ea:	86 83       	std	Z+6, r24	; 0x06
				pxNewQueue->uxLength = uxQueueLength;
    39ec:	ed 81       	ldd	r30, Y+5	; 0x05
    39ee:	fe 81       	ldd	r31, Y+6	; 0x06
    39f0:	8f 81       	ldd	r24, Y+7	; 0x07
    39f2:	83 8f       	std	Z+27, r24	; 0x1b
				pxNewQueue->uxItemSize = uxItemSize;
    39f4:	ed 81       	ldd	r30, Y+5	; 0x05
    39f6:	fe 81       	ldd	r31, Y+6	; 0x06
    39f8:	88 85       	ldd	r24, Y+8	; 0x08
    39fa:	84 8f       	std	Z+28, r24	; 0x1c
				pxNewQueue->xRxLock = queueUNLOCKED;
    39fc:	ed 81       	ldd	r30, Y+5	; 0x05
    39fe:	fe 81       	ldd	r31, Y+6	; 0x06
    3a00:	8f ef       	ldi	r24, 0xFF	; 255
    3a02:	85 8f       	std	Z+29, r24	; 0x1d
				pxNewQueue->xTxLock = queueUNLOCKED;
    3a04:	ed 81       	ldd	r30, Y+5	; 0x05
    3a06:	fe 81       	ldd	r31, Y+6	; 0x06
    3a08:	8f ef       	ldi	r24, 0xFF	; 255
    3a0a:	86 8f       	std	Z+30, r24	; 0x1e

				/* Likewise ensure the event queues start with the correct state. */
				vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
    3a0c:	8d 81       	ldd	r24, Y+5	; 0x05
    3a0e:	9e 81       	ldd	r25, Y+6	; 0x06
    3a10:	08 96       	adiw	r24, 0x08	; 8
    3a12:	0e 94 7d 17 	call	0x2efa	; 0x2efa <vListInitialise>
				vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
    3a16:	8d 81       	ldd	r24, Y+5	; 0x05
    3a18:	9e 81       	ldd	r25, Y+6	; 0x06
    3a1a:	41 96       	adiw	r24, 0x11	; 17
    3a1c:	0e 94 7d 17 	call	0x2efa	; 0x2efa <vListInitialise>

				traceQUEUE_CREATE( pxNewQueue );
				xReturn = pxNewQueue;
    3a20:	8d 81       	ldd	r24, Y+5	; 0x05
    3a22:	9e 81       	ldd	r25, Y+6	; 0x06
    3a24:	9a 83       	std	Y+2, r25	; 0x02
    3a26:	89 83       	std	Y+1, r24	; 0x01
    3a28:	04 c0       	rjmp	.+8      	; 0x3a32 <xQueueCreate+0x13c>
			}
			else
			{
				traceQUEUE_CREATE_FAILED();
				vPortFree( pxNewQueue );
    3a2a:	8d 81       	ldd	r24, Y+5	; 0x05
    3a2c:	9e 81       	ldd	r25, Y+6	; 0x06
    3a2e:	0e 94 57 17 	call	0x2eae	; 0x2eae <vPortFree>
		}
	}

	configASSERT( xReturn );

	return xReturn;
    3a32:	89 81       	ldd	r24, Y+1	; 0x01
    3a34:	9a 81       	ldd	r25, Y+2	; 0x02
}
    3a36:	28 96       	adiw	r28, 0x08	; 8
    3a38:	0f b6       	in	r0, 0x3f	; 63
    3a3a:	f8 94       	cli
    3a3c:	de bf       	out	0x3e, r29	; 62
    3a3e:	0f be       	out	0x3f, r0	; 63
    3a40:	cd bf       	out	0x3d, r28	; 61
    3a42:	cf 91       	pop	r28
    3a44:	df 91       	pop	r29
    3a46:	08 95       	ret

00003a48 <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
    3a48:	df 93       	push	r29
    3a4a:	cf 93       	push	r28
    3a4c:	cd b7       	in	r28, 0x3d	; 61
    3a4e:	de b7       	in	r29, 0x3e	; 62
    3a50:	2c 97       	sbiw	r28, 0x0c	; 12
    3a52:	0f b6       	in	r0, 0x3f	; 63
    3a54:	f8 94       	cli
    3a56:	de bf       	out	0x3e, r29	; 62
    3a58:	0f be       	out	0x3f, r0	; 63
    3a5a:	cd bf       	out	0x3d, r28	; 61
    3a5c:	9e 83       	std	Y+6, r25	; 0x06
    3a5e:	8d 83       	std	Y+5, r24	; 0x05
    3a60:	78 87       	std	Y+8, r23	; 0x08
    3a62:	6f 83       	std	Y+7, r22	; 0x07
    3a64:	5a 87       	std	Y+10, r21	; 0x0a
    3a66:	49 87       	std	Y+9, r20	; 0x09
    3a68:	2b 87       	std	Y+11, r18	; 0x0b
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
    3a6a:	19 82       	std	Y+1, r1	; 0x01
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    3a6c:	0f b6       	in	r0, 0x3f	; 63
    3a6e:	f8 94       	cli
    3a70:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    3a72:	ed 81       	ldd	r30, Y+5	; 0x05
    3a74:	fe 81       	ldd	r31, Y+6	; 0x06
    3a76:	92 8d       	ldd	r25, Z+26	; 0x1a
    3a78:	ed 81       	ldd	r30, Y+5	; 0x05
    3a7a:	fe 81       	ldd	r31, Y+6	; 0x06
    3a7c:	83 8d       	ldd	r24, Z+27	; 0x1b
    3a7e:	98 17       	cp	r25, r24
    3a80:	d8 f4       	brcc	.+54     	; 0x3ab8 <xQueueGenericSend+0x70>
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    3a82:	8d 81       	ldd	r24, Y+5	; 0x05
    3a84:	9e 81       	ldd	r25, Y+6	; 0x06
    3a86:	2f 81       	ldd	r18, Y+7	; 0x07
    3a88:	38 85       	ldd	r19, Y+8	; 0x08
    3a8a:	b9 01       	movw	r22, r18
    3a8c:	4b 85       	ldd	r20, Y+11	; 0x0b
    3a8e:	0e 94 5f 1f 	call	0x3ebe	; 0x3ebe <prvCopyDataToQueue>

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    3a92:	ed 81       	ldd	r30, Y+5	; 0x05
    3a94:	fe 81       	ldd	r31, Y+6	; 0x06
    3a96:	81 89       	ldd	r24, Z+17	; 0x11
    3a98:	88 23       	and	r24, r24
    3a9a:	49 f0       	breq	.+18     	; 0x3aae <xQueueGenericSend+0x66>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
    3a9c:	8d 81       	ldd	r24, Y+5	; 0x05
    3a9e:	9e 81       	ldd	r25, Y+6	; 0x06
    3aa0:	41 96       	adiw	r24, 0x11	; 17
    3aa2:	0e 94 74 25 	call	0x4ae8	; 0x4ae8 <xTaskRemoveFromEventList>
    3aa6:	81 30       	cpi	r24, 0x01	; 1
    3aa8:	11 f4       	brne	.+4      	; 0x3aae <xQueueGenericSend+0x66>
					{
						/* The unblocked task has a priority higher than
						our own so yield immediately.  Yes it is ok to do
						this from within the critical section - the kernel
						takes care of that. */
						portYIELD_WITHIN_API();
    3aaa:	0e 94 68 1b 	call	0x36d0	; 0x36d0 <vPortYield>
					}
				}

				taskEXIT_CRITICAL();
    3aae:	0f 90       	pop	r0
    3ab0:	0f be       	out	0x3f, r0	; 63

				/* Return to the original privilege level before exiting the
				function. */
				return pdPASS;
    3ab2:	81 e0       	ldi	r24, 0x01	; 1
    3ab4:	8c 87       	std	Y+12, r24	; 0x0c
    3ab6:	5c c0       	rjmp	.+184    	; 0x3b70 <xQueueGenericSend+0x128>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
    3ab8:	89 85       	ldd	r24, Y+9	; 0x09
    3aba:	9a 85       	ldd	r25, Y+10	; 0x0a
    3abc:	00 97       	sbiw	r24, 0x00	; 0
    3abe:	21 f4       	brne	.+8      	; 0x3ac8 <xQueueGenericSend+0x80>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    3ac0:	0f 90       	pop	r0
    3ac2:	0f be       	out	0x3f, r0	; 63

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
    3ac4:	1c 86       	std	Y+12, r1	; 0x0c
    3ac6:	54 c0       	rjmp	.+168    	; 0x3b70 <xQueueGenericSend+0x128>
				}
				else if( xEntryTimeSet == pdFALSE )
    3ac8:	89 81       	ldd	r24, Y+1	; 0x01
    3aca:	88 23       	and	r24, r24
    3acc:	31 f4       	brne	.+12     	; 0x3ada <xQueueGenericSend+0x92>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    3ace:	ce 01       	movw	r24, r28
    3ad0:	02 96       	adiw	r24, 0x02	; 2
    3ad2:	0e 94 dc 25 	call	0x4bb8	; 0x4bb8 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    3ad6:	81 e0       	ldi	r24, 0x01	; 1
    3ad8:	89 83       	std	Y+1, r24	; 0x01
				}
			}
		}
		taskEXIT_CRITICAL();
    3ada:	0f 90       	pop	r0
    3adc:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    3ade:	0e 94 38 23 	call	0x4670	; 0x4670 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    3ae2:	0f b6       	in	r0, 0x3f	; 63
    3ae4:	f8 94       	cli
    3ae6:	0f 92       	push	r0
    3ae8:	ed 81       	ldd	r30, Y+5	; 0x05
    3aea:	fe 81       	ldd	r31, Y+6	; 0x06
    3aec:	85 8d       	ldd	r24, Z+29	; 0x1d
    3aee:	8f 3f       	cpi	r24, 0xFF	; 255
    3af0:	19 f4       	brne	.+6      	; 0x3af8 <xQueueGenericSend+0xb0>
    3af2:	ed 81       	ldd	r30, Y+5	; 0x05
    3af4:	fe 81       	ldd	r31, Y+6	; 0x06
    3af6:	15 8e       	std	Z+29, r1	; 0x1d
    3af8:	ed 81       	ldd	r30, Y+5	; 0x05
    3afa:	fe 81       	ldd	r31, Y+6	; 0x06
    3afc:	86 8d       	ldd	r24, Z+30	; 0x1e
    3afe:	8f 3f       	cpi	r24, 0xFF	; 255
    3b00:	19 f4       	brne	.+6      	; 0x3b08 <xQueueGenericSend+0xc0>
    3b02:	ed 81       	ldd	r30, Y+5	; 0x05
    3b04:	fe 81       	ldd	r31, Y+6	; 0x06
    3b06:	16 8e       	std	Z+30, r1	; 0x1e
    3b08:	0f 90       	pop	r0
    3b0a:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    3b0c:	ce 01       	movw	r24, r28
    3b0e:	02 96       	adiw	r24, 0x02	; 2
    3b10:	9e 01       	movw	r18, r28
    3b12:	27 5f       	subi	r18, 0xF7	; 247
    3b14:	3f 4f       	sbci	r19, 0xFF	; 255
    3b16:	b9 01       	movw	r22, r18
    3b18:	0e 94 f5 25 	call	0x4bea	; 0x4bea <xTaskCheckForTimeOut>
    3b1c:	88 23       	and	r24, r24
    3b1e:	09 f5       	brne	.+66     	; 0x3b62 <xQueueGenericSend+0x11a>
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    3b20:	8d 81       	ldd	r24, Y+5	; 0x05
    3b22:	9e 81       	ldd	r25, Y+6	; 0x06
    3b24:	0e 94 c3 20 	call	0x4186	; 0x4186 <prvIsQueueFull>
    3b28:	88 23       	and	r24, r24
    3b2a:	a1 f0       	breq	.+40     	; 0x3b54 <xQueueGenericSend+0x10c>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    3b2c:	8d 81       	ldd	r24, Y+5	; 0x05
    3b2e:	9e 81       	ldd	r25, Y+6	; 0x06
    3b30:	08 96       	adiw	r24, 0x08	; 8
    3b32:	29 85       	ldd	r18, Y+9	; 0x09
    3b34:	3a 85       	ldd	r19, Y+10	; 0x0a
    3b36:	b9 01       	movw	r22, r18
    3b38:	0e 94 3e 25 	call	0x4a7c	; 0x4a7c <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    3b3c:	8d 81       	ldd	r24, Y+5	; 0x05
    3b3e:	9e 81       	ldd	r25, Y+6	; 0x06
    3b40:	0e 94 3c 20 	call	0x4078	; 0x4078 <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
    3b44:	0e 94 44 23 	call	0x4688	; 0x4688 <xTaskResumeAll>
    3b48:	88 23       	and	r24, r24
    3b4a:	09 f0       	breq	.+2      	; 0x3b4e <xQueueGenericSend+0x106>
    3b4c:	8f cf       	rjmp	.-226    	; 0x3a6c <xQueueGenericSend+0x24>
				{
					portYIELD_WITHIN_API();
    3b4e:	0e 94 68 1b 	call	0x36d0	; 0x36d0 <vPortYield>
    3b52:	8c cf       	rjmp	.-232    	; 0x3a6c <xQueueGenericSend+0x24>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    3b54:	8d 81       	ldd	r24, Y+5	; 0x05
    3b56:	9e 81       	ldd	r25, Y+6	; 0x06
    3b58:	0e 94 3c 20 	call	0x4078	; 0x4078 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    3b5c:	0e 94 44 23 	call	0x4688	; 0x4688 <xTaskResumeAll>
    3b60:	85 cf       	rjmp	.-246    	; 0x3a6c <xQueueGenericSend+0x24>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    3b62:	8d 81       	ldd	r24, Y+5	; 0x05
    3b64:	9e 81       	ldd	r25, Y+6	; 0x06
    3b66:	0e 94 3c 20 	call	0x4078	; 0x4078 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    3b6a:	0e 94 44 23 	call	0x4688	; 0x4688 <xTaskResumeAll>

			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    3b6e:	1c 86       	std	Y+12, r1	; 0x0c
    3b70:	8c 85       	ldd	r24, Y+12	; 0x0c
		}
	}
}
    3b72:	2c 96       	adiw	r28, 0x0c	; 12
    3b74:	0f b6       	in	r0, 0x3f	; 63
    3b76:	f8 94       	cli
    3b78:	de bf       	out	0x3e, r29	; 62
    3b7a:	0f be       	out	0x3f, r0	; 63
    3b7c:	cd bf       	out	0x3d, r28	; 61
    3b7e:	cf 91       	pop	r28
    3b80:	df 91       	pop	r29
    3b82:	08 95       	ret

00003b84 <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
    3b84:	df 93       	push	r29
    3b86:	cf 93       	push	r28
    3b88:	cd b7       	in	r28, 0x3d	; 61
    3b8a:	de b7       	in	r29, 0x3e	; 62
    3b8c:	29 97       	sbiw	r28, 0x09	; 9
    3b8e:	0f b6       	in	r0, 0x3f	; 63
    3b90:	f8 94       	cli
    3b92:	de bf       	out	0x3e, r29	; 62
    3b94:	0f be       	out	0x3f, r0	; 63
    3b96:	cd bf       	out	0x3d, r28	; 61
    3b98:	9c 83       	std	Y+4, r25	; 0x04
    3b9a:	8b 83       	std	Y+3, r24	; 0x03
    3b9c:	7e 83       	std	Y+6, r23	; 0x06
    3b9e:	6d 83       	std	Y+5, r22	; 0x05
    3ba0:	58 87       	std	Y+8, r21	; 0x08
    3ba2:	4f 83       	std	Y+7, r20	; 0x07
    3ba4:	29 87       	std	Y+9, r18	; 0x09
	/* Similar to xQueueGenericSend, except we don't block if there is no room
	in the queue.  Also we don't directly wake a task that was blocked on a
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    3ba6:	19 82       	std	Y+1, r1	; 0x01
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    3ba8:	eb 81       	ldd	r30, Y+3	; 0x03
    3baa:	fc 81       	ldd	r31, Y+4	; 0x04
    3bac:	92 8d       	ldd	r25, Z+26	; 0x1a
    3bae:	eb 81       	ldd	r30, Y+3	; 0x03
    3bb0:	fc 81       	ldd	r31, Y+4	; 0x04
    3bb2:	83 8d       	ldd	r24, Z+27	; 0x1b
    3bb4:	98 17       	cp	r25, r24
    3bb6:	40 f5       	brcc	.+80     	; 0x3c08 <xQueueGenericSendFromISR+0x84>
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    3bb8:	8b 81       	ldd	r24, Y+3	; 0x03
    3bba:	9c 81       	ldd	r25, Y+4	; 0x04
    3bbc:	2d 81       	ldd	r18, Y+5	; 0x05
    3bbe:	3e 81       	ldd	r19, Y+6	; 0x06
    3bc0:	b9 01       	movw	r22, r18
    3bc2:	49 85       	ldd	r20, Y+9	; 0x09
    3bc4:	0e 94 5f 1f 	call	0x3ebe	; 0x3ebe <prvCopyDataToQueue>

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
    3bc8:	eb 81       	ldd	r30, Y+3	; 0x03
    3bca:	fc 81       	ldd	r31, Y+4	; 0x04
    3bcc:	86 8d       	ldd	r24, Z+30	; 0x1e
    3bce:	8f 3f       	cpi	r24, 0xFF	; 255
    3bd0:	89 f4       	brne	.+34     	; 0x3bf4 <xQueueGenericSendFromISR+0x70>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    3bd2:	eb 81       	ldd	r30, Y+3	; 0x03
    3bd4:	fc 81       	ldd	r31, Y+4	; 0x04
    3bd6:	81 89       	ldd	r24, Z+17	; 0x11
    3bd8:	88 23       	and	r24, r24
    3bda:	99 f0       	breq	.+38     	; 0x3c02 <xQueueGenericSendFromISR+0x7e>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    3bdc:	8b 81       	ldd	r24, Y+3	; 0x03
    3bde:	9c 81       	ldd	r25, Y+4	; 0x04
    3be0:	41 96       	adiw	r24, 0x11	; 17
    3be2:	0e 94 74 25 	call	0x4ae8	; 0x4ae8 <xTaskRemoveFromEventList>
    3be6:	88 23       	and	r24, r24
    3be8:	61 f0       	breq	.+24     	; 0x3c02 <xQueueGenericSendFromISR+0x7e>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						*pxHigherPriorityTaskWoken = pdTRUE;
    3bea:	ef 81       	ldd	r30, Y+7	; 0x07
    3bec:	f8 85       	ldd	r31, Y+8	; 0x08
    3bee:	81 e0       	ldi	r24, 0x01	; 1
    3bf0:	80 83       	st	Z, r24
    3bf2:	07 c0       	rjmp	.+14     	; 0x3c02 <xQueueGenericSendFromISR+0x7e>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
    3bf4:	eb 81       	ldd	r30, Y+3	; 0x03
    3bf6:	fc 81       	ldd	r31, Y+4	; 0x04
    3bf8:	86 8d       	ldd	r24, Z+30	; 0x1e
    3bfa:	8f 5f       	subi	r24, 0xFF	; 255
    3bfc:	eb 81       	ldd	r30, Y+3	; 0x03
    3bfe:	fc 81       	ldd	r31, Y+4	; 0x04
    3c00:	86 8f       	std	Z+30, r24	; 0x1e
			}

			xReturn = pdPASS;
    3c02:	81 e0       	ldi	r24, 0x01	; 1
    3c04:	8a 83       	std	Y+2, r24	; 0x02
    3c06:	01 c0       	rjmp	.+2      	; 0x3c0a <xQueueGenericSendFromISR+0x86>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    3c08:	1a 82       	std	Y+2, r1	; 0x02
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    3c0a:	8a 81       	ldd	r24, Y+2	; 0x02
}
    3c0c:	29 96       	adiw	r28, 0x09	; 9
    3c0e:	0f b6       	in	r0, 0x3f	; 63
    3c10:	f8 94       	cli
    3c12:	de bf       	out	0x3e, r29	; 62
    3c14:	0f be       	out	0x3f, r0	; 63
    3c16:	cd bf       	out	0x3d, r28	; 61
    3c18:	cf 91       	pop	r28
    3c1a:	df 91       	pop	r29
    3c1c:	08 95       	ret

00003c1e <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
    3c1e:	df 93       	push	r29
    3c20:	cf 93       	push	r28
    3c22:	cd b7       	in	r28, 0x3d	; 61
    3c24:	de b7       	in	r29, 0x3e	; 62
    3c26:	2e 97       	sbiw	r28, 0x0e	; 14
    3c28:	0f b6       	in	r0, 0x3f	; 63
    3c2a:	f8 94       	cli
    3c2c:	de bf       	out	0x3e, r29	; 62
    3c2e:	0f be       	out	0x3f, r0	; 63
    3c30:	cd bf       	out	0x3d, r28	; 61
    3c32:	98 87       	std	Y+8, r25	; 0x08
    3c34:	8f 83       	std	Y+7, r24	; 0x07
    3c36:	7a 87       	std	Y+10, r23	; 0x0a
    3c38:	69 87       	std	Y+9, r22	; 0x09
    3c3a:	5c 87       	std	Y+12, r21	; 0x0c
    3c3c:	4b 87       	std	Y+11, r20	; 0x0b
    3c3e:	2d 87       	std	Y+13, r18	; 0x0d
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
    3c40:	1b 82       	std	Y+3, r1	; 0x03
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    3c42:	0f b6       	in	r0, 0x3f	; 63
    3c44:	f8 94       	cli
    3c46:	0f 92       	push	r0
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    3c48:	ef 81       	ldd	r30, Y+7	; 0x07
    3c4a:	f8 85       	ldd	r31, Y+8	; 0x08
    3c4c:	82 8d       	ldd	r24, Z+26	; 0x1a
    3c4e:	88 23       	and	r24, r24
    3c50:	09 f4       	brne	.+2      	; 0x3c54 <xQueueGenericReceive+0x36>
    3c52:	3f c0       	rjmp	.+126    	; 0x3cd2 <xQueueGenericReceive+0xb4>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
    3c54:	ef 81       	ldd	r30, Y+7	; 0x07
    3c56:	f8 85       	ldd	r31, Y+8	; 0x08
    3c58:	86 81       	ldd	r24, Z+6	; 0x06
    3c5a:	97 81       	ldd	r25, Z+7	; 0x07
    3c5c:	9a 83       	std	Y+2, r25	; 0x02
    3c5e:	89 83       	std	Y+1, r24	; 0x01

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    3c60:	8f 81       	ldd	r24, Y+7	; 0x07
    3c62:	98 85       	ldd	r25, Y+8	; 0x08
    3c64:	29 85       	ldd	r18, Y+9	; 0x09
    3c66:	3a 85       	ldd	r19, Y+10	; 0x0a
    3c68:	b9 01       	movw	r22, r18
    3c6a:	0e 94 f4 1f 	call	0x3fe8	; 0x3fe8 <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
    3c6e:	8d 85       	ldd	r24, Y+13	; 0x0d
    3c70:	88 23       	and	r24, r24
    3c72:	b1 f4       	brne	.+44     	; 0x3ca0 <xQueueGenericReceive+0x82>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
    3c74:	ef 81       	ldd	r30, Y+7	; 0x07
    3c76:	f8 85       	ldd	r31, Y+8	; 0x08
    3c78:	82 8d       	ldd	r24, Z+26	; 0x1a
    3c7a:	81 50       	subi	r24, 0x01	; 1
    3c7c:	ef 81       	ldd	r30, Y+7	; 0x07
    3c7e:	f8 85       	ldd	r31, Y+8	; 0x08
    3c80:	82 8f       	std	Z+26, r24	; 0x1a
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    3c82:	ef 81       	ldd	r30, Y+7	; 0x07
    3c84:	f8 85       	ldd	r31, Y+8	; 0x08
    3c86:	80 85       	ldd	r24, Z+8	; 0x08
    3c88:	88 23       	and	r24, r24
    3c8a:	f1 f0       	breq	.+60     	; 0x3cc8 <xQueueGenericReceive+0xaa>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    3c8c:	8f 81       	ldd	r24, Y+7	; 0x07
    3c8e:	98 85       	ldd	r25, Y+8	; 0x08
    3c90:	08 96       	adiw	r24, 0x08	; 8
    3c92:	0e 94 74 25 	call	0x4ae8	; 0x4ae8 <xTaskRemoveFromEventList>
    3c96:	81 30       	cpi	r24, 0x01	; 1
    3c98:	b9 f4       	brne	.+46     	; 0x3cc8 <xQueueGenericReceive+0xaa>
						{
							portYIELD_WITHIN_API();
    3c9a:	0e 94 68 1b 	call	0x36d0	; 0x36d0 <vPortYield>
    3c9e:	14 c0       	rjmp	.+40     	; 0x3cc8 <xQueueGenericReceive+0xaa>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
    3ca0:	ef 81       	ldd	r30, Y+7	; 0x07
    3ca2:	f8 85       	ldd	r31, Y+8	; 0x08
    3ca4:	89 81       	ldd	r24, Y+1	; 0x01
    3ca6:	9a 81       	ldd	r25, Y+2	; 0x02
    3ca8:	97 83       	std	Z+7, r25	; 0x07
    3caa:	86 83       	std	Z+6, r24	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    3cac:	ef 81       	ldd	r30, Y+7	; 0x07
    3cae:	f8 85       	ldd	r31, Y+8	; 0x08
    3cb0:	81 89       	ldd	r24, Z+17	; 0x11
    3cb2:	88 23       	and	r24, r24
    3cb4:	49 f0       	breq	.+18     	; 0x3cc8 <xQueueGenericReceive+0xaa>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    3cb6:	8f 81       	ldd	r24, Y+7	; 0x07
    3cb8:	98 85       	ldd	r25, Y+8	; 0x08
    3cba:	41 96       	adiw	r24, 0x11	; 17
    3cbc:	0e 94 74 25 	call	0x4ae8	; 0x4ae8 <xTaskRemoveFromEventList>
    3cc0:	88 23       	and	r24, r24
    3cc2:	11 f0       	breq	.+4      	; 0x3cc8 <xQueueGenericReceive+0xaa>
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
    3cc4:	0e 94 68 1b 	call	0x36d0	; 0x36d0 <vPortYield>
						}
					}

				}

				taskEXIT_CRITICAL();
    3cc8:	0f 90       	pop	r0
    3cca:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    3ccc:	81 e0       	ldi	r24, 0x01	; 1
    3cce:	8e 87       	std	Y+14, r24	; 0x0e
    3cd0:	5c c0       	rjmp	.+184    	; 0x3d8a <xQueueGenericReceive+0x16c>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
    3cd2:	8b 85       	ldd	r24, Y+11	; 0x0b
    3cd4:	9c 85       	ldd	r25, Y+12	; 0x0c
    3cd6:	00 97       	sbiw	r24, 0x00	; 0
    3cd8:	21 f4       	brne	.+8      	; 0x3ce2 <xQueueGenericReceive+0xc4>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    3cda:	0f 90       	pop	r0
    3cdc:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    3cde:	1e 86       	std	Y+14, r1	; 0x0e
    3ce0:	54 c0       	rjmp	.+168    	; 0x3d8a <xQueueGenericReceive+0x16c>
				}
				else if( xEntryTimeSet == pdFALSE )
    3ce2:	8b 81       	ldd	r24, Y+3	; 0x03
    3ce4:	88 23       	and	r24, r24
    3ce6:	31 f4       	brne	.+12     	; 0x3cf4 <xQueueGenericReceive+0xd6>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    3ce8:	ce 01       	movw	r24, r28
    3cea:	04 96       	adiw	r24, 0x04	; 4
    3cec:	0e 94 dc 25 	call	0x4bb8	; 0x4bb8 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    3cf0:	81 e0       	ldi	r24, 0x01	; 1
    3cf2:	8b 83       	std	Y+3, r24	; 0x03
				}
			}
		}
		taskEXIT_CRITICAL();
    3cf4:	0f 90       	pop	r0
    3cf6:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    3cf8:	0e 94 38 23 	call	0x4670	; 0x4670 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    3cfc:	0f b6       	in	r0, 0x3f	; 63
    3cfe:	f8 94       	cli
    3d00:	0f 92       	push	r0
    3d02:	ef 81       	ldd	r30, Y+7	; 0x07
    3d04:	f8 85       	ldd	r31, Y+8	; 0x08
    3d06:	85 8d       	ldd	r24, Z+29	; 0x1d
    3d08:	8f 3f       	cpi	r24, 0xFF	; 255
    3d0a:	19 f4       	brne	.+6      	; 0x3d12 <xQueueGenericReceive+0xf4>
    3d0c:	ef 81       	ldd	r30, Y+7	; 0x07
    3d0e:	f8 85       	ldd	r31, Y+8	; 0x08
    3d10:	15 8e       	std	Z+29, r1	; 0x1d
    3d12:	ef 81       	ldd	r30, Y+7	; 0x07
    3d14:	f8 85       	ldd	r31, Y+8	; 0x08
    3d16:	86 8d       	ldd	r24, Z+30	; 0x1e
    3d18:	8f 3f       	cpi	r24, 0xFF	; 255
    3d1a:	19 f4       	brne	.+6      	; 0x3d22 <xQueueGenericReceive+0x104>
    3d1c:	ef 81       	ldd	r30, Y+7	; 0x07
    3d1e:	f8 85       	ldd	r31, Y+8	; 0x08
    3d20:	16 8e       	std	Z+30, r1	; 0x1e
    3d22:	0f 90       	pop	r0
    3d24:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    3d26:	ce 01       	movw	r24, r28
    3d28:	04 96       	adiw	r24, 0x04	; 4
    3d2a:	9e 01       	movw	r18, r28
    3d2c:	25 5f       	subi	r18, 0xF5	; 245
    3d2e:	3f 4f       	sbci	r19, 0xFF	; 255
    3d30:	b9 01       	movw	r22, r18
    3d32:	0e 94 f5 25 	call	0x4bea	; 0x4bea <xTaskCheckForTimeOut>
    3d36:	88 23       	and	r24, r24
    3d38:	09 f5       	brne	.+66     	; 0x3d7c <xQueueGenericReceive+0x15e>
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    3d3a:	8f 81       	ldd	r24, Y+7	; 0x07
    3d3c:	98 85       	ldd	r25, Y+8	; 0x08
    3d3e:	0e 94 90 20 	call	0x4120	; 0x4120 <prvIsQueueEmpty>
    3d42:	88 23       	and	r24, r24
    3d44:	a1 f0       	breq	.+40     	; 0x3d6e <xQueueGenericReceive+0x150>
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    3d46:	8f 81       	ldd	r24, Y+7	; 0x07
    3d48:	98 85       	ldd	r25, Y+8	; 0x08
    3d4a:	41 96       	adiw	r24, 0x11	; 17
    3d4c:	2b 85       	ldd	r18, Y+11	; 0x0b
    3d4e:	3c 85       	ldd	r19, Y+12	; 0x0c
    3d50:	b9 01       	movw	r22, r18
    3d52:	0e 94 3e 25 	call	0x4a7c	; 0x4a7c <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    3d56:	8f 81       	ldd	r24, Y+7	; 0x07
    3d58:	98 85       	ldd	r25, Y+8	; 0x08
    3d5a:	0e 94 3c 20 	call	0x4078	; 0x4078 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    3d5e:	0e 94 44 23 	call	0x4688	; 0x4688 <xTaskResumeAll>
    3d62:	88 23       	and	r24, r24
    3d64:	09 f0       	breq	.+2      	; 0x3d68 <xQueueGenericReceive+0x14a>
    3d66:	6d cf       	rjmp	.-294    	; 0x3c42 <xQueueGenericReceive+0x24>
				{
					portYIELD_WITHIN_API();
    3d68:	0e 94 68 1b 	call	0x36d0	; 0x36d0 <vPortYield>
    3d6c:	6a cf       	rjmp	.-300    	; 0x3c42 <xQueueGenericReceive+0x24>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    3d6e:	8f 81       	ldd	r24, Y+7	; 0x07
    3d70:	98 85       	ldd	r25, Y+8	; 0x08
    3d72:	0e 94 3c 20 	call	0x4078	; 0x4078 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    3d76:	0e 94 44 23 	call	0x4688	; 0x4688 <xTaskResumeAll>
    3d7a:	63 cf       	rjmp	.-314    	; 0x3c42 <xQueueGenericReceive+0x24>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
    3d7c:	8f 81       	ldd	r24, Y+7	; 0x07
    3d7e:	98 85       	ldd	r25, Y+8	; 0x08
    3d80:	0e 94 3c 20 	call	0x4078	; 0x4078 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    3d84:	0e 94 44 23 	call	0x4688	; 0x4688 <xTaskResumeAll>
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
    3d88:	1e 86       	std	Y+14, r1	; 0x0e
    3d8a:	8e 85       	ldd	r24, Y+14	; 0x0e
		}
	}
}
    3d8c:	2e 96       	adiw	r28, 0x0e	; 14
    3d8e:	0f b6       	in	r0, 0x3f	; 63
    3d90:	f8 94       	cli
    3d92:	de bf       	out	0x3e, r29	; 62
    3d94:	0f be       	out	0x3f, r0	; 63
    3d96:	cd bf       	out	0x3d, r28	; 61
    3d98:	cf 91       	pop	r28
    3d9a:	df 91       	pop	r29
    3d9c:	08 95       	ret

00003d9e <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed portBASE_TYPE *pxTaskWoken )
{
    3d9e:	df 93       	push	r29
    3da0:	cf 93       	push	r28
    3da2:	cd b7       	in	r28, 0x3d	; 61
    3da4:	de b7       	in	r29, 0x3e	; 62
    3da6:	28 97       	sbiw	r28, 0x08	; 8
    3da8:	0f b6       	in	r0, 0x3f	; 63
    3daa:	f8 94       	cli
    3dac:	de bf       	out	0x3e, r29	; 62
    3dae:	0f be       	out	0x3f, r0	; 63
    3db0:	cd bf       	out	0x3d, r28	; 61
    3db2:	9c 83       	std	Y+4, r25	; 0x04
    3db4:	8b 83       	std	Y+3, r24	; 0x03
    3db6:	7e 83       	std	Y+6, r23	; 0x06
    3db8:	6d 83       	std	Y+5, r22	; 0x05
    3dba:	58 87       	std	Y+8, r21	; 0x08
    3dbc:	4f 83       	std	Y+7, r20	; 0x07

	configASSERT( pxQueue );
	configASSERT( pxTaskWoken );
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    3dbe:	19 82       	std	Y+1, r1	; 0x01
	{
		/* We cannot block from an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    3dc0:	eb 81       	ldd	r30, Y+3	; 0x03
    3dc2:	fc 81       	ldd	r31, Y+4	; 0x04
    3dc4:	82 8d       	ldd	r24, Z+26	; 0x1a
    3dc6:	88 23       	and	r24, r24
    3dc8:	71 f1       	breq	.+92     	; 0x3e26 <xQueueReceiveFromISR+0x88>
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
    3dca:	8b 81       	ldd	r24, Y+3	; 0x03
    3dcc:	9c 81       	ldd	r25, Y+4	; 0x04
    3dce:	2d 81       	ldd	r18, Y+5	; 0x05
    3dd0:	3e 81       	ldd	r19, Y+6	; 0x06
    3dd2:	b9 01       	movw	r22, r18
    3dd4:	0e 94 f4 1f 	call	0x3fe8	; 0x3fe8 <prvCopyDataFromQueue>
			--( pxQueue->uxMessagesWaiting );
    3dd8:	eb 81       	ldd	r30, Y+3	; 0x03
    3dda:	fc 81       	ldd	r31, Y+4	; 0x04
    3ddc:	82 8d       	ldd	r24, Z+26	; 0x1a
    3dde:	81 50       	subi	r24, 0x01	; 1
    3de0:	eb 81       	ldd	r30, Y+3	; 0x03
    3de2:	fc 81       	ldd	r31, Y+4	; 0x04
    3de4:	82 8f       	std	Z+26, r24	; 0x1a

			/* If the queue is locked we will not modify the event list.  Instead
			we update the lock count so the task that unlocks the queue will know
			that an ISR has removed data while the queue was locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
    3de6:	eb 81       	ldd	r30, Y+3	; 0x03
    3de8:	fc 81       	ldd	r31, Y+4	; 0x04
    3dea:	85 8d       	ldd	r24, Z+29	; 0x1d
    3dec:	8f 3f       	cpi	r24, 0xFF	; 255
    3dee:	89 f4       	brne	.+34     	; 0x3e12 <xQueueReceiveFromISR+0x74>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    3df0:	eb 81       	ldd	r30, Y+3	; 0x03
    3df2:	fc 81       	ldd	r31, Y+4	; 0x04
    3df4:	80 85       	ldd	r24, Z+8	; 0x08
    3df6:	88 23       	and	r24, r24
    3df8:	99 f0       	breq	.+38     	; 0x3e20 <xQueueReceiveFromISR+0x82>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    3dfa:	8b 81       	ldd	r24, Y+3	; 0x03
    3dfc:	9c 81       	ldd	r25, Y+4	; 0x04
    3dfe:	08 96       	adiw	r24, 0x08	; 8
    3e00:	0e 94 74 25 	call	0x4ae8	; 0x4ae8 <xTaskRemoveFromEventList>
    3e04:	88 23       	and	r24, r24
    3e06:	61 f0       	breq	.+24     	; 0x3e20 <xQueueReceiveFromISR+0x82>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						*pxTaskWoken = pdTRUE;
    3e08:	ef 81       	ldd	r30, Y+7	; 0x07
    3e0a:	f8 85       	ldd	r31, Y+8	; 0x08
    3e0c:	81 e0       	ldi	r24, 0x01	; 1
    3e0e:	80 83       	st	Z, r24
    3e10:	07 c0       	rjmp	.+14     	; 0x3e20 <xQueueReceiveFromISR+0x82>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
    3e12:	eb 81       	ldd	r30, Y+3	; 0x03
    3e14:	fc 81       	ldd	r31, Y+4	; 0x04
    3e16:	85 8d       	ldd	r24, Z+29	; 0x1d
    3e18:	8f 5f       	subi	r24, 0xFF	; 255
    3e1a:	eb 81       	ldd	r30, Y+3	; 0x03
    3e1c:	fc 81       	ldd	r31, Y+4	; 0x04
    3e1e:	85 8f       	std	Z+29, r24	; 0x1d
			}

			xReturn = pdPASS;
    3e20:	81 e0       	ldi	r24, 0x01	; 1
    3e22:	8a 83       	std	Y+2, r24	; 0x02
    3e24:	01 c0       	rjmp	.+2      	; 0x3e28 <xQueueReceiveFromISR+0x8a>
		}
		else
		{
			xReturn = pdFAIL;
    3e26:	1a 82       	std	Y+2, r1	; 0x02
			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    3e28:	8a 81       	ldd	r24, Y+2	; 0x02
}
    3e2a:	28 96       	adiw	r28, 0x08	; 8
    3e2c:	0f b6       	in	r0, 0x3f	; 63
    3e2e:	f8 94       	cli
    3e30:	de bf       	out	0x3e, r29	; 62
    3e32:	0f be       	out	0x3f, r0	; 63
    3e34:	cd bf       	out	0x3d, r28	; 61
    3e36:	cf 91       	pop	r28
    3e38:	df 91       	pop	r29
    3e3a:	08 95       	ret

00003e3c <uxQueueMessagesWaiting>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxQueueMessagesWaiting( const xQueueHandle pxQueue )
{
    3e3c:	df 93       	push	r29
    3e3e:	cf 93       	push	r28
    3e40:	00 d0       	rcall	.+0      	; 0x3e42 <uxQueueMessagesWaiting+0x6>
    3e42:	0f 92       	push	r0
    3e44:	cd b7       	in	r28, 0x3d	; 61
    3e46:	de b7       	in	r29, 0x3e	; 62
    3e48:	9b 83       	std	Y+3, r25	; 0x03
    3e4a:	8a 83       	std	Y+2, r24	; 0x02
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    3e4c:	0f b6       	in	r0, 0x3f	; 63
    3e4e:	f8 94       	cli
    3e50:	0f 92       	push	r0
		uxReturn = pxQueue->uxMessagesWaiting;
    3e52:	ea 81       	ldd	r30, Y+2	; 0x02
    3e54:	fb 81       	ldd	r31, Y+3	; 0x03
    3e56:	82 8d       	ldd	r24, Z+26	; 0x1a
    3e58:	89 83       	std	Y+1, r24	; 0x01
	taskEXIT_CRITICAL();
    3e5a:	0f 90       	pop	r0
    3e5c:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
    3e5e:	89 81       	ldd	r24, Y+1	; 0x01
}
    3e60:	0f 90       	pop	r0
    3e62:	0f 90       	pop	r0
    3e64:	0f 90       	pop	r0
    3e66:	cf 91       	pop	r28
    3e68:	df 91       	pop	r29
    3e6a:	08 95       	ret

00003e6c <uxQueueMessagesWaitingFromISR>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxQueueMessagesWaitingFromISR( const xQueueHandle pxQueue )
{
    3e6c:	df 93       	push	r29
    3e6e:	cf 93       	push	r28
    3e70:	00 d0       	rcall	.+0      	; 0x3e72 <uxQueueMessagesWaitingFromISR+0x6>
    3e72:	0f 92       	push	r0
    3e74:	cd b7       	in	r28, 0x3d	; 61
    3e76:	de b7       	in	r29, 0x3e	; 62
    3e78:	9b 83       	std	Y+3, r25	; 0x03
    3e7a:	8a 83       	std	Y+2, r24	; 0x02
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	uxReturn = pxQueue->uxMessagesWaiting;
    3e7c:	ea 81       	ldd	r30, Y+2	; 0x02
    3e7e:	fb 81       	ldd	r31, Y+3	; 0x03
    3e80:	82 8d       	ldd	r24, Z+26	; 0x1a
    3e82:	89 83       	std	Y+1, r24	; 0x01

	return uxReturn;
    3e84:	89 81       	ldd	r24, Y+1	; 0x01
}
    3e86:	0f 90       	pop	r0
    3e88:	0f 90       	pop	r0
    3e8a:	0f 90       	pop	r0
    3e8c:	cf 91       	pop	r28
    3e8e:	df 91       	pop	r29
    3e90:	08 95       	ret

00003e92 <vQueueDelete>:
/*-----------------------------------------------------------*/

void vQueueDelete( xQueueHandle pxQueue )
{
    3e92:	df 93       	push	r29
    3e94:	cf 93       	push	r28
    3e96:	00 d0       	rcall	.+0      	; 0x3e98 <vQueueDelete+0x6>
    3e98:	cd b7       	in	r28, 0x3d	; 61
    3e9a:	de b7       	in	r29, 0x3e	; 62
    3e9c:	9a 83       	std	Y+2, r25	; 0x02
    3e9e:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxQueue );

	traceQUEUE_DELETE( pxQueue );
	vQueueUnregisterQueue( pxQueue );
	vPortFree( pxQueue->pcHead );
    3ea0:	e9 81       	ldd	r30, Y+1	; 0x01
    3ea2:	fa 81       	ldd	r31, Y+2	; 0x02
    3ea4:	80 81       	ld	r24, Z
    3ea6:	91 81       	ldd	r25, Z+1	; 0x01
    3ea8:	0e 94 57 17 	call	0x2eae	; 0x2eae <vPortFree>
	vPortFree( pxQueue );
    3eac:	89 81       	ldd	r24, Y+1	; 0x01
    3eae:	9a 81       	ldd	r25, Y+2	; 0x02
    3eb0:	0e 94 57 17 	call	0x2eae	; 0x2eae <vPortFree>
}
    3eb4:	0f 90       	pop	r0
    3eb6:	0f 90       	pop	r0
    3eb8:	cf 91       	pop	r28
    3eba:	df 91       	pop	r29
    3ebc:	08 95       	ret

00003ebe <prvCopyDataToQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
    3ebe:	df 93       	push	r29
    3ec0:	cf 93       	push	r28
    3ec2:	00 d0       	rcall	.+0      	; 0x3ec4 <prvCopyDataToQueue+0x6>
    3ec4:	00 d0       	rcall	.+0      	; 0x3ec6 <prvCopyDataToQueue+0x8>
    3ec6:	0f 92       	push	r0
    3ec8:	cd b7       	in	r28, 0x3d	; 61
    3eca:	de b7       	in	r29, 0x3e	; 62
    3ecc:	9a 83       	std	Y+2, r25	; 0x02
    3ece:	89 83       	std	Y+1, r24	; 0x01
    3ed0:	7c 83       	std	Y+4, r23	; 0x04
    3ed2:	6b 83       	std	Y+3, r22	; 0x03
    3ed4:	4d 83       	std	Y+5, r20	; 0x05
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
    3ed6:	e9 81       	ldd	r30, Y+1	; 0x01
    3ed8:	fa 81       	ldd	r31, Y+2	; 0x02
    3eda:	84 8d       	ldd	r24, Z+28	; 0x1c
    3edc:	88 23       	and	r24, r24
    3ede:	09 f4       	brne	.+2      	; 0x3ee2 <prvCopyDataToQueue+0x24>
    3ee0:	74 c0       	rjmp	.+232    	; 0x3fca <prvCopyDataToQueue+0x10c>
				pxQueue->pxMutexHolder = NULL;
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
    3ee2:	8d 81       	ldd	r24, Y+5	; 0x05
    3ee4:	88 23       	and	r24, r24
    3ee6:	99 f5       	brne	.+102    	; 0x3f4e <prvCopyDataToQueue+0x90>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
    3ee8:	e9 81       	ldd	r30, Y+1	; 0x01
    3eea:	fa 81       	ldd	r31, Y+2	; 0x02
    3eec:	64 81       	ldd	r22, Z+4	; 0x04
    3eee:	75 81       	ldd	r23, Z+5	; 0x05
    3ef0:	e9 81       	ldd	r30, Y+1	; 0x01
    3ef2:	fa 81       	ldd	r31, Y+2	; 0x02
    3ef4:	84 8d       	ldd	r24, Z+28	; 0x1c
    3ef6:	48 2f       	mov	r20, r24
    3ef8:	50 e0       	ldi	r21, 0x00	; 0
    3efa:	2b 81       	ldd	r18, Y+3	; 0x03
    3efc:	3c 81       	ldd	r19, Y+4	; 0x04
    3efe:	cb 01       	movw	r24, r22
    3f00:	b9 01       	movw	r22, r18
    3f02:	0e 94 5f 28 	call	0x50be	; 0x50be <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
    3f06:	e9 81       	ldd	r30, Y+1	; 0x01
    3f08:	fa 81       	ldd	r31, Y+2	; 0x02
    3f0a:	24 81       	ldd	r18, Z+4	; 0x04
    3f0c:	35 81       	ldd	r19, Z+5	; 0x05
    3f0e:	e9 81       	ldd	r30, Y+1	; 0x01
    3f10:	fa 81       	ldd	r31, Y+2	; 0x02
    3f12:	84 8d       	ldd	r24, Z+28	; 0x1c
    3f14:	88 2f       	mov	r24, r24
    3f16:	90 e0       	ldi	r25, 0x00	; 0
    3f18:	82 0f       	add	r24, r18
    3f1a:	93 1f       	adc	r25, r19
    3f1c:	e9 81       	ldd	r30, Y+1	; 0x01
    3f1e:	fa 81       	ldd	r31, Y+2	; 0x02
    3f20:	95 83       	std	Z+5, r25	; 0x05
    3f22:	84 83       	std	Z+4, r24	; 0x04
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
    3f24:	e9 81       	ldd	r30, Y+1	; 0x01
    3f26:	fa 81       	ldd	r31, Y+2	; 0x02
    3f28:	24 81       	ldd	r18, Z+4	; 0x04
    3f2a:	35 81       	ldd	r19, Z+5	; 0x05
    3f2c:	e9 81       	ldd	r30, Y+1	; 0x01
    3f2e:	fa 81       	ldd	r31, Y+2	; 0x02
    3f30:	82 81       	ldd	r24, Z+2	; 0x02
    3f32:	93 81       	ldd	r25, Z+3	; 0x03
    3f34:	28 17       	cp	r18, r24
    3f36:	39 07       	cpc	r19, r25
    3f38:	08 f4       	brcc	.+2      	; 0x3f3c <prvCopyDataToQueue+0x7e>
    3f3a:	47 c0       	rjmp	.+142    	; 0x3fca <prvCopyDataToQueue+0x10c>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
    3f3c:	e9 81       	ldd	r30, Y+1	; 0x01
    3f3e:	fa 81       	ldd	r31, Y+2	; 0x02
    3f40:	80 81       	ld	r24, Z
    3f42:	91 81       	ldd	r25, Z+1	; 0x01
    3f44:	e9 81       	ldd	r30, Y+1	; 0x01
    3f46:	fa 81       	ldd	r31, Y+2	; 0x02
    3f48:	95 83       	std	Z+5, r25	; 0x05
    3f4a:	84 83       	std	Z+4, r24	; 0x04
    3f4c:	3e c0       	rjmp	.+124    	; 0x3fca <prvCopyDataToQueue+0x10c>
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
    3f4e:	e9 81       	ldd	r30, Y+1	; 0x01
    3f50:	fa 81       	ldd	r31, Y+2	; 0x02
    3f52:	66 81       	ldd	r22, Z+6	; 0x06
    3f54:	77 81       	ldd	r23, Z+7	; 0x07
    3f56:	e9 81       	ldd	r30, Y+1	; 0x01
    3f58:	fa 81       	ldd	r31, Y+2	; 0x02
    3f5a:	84 8d       	ldd	r24, Z+28	; 0x1c
    3f5c:	48 2f       	mov	r20, r24
    3f5e:	50 e0       	ldi	r21, 0x00	; 0
    3f60:	2b 81       	ldd	r18, Y+3	; 0x03
    3f62:	3c 81       	ldd	r19, Y+4	; 0x04
    3f64:	cb 01       	movw	r24, r22
    3f66:	b9 01       	movw	r22, r18
    3f68:	0e 94 5f 28 	call	0x50be	; 0x50be <memcpy>
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
    3f6c:	e9 81       	ldd	r30, Y+1	; 0x01
    3f6e:	fa 81       	ldd	r31, Y+2	; 0x02
    3f70:	26 81       	ldd	r18, Z+6	; 0x06
    3f72:	37 81       	ldd	r19, Z+7	; 0x07
    3f74:	e9 81       	ldd	r30, Y+1	; 0x01
    3f76:	fa 81       	ldd	r31, Y+2	; 0x02
    3f78:	84 8d       	ldd	r24, Z+28	; 0x1c
    3f7a:	88 2f       	mov	r24, r24
    3f7c:	90 e0       	ldi	r25, 0x00	; 0
    3f7e:	90 95       	com	r25
    3f80:	81 95       	neg	r24
    3f82:	9f 4f       	sbci	r25, 0xFF	; 255
    3f84:	82 0f       	add	r24, r18
    3f86:	93 1f       	adc	r25, r19
    3f88:	e9 81       	ldd	r30, Y+1	; 0x01
    3f8a:	fa 81       	ldd	r31, Y+2	; 0x02
    3f8c:	97 83       	std	Z+7, r25	; 0x07
    3f8e:	86 83       	std	Z+6, r24	; 0x06
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
    3f90:	e9 81       	ldd	r30, Y+1	; 0x01
    3f92:	fa 81       	ldd	r31, Y+2	; 0x02
    3f94:	26 81       	ldd	r18, Z+6	; 0x06
    3f96:	37 81       	ldd	r19, Z+7	; 0x07
    3f98:	e9 81       	ldd	r30, Y+1	; 0x01
    3f9a:	fa 81       	ldd	r31, Y+2	; 0x02
    3f9c:	80 81       	ld	r24, Z
    3f9e:	91 81       	ldd	r25, Z+1	; 0x01
    3fa0:	28 17       	cp	r18, r24
    3fa2:	39 07       	cpc	r19, r25
    3fa4:	90 f4       	brcc	.+36     	; 0x3fca <prvCopyDataToQueue+0x10c>
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
    3fa6:	e9 81       	ldd	r30, Y+1	; 0x01
    3fa8:	fa 81       	ldd	r31, Y+2	; 0x02
    3faa:	22 81       	ldd	r18, Z+2	; 0x02
    3fac:	33 81       	ldd	r19, Z+3	; 0x03
    3fae:	e9 81       	ldd	r30, Y+1	; 0x01
    3fb0:	fa 81       	ldd	r31, Y+2	; 0x02
    3fb2:	84 8d       	ldd	r24, Z+28	; 0x1c
    3fb4:	88 2f       	mov	r24, r24
    3fb6:	90 e0       	ldi	r25, 0x00	; 0
    3fb8:	90 95       	com	r25
    3fba:	81 95       	neg	r24
    3fbc:	9f 4f       	sbci	r25, 0xFF	; 255
    3fbe:	82 0f       	add	r24, r18
    3fc0:	93 1f       	adc	r25, r19
    3fc2:	e9 81       	ldd	r30, Y+1	; 0x01
    3fc4:	fa 81       	ldd	r31, Y+2	; 0x02
    3fc6:	97 83       	std	Z+7, r25	; 0x07
    3fc8:	86 83       	std	Z+6, r24	; 0x06
		}
	}

	++( pxQueue->uxMessagesWaiting );
    3fca:	e9 81       	ldd	r30, Y+1	; 0x01
    3fcc:	fa 81       	ldd	r31, Y+2	; 0x02
    3fce:	82 8d       	ldd	r24, Z+26	; 0x1a
    3fd0:	8f 5f       	subi	r24, 0xFF	; 255
    3fd2:	e9 81       	ldd	r30, Y+1	; 0x01
    3fd4:	fa 81       	ldd	r31, Y+2	; 0x02
    3fd6:	82 8f       	std	Z+26, r24	; 0x1a
}
    3fd8:	0f 90       	pop	r0
    3fda:	0f 90       	pop	r0
    3fdc:	0f 90       	pop	r0
    3fde:	0f 90       	pop	r0
    3fe0:	0f 90       	pop	r0
    3fe2:	cf 91       	pop	r28
    3fe4:	df 91       	pop	r29
    3fe6:	08 95       	ret

00003fe8 <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
    3fe8:	df 93       	push	r29
    3fea:	cf 93       	push	r28
    3fec:	00 d0       	rcall	.+0      	; 0x3fee <prvCopyDataFromQueue+0x6>
    3fee:	00 d0       	rcall	.+0      	; 0x3ff0 <prvCopyDataFromQueue+0x8>
    3ff0:	cd b7       	in	r28, 0x3d	; 61
    3ff2:	de b7       	in	r29, 0x3e	; 62
    3ff4:	9a 83       	std	Y+2, r25	; 0x02
    3ff6:	89 83       	std	Y+1, r24	; 0x01
    3ff8:	7c 83       	std	Y+4, r23	; 0x04
    3ffa:	6b 83       	std	Y+3, r22	; 0x03
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
    3ffc:	e9 81       	ldd	r30, Y+1	; 0x01
    3ffe:	fa 81       	ldd	r31, Y+2	; 0x02
    4000:	80 81       	ld	r24, Z
    4002:	91 81       	ldd	r25, Z+1	; 0x01
    4004:	00 97       	sbiw	r24, 0x00	; 0
    4006:	89 f1       	breq	.+98     	; 0x406a <prvCopyDataFromQueue+0x82>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
    4008:	e9 81       	ldd	r30, Y+1	; 0x01
    400a:	fa 81       	ldd	r31, Y+2	; 0x02
    400c:	26 81       	ldd	r18, Z+6	; 0x06
    400e:	37 81       	ldd	r19, Z+7	; 0x07
    4010:	e9 81       	ldd	r30, Y+1	; 0x01
    4012:	fa 81       	ldd	r31, Y+2	; 0x02
    4014:	84 8d       	ldd	r24, Z+28	; 0x1c
    4016:	88 2f       	mov	r24, r24
    4018:	90 e0       	ldi	r25, 0x00	; 0
    401a:	82 0f       	add	r24, r18
    401c:	93 1f       	adc	r25, r19
    401e:	e9 81       	ldd	r30, Y+1	; 0x01
    4020:	fa 81       	ldd	r31, Y+2	; 0x02
    4022:	97 83       	std	Z+7, r25	; 0x07
    4024:	86 83       	std	Z+6, r24	; 0x06
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
    4026:	e9 81       	ldd	r30, Y+1	; 0x01
    4028:	fa 81       	ldd	r31, Y+2	; 0x02
    402a:	26 81       	ldd	r18, Z+6	; 0x06
    402c:	37 81       	ldd	r19, Z+7	; 0x07
    402e:	e9 81       	ldd	r30, Y+1	; 0x01
    4030:	fa 81       	ldd	r31, Y+2	; 0x02
    4032:	82 81       	ldd	r24, Z+2	; 0x02
    4034:	93 81       	ldd	r25, Z+3	; 0x03
    4036:	28 17       	cp	r18, r24
    4038:	39 07       	cpc	r19, r25
    403a:	40 f0       	brcs	.+16     	; 0x404c <prvCopyDataFromQueue+0x64>
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
    403c:	e9 81       	ldd	r30, Y+1	; 0x01
    403e:	fa 81       	ldd	r31, Y+2	; 0x02
    4040:	80 81       	ld	r24, Z
    4042:	91 81       	ldd	r25, Z+1	; 0x01
    4044:	e9 81       	ldd	r30, Y+1	; 0x01
    4046:	fa 81       	ldd	r31, Y+2	; 0x02
    4048:	97 83       	std	Z+7, r25	; 0x07
    404a:	86 83       	std	Z+6, r24	; 0x06
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    404c:	e9 81       	ldd	r30, Y+1	; 0x01
    404e:	fa 81       	ldd	r31, Y+2	; 0x02
    4050:	46 81       	ldd	r20, Z+6	; 0x06
    4052:	57 81       	ldd	r21, Z+7	; 0x07
    4054:	e9 81       	ldd	r30, Y+1	; 0x01
    4056:	fa 81       	ldd	r31, Y+2	; 0x02
    4058:	84 8d       	ldd	r24, Z+28	; 0x1c
    405a:	28 2f       	mov	r18, r24
    405c:	30 e0       	ldi	r19, 0x00	; 0
    405e:	8b 81       	ldd	r24, Y+3	; 0x03
    4060:	9c 81       	ldd	r25, Y+4	; 0x04
    4062:	ba 01       	movw	r22, r20
    4064:	a9 01       	movw	r20, r18
    4066:	0e 94 5f 28 	call	0x50be	; 0x50be <memcpy>
	}
}
    406a:	0f 90       	pop	r0
    406c:	0f 90       	pop	r0
    406e:	0f 90       	pop	r0
    4070:	0f 90       	pop	r0
    4072:	cf 91       	pop	r28
    4074:	df 91       	pop	r29
    4076:	08 95       	ret

00004078 <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQueueHandle pxQueue )
{
    4078:	df 93       	push	r29
    407a:	cf 93       	push	r28
    407c:	00 d0       	rcall	.+0      	; 0x407e <prvUnlockQueue+0x6>
    407e:	cd b7       	in	r28, 0x3d	; 61
    4080:	de b7       	in	r29, 0x3e	; 62
    4082:	9a 83       	std	Y+2, r25	; 0x02
    4084:	89 83       	std	Y+1, r24	; 0x01

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    4086:	0f b6       	in	r0, 0x3f	; 63
    4088:	f8 94       	cli
    408a:	0f 92       	push	r0
    408c:	15 c0       	rjmp	.+42     	; 0x40b8 <prvUnlockQueue+0x40>
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    408e:	e9 81       	ldd	r30, Y+1	; 0x01
    4090:	fa 81       	ldd	r31, Y+2	; 0x02
    4092:	81 89       	ldd	r24, Z+17	; 0x11
    4094:	88 23       	and	r24, r24
    4096:	a9 f0       	breq	.+42     	; 0x40c2 <prvUnlockQueue+0x4a>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    4098:	89 81       	ldd	r24, Y+1	; 0x01
    409a:	9a 81       	ldd	r25, Y+2	; 0x02
    409c:	41 96       	adiw	r24, 0x11	; 17
    409e:	0e 94 74 25 	call	0x4ae8	; 0x4ae8 <xTaskRemoveFromEventList>
    40a2:	88 23       	and	r24, r24
    40a4:	11 f0       	breq	.+4      	; 0x40aa <prvUnlockQueue+0x32>
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
    40a6:	0e 94 52 26 	call	0x4ca4	; 0x4ca4 <vTaskMissedYield>
				}

				--( pxQueue->xTxLock );
    40aa:	e9 81       	ldd	r30, Y+1	; 0x01
    40ac:	fa 81       	ldd	r31, Y+2	; 0x02
    40ae:	86 8d       	ldd	r24, Z+30	; 0x1e
    40b0:	81 50       	subi	r24, 0x01	; 1
    40b2:	e9 81       	ldd	r30, Y+1	; 0x01
    40b4:	fa 81       	ldd	r31, Y+2	; 0x02
    40b6:	86 8f       	std	Z+30, r24	; 0x1e
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    40b8:	e9 81       	ldd	r30, Y+1	; 0x01
    40ba:	fa 81       	ldd	r31, Y+2	; 0x02
    40bc:	86 8d       	ldd	r24, Z+30	; 0x1e
    40be:	18 16       	cp	r1, r24
    40c0:	34 f3       	brlt	.-52     	; 0x408e <prvUnlockQueue+0x16>
			{
				break;
			}
		}

		pxQueue->xTxLock = queueUNLOCKED;
    40c2:	e9 81       	ldd	r30, Y+1	; 0x01
    40c4:	fa 81       	ldd	r31, Y+2	; 0x02
    40c6:	8f ef       	ldi	r24, 0xFF	; 255
    40c8:	86 8f       	std	Z+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
    40ca:	0f 90       	pop	r0
    40cc:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    40ce:	0f b6       	in	r0, 0x3f	; 63
    40d0:	f8 94       	cli
    40d2:	0f 92       	push	r0
    40d4:	15 c0       	rjmp	.+42     	; 0x4100 <prvUnlockQueue+0x88>
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    40d6:	e9 81       	ldd	r30, Y+1	; 0x01
    40d8:	fa 81       	ldd	r31, Y+2	; 0x02
    40da:	80 85       	ldd	r24, Z+8	; 0x08
    40dc:	88 23       	and	r24, r24
    40de:	a9 f0       	breq	.+42     	; 0x410a <prvUnlockQueue+0x92>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    40e0:	89 81       	ldd	r24, Y+1	; 0x01
    40e2:	9a 81       	ldd	r25, Y+2	; 0x02
    40e4:	08 96       	adiw	r24, 0x08	; 8
    40e6:	0e 94 74 25 	call	0x4ae8	; 0x4ae8 <xTaskRemoveFromEventList>
    40ea:	88 23       	and	r24, r24
    40ec:	11 f0       	breq	.+4      	; 0x40f2 <prvUnlockQueue+0x7a>
				{
					vTaskMissedYield();
    40ee:	0e 94 52 26 	call	0x4ca4	; 0x4ca4 <vTaskMissedYield>
				}

				--( pxQueue->xRxLock );
    40f2:	e9 81       	ldd	r30, Y+1	; 0x01
    40f4:	fa 81       	ldd	r31, Y+2	; 0x02
    40f6:	85 8d       	ldd	r24, Z+29	; 0x1d
    40f8:	81 50       	subi	r24, 0x01	; 1
    40fa:	e9 81       	ldd	r30, Y+1	; 0x01
    40fc:	fa 81       	ldd	r31, Y+2	; 0x02
    40fe:	85 8f       	std	Z+29, r24	; 0x1d
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    4100:	e9 81       	ldd	r30, Y+1	; 0x01
    4102:	fa 81       	ldd	r31, Y+2	; 0x02
    4104:	85 8d       	ldd	r24, Z+29	; 0x1d
    4106:	18 16       	cp	r1, r24
    4108:	34 f3       	brlt	.-52     	; 0x40d6 <prvUnlockQueue+0x5e>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
    410a:	e9 81       	ldd	r30, Y+1	; 0x01
    410c:	fa 81       	ldd	r31, Y+2	; 0x02
    410e:	8f ef       	ldi	r24, 0xFF	; 255
    4110:	85 8f       	std	Z+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
    4112:	0f 90       	pop	r0
    4114:	0f be       	out	0x3f, r0	; 63
}
    4116:	0f 90       	pop	r0
    4118:	0f 90       	pop	r0
    411a:	cf 91       	pop	r28
    411c:	df 91       	pop	r29
    411e:	08 95       	ret

00004120 <prvIsQueueEmpty>:
/*-----------------------------------------------------------*/

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
    4120:	df 93       	push	r29
    4122:	cf 93       	push	r28
    4124:	00 d0       	rcall	.+0      	; 0x4126 <prvIsQueueEmpty+0x6>
    4126:	0f 92       	push	r0
    4128:	cd b7       	in	r28, 0x3d	; 61
    412a:	de b7       	in	r29, 0x3e	; 62
    412c:	9b 83       	std	Y+3, r25	; 0x03
    412e:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    4130:	0f b6       	in	r0, 0x3f	; 63
    4132:	f8 94       	cli
    4134:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
    4136:	ea 81       	ldd	r30, Y+2	; 0x02
    4138:	fb 81       	ldd	r31, Y+3	; 0x03
    413a:	82 8d       	ldd	r24, Z+26	; 0x1a
    413c:	19 82       	std	Y+1, r1	; 0x01
    413e:	88 23       	and	r24, r24
    4140:	11 f4       	brne	.+4      	; 0x4146 <prvIsQueueEmpty+0x26>
    4142:	81 e0       	ldi	r24, 0x01	; 1
    4144:	89 83       	std	Y+1, r24	; 0x01
	taskEXIT_CRITICAL();
    4146:	0f 90       	pop	r0
    4148:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    414a:	89 81       	ldd	r24, Y+1	; 0x01
}
    414c:	0f 90       	pop	r0
    414e:	0f 90       	pop	r0
    4150:	0f 90       	pop	r0
    4152:	cf 91       	pop	r28
    4154:	df 91       	pop	r29
    4156:	08 95       	ret

00004158 <xQueueIsQueueEmptyFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueIsQueueEmptyFromISR( const xQueueHandle pxQueue )
{
    4158:	df 93       	push	r29
    415a:	cf 93       	push	r28
    415c:	00 d0       	rcall	.+0      	; 0x415e <xQueueIsQueueEmptyFromISR+0x6>
    415e:	0f 92       	push	r0
    4160:	cd b7       	in	r28, 0x3d	; 61
    4162:	de b7       	in	r29, 0x3e	; 62
    4164:	9b 83       	std	Y+3, r25	; 0x03
    4166:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	configASSERT( pxQueue );
	xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
    4168:	ea 81       	ldd	r30, Y+2	; 0x02
    416a:	fb 81       	ldd	r31, Y+3	; 0x03
    416c:	82 8d       	ldd	r24, Z+26	; 0x1a
    416e:	19 82       	std	Y+1, r1	; 0x01
    4170:	88 23       	and	r24, r24
    4172:	11 f4       	brne	.+4      	; 0x4178 <xQueueIsQueueEmptyFromISR+0x20>
    4174:	81 e0       	ldi	r24, 0x01	; 1
    4176:	89 83       	std	Y+1, r24	; 0x01

	return xReturn;
    4178:	89 81       	ldd	r24, Y+1	; 0x01
}
    417a:	0f 90       	pop	r0
    417c:	0f 90       	pop	r0
    417e:	0f 90       	pop	r0
    4180:	cf 91       	pop	r28
    4182:	df 91       	pop	r29
    4184:	08 95       	ret

00004186 <prvIsQueueFull>:
/*-----------------------------------------------------------*/

static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
{
    4186:	df 93       	push	r29
    4188:	cf 93       	push	r28
    418a:	00 d0       	rcall	.+0      	; 0x418c <prvIsQueueFull+0x6>
    418c:	0f 92       	push	r0
    418e:	cd b7       	in	r28, 0x3d	; 61
    4190:	de b7       	in	r29, 0x3e	; 62
    4192:	9b 83       	std	Y+3, r25	; 0x03
    4194:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    4196:	0f b6       	in	r0, 0x3f	; 63
    4198:	f8 94       	cli
    419a:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
    419c:	ea 81       	ldd	r30, Y+2	; 0x02
    419e:	fb 81       	ldd	r31, Y+3	; 0x03
    41a0:	92 8d       	ldd	r25, Z+26	; 0x1a
    41a2:	ea 81       	ldd	r30, Y+2	; 0x02
    41a4:	fb 81       	ldd	r31, Y+3	; 0x03
    41a6:	83 8d       	ldd	r24, Z+27	; 0x1b
    41a8:	19 82       	std	Y+1, r1	; 0x01
    41aa:	98 17       	cp	r25, r24
    41ac:	11 f4       	brne	.+4      	; 0x41b2 <prvIsQueueFull+0x2c>
    41ae:	81 e0       	ldi	r24, 0x01	; 1
    41b0:	89 83       	std	Y+1, r24	; 0x01
	taskEXIT_CRITICAL();
    41b2:	0f 90       	pop	r0
    41b4:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    41b6:	89 81       	ldd	r24, Y+1	; 0x01
}
    41b8:	0f 90       	pop	r0
    41ba:	0f 90       	pop	r0
    41bc:	0f 90       	pop	r0
    41be:	cf 91       	pop	r28
    41c0:	df 91       	pop	r29
    41c2:	08 95       	ret

000041c4 <xQueueIsQueueFullFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueIsQueueFullFromISR( const xQueueHandle pxQueue )
{
    41c4:	df 93       	push	r29
    41c6:	cf 93       	push	r28
    41c8:	00 d0       	rcall	.+0      	; 0x41ca <xQueueIsQueueFullFromISR+0x6>
    41ca:	0f 92       	push	r0
    41cc:	cd b7       	in	r28, 0x3d	; 61
    41ce:	de b7       	in	r29, 0x3e	; 62
    41d0:	9b 83       	std	Y+3, r25	; 0x03
    41d2:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	configASSERT( pxQueue );
	xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
    41d4:	ea 81       	ldd	r30, Y+2	; 0x02
    41d6:	fb 81       	ldd	r31, Y+3	; 0x03
    41d8:	92 8d       	ldd	r25, Z+26	; 0x1a
    41da:	ea 81       	ldd	r30, Y+2	; 0x02
    41dc:	fb 81       	ldd	r31, Y+3	; 0x03
    41de:	83 8d       	ldd	r24, Z+27	; 0x1b
    41e0:	19 82       	std	Y+1, r1	; 0x01
    41e2:	98 17       	cp	r25, r24
    41e4:	11 f4       	brne	.+4      	; 0x41ea <xQueueIsQueueFullFromISR+0x26>
    41e6:	81 e0       	ldi	r24, 0x01	; 1
    41e8:	89 83       	std	Y+1, r24	; 0x01

	return xReturn;
    41ea:	89 81       	ldd	r24, Y+1	; 0x01
}
    41ec:	0f 90       	pop	r0
    41ee:	0f 90       	pop	r0
    41f0:	0f 90       	pop	r0
    41f2:	cf 91       	pop	r28
    41f4:	df 91       	pop	r29
    41f6:	08 95       	ret

000041f8 <xTaskGenericCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
    41f8:	af 92       	push	r10
    41fa:	bf 92       	push	r11
    41fc:	cf 92       	push	r12
    41fe:	df 92       	push	r13
    4200:	ef 92       	push	r14
    4202:	ff 92       	push	r15
    4204:	0f 93       	push	r16
    4206:	1f 93       	push	r17
    4208:	df 93       	push	r29
    420a:	cf 93       	push	r28
    420c:	cd b7       	in	r28, 0x3d	; 61
    420e:	de b7       	in	r29, 0x3e	; 62
    4210:	64 97       	sbiw	r28, 0x14	; 20
    4212:	0f b6       	in	r0, 0x3f	; 63
    4214:	f8 94       	cli
    4216:	de bf       	out	0x3e, r29	; 62
    4218:	0f be       	out	0x3f, r0	; 63
    421a:	cd bf       	out	0x3d, r28	; 61
    421c:	9f 83       	std	Y+7, r25	; 0x07
    421e:	8e 83       	std	Y+6, r24	; 0x06
    4220:	79 87       	std	Y+9, r23	; 0x09
    4222:	68 87       	std	Y+8, r22	; 0x08
    4224:	5b 87       	std	Y+11, r21	; 0x0b
    4226:	4a 87       	std	Y+10, r20	; 0x0a
    4228:	3d 87       	std	Y+13, r19	; 0x0d
    422a:	2c 87       	std	Y+12, r18	; 0x0c
    422c:	0e 87       	std	Y+14, r16	; 0x0e
    422e:	f8 8a       	std	Y+16, r15	; 0x10
    4230:	ef 86       	std	Y+15, r14	; 0x0f
    4232:	da 8a       	std	Y+18, r13	; 0x12
    4234:	c9 8a       	std	Y+17, r12	; 0x11
    4236:	bc 8a       	std	Y+20, r11	; 0x14
    4238:	ab 8a       	std	Y+19, r10	; 0x13
	configASSERT( pxTaskCode );
	configASSERT( ( uxPriority < configMAX_PRIORITIES ) );

	/* Allocate the memory required by the TCB and stack for the new task,
	checking that the allocation was successful. */
	pxNewTCB = prvAllocateTCBAndStack( usStackDepth, puxStackBuffer );
    423a:	8a 85       	ldd	r24, Y+10	; 0x0a
    423c:	9b 85       	ldd	r25, Y+11	; 0x0b
    423e:	29 89       	ldd	r18, Y+17	; 0x11
    4240:	3a 89       	ldd	r19, Y+18	; 0x12
    4242:	b9 01       	movw	r22, r18
    4244:	0e 94 81 27 	call	0x4f02	; 0x4f02 <prvAllocateTCBAndStack>
    4248:	9c 83       	std	Y+4, r25	; 0x04
    424a:	8b 83       	std	Y+3, r24	; 0x03

	if( pxNewTCB != NULL )
    424c:	8b 81       	ldd	r24, Y+3	; 0x03
    424e:	9c 81       	ldd	r25, Y+4	; 0x04
    4250:	00 97       	sbiw	r24, 0x00	; 0
    4252:	09 f4       	brne	.+2      	; 0x4256 <xTaskGenericCreate+0x5e>
    4254:	99 c0       	rjmp	.+306    	; 0x4388 <xTaskGenericCreate+0x190>
		stack grows from high memory to low (as per the 80x86) or visa versa.
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
    4256:	eb 81       	ldd	r30, Y+3	; 0x03
    4258:	fc 81       	ldd	r31, Y+4	; 0x04
    425a:	27 89       	ldd	r18, Z+23	; 0x17
    425c:	30 8d       	ldd	r19, Z+24	; 0x18
    425e:	8a 85       	ldd	r24, Y+10	; 0x0a
    4260:	9b 85       	ldd	r25, Y+11	; 0x0b
    4262:	01 97       	sbiw	r24, 0x01	; 1
    4264:	82 0f       	add	r24, r18
    4266:	93 1f       	adc	r25, r19
    4268:	9a 83       	std	Y+2, r25	; 0x02
    426a:	89 83       	std	Y+1, r24	; 0x01
			pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( usStackDepth - 1 );
		}
		#endif

		/* Setup the newly allocated TCB with the initial state of the task. */
		prvInitialiseTCBVariables( pxNewTCB, pcName, uxPriority, xRegions, usStackDepth );
    426c:	8b 81       	ldd	r24, Y+3	; 0x03
    426e:	9c 81       	ldd	r25, Y+4	; 0x04
    4270:	28 85       	ldd	r18, Y+8	; 0x08
    4272:	39 85       	ldd	r19, Y+9	; 0x09
    4274:	eb 89       	ldd	r30, Y+19	; 0x13
    4276:	fc 89       	ldd	r31, Y+20	; 0x14
    4278:	aa 85       	ldd	r26, Y+10	; 0x0a
    427a:	bb 85       	ldd	r27, Y+11	; 0x0b
    427c:	b9 01       	movw	r22, r18
    427e:	4e 85       	ldd	r20, Y+14	; 0x0e
    4280:	9f 01       	movw	r18, r30
    4282:	8d 01       	movw	r16, r26
    4284:	0e 94 66 26 	call	0x4ccc	; 0x4ccc <prvInitialiseTCBVariables>
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    4288:	89 81       	ldd	r24, Y+1	; 0x01
    428a:	9a 81       	ldd	r25, Y+2	; 0x02
    428c:	2e 81       	ldd	r18, Y+6	; 0x06
    428e:	3f 81       	ldd	r19, Y+7	; 0x07
    4290:	4c 85       	ldd	r20, Y+12	; 0x0c
    4292:	5d 85       	ldd	r21, Y+13	; 0x0d
    4294:	b9 01       	movw	r22, r18
    4296:	0e 94 a9 19 	call	0x3352	; 0x3352 <pxPortInitialiseStack>
    429a:	eb 81       	ldd	r30, Y+3	; 0x03
    429c:	fc 81       	ldd	r31, Y+4	; 0x04
    429e:	91 83       	std	Z+1, r25	; 0x01
    42a0:	80 83       	st	Z, r24
		#endif

		/* Check the alignment of the initialised stack. */
		configASSERT( ( ( ( unsigned long ) pxNewTCB->pxTopOfStack & ( unsigned long ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );

		if( ( void * ) pxCreatedTask != NULL )
    42a2:	8f 85       	ldd	r24, Y+15	; 0x0f
    42a4:	98 89       	ldd	r25, Y+16	; 0x10
    42a6:	00 97       	sbiw	r24, 0x00	; 0
    42a8:	31 f0       	breq	.+12     	; 0x42b6 <xTaskGenericCreate+0xbe>
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
    42aa:	ef 85       	ldd	r30, Y+15	; 0x0f
    42ac:	f8 89       	ldd	r31, Y+16	; 0x10
    42ae:	8b 81       	ldd	r24, Y+3	; 0x03
    42b0:	9c 81       	ldd	r25, Y+4	; 0x04
    42b2:	91 83       	std	Z+1, r25	; 0x01
    42b4:	80 83       	st	Z, r24
		}
		
		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		taskENTER_CRITICAL();
    42b6:	0f b6       	in	r0, 0x3f	; 63
    42b8:	f8 94       	cli
    42ba:	0f 92       	push	r0
		{
			uxCurrentNumberOfTasks++;
    42bc:	80 91 2d 04 	lds	r24, 0x042D
    42c0:	8f 5f       	subi	r24, 0xFF	; 255
    42c2:	80 93 2d 04 	sts	0x042D, r24
			if( pxCurrentTCB == NULL )
    42c6:	80 91 2a 04 	lds	r24, 0x042A
    42ca:	90 91 2b 04 	lds	r25, 0x042B
    42ce:	00 97       	sbiw	r24, 0x00	; 0
    42d0:	69 f4       	brne	.+26     	; 0x42ec <xTaskGenericCreate+0xf4>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
    42d2:	8b 81       	ldd	r24, Y+3	; 0x03
    42d4:	9c 81       	ldd	r25, Y+4	; 0x04
    42d6:	90 93 2b 04 	sts	0x042B, r25
    42da:	80 93 2a 04 	sts	0x042A, r24

				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
    42de:	80 91 2d 04 	lds	r24, 0x042D
    42e2:	81 30       	cpi	r24, 0x01	; 1
    42e4:	a9 f4       	brne	.+42     	; 0x4310 <xTaskGenericCreate+0x118>
				{
					/* This is the first task to be created so do the preliminary
					initialisation required.  We will not recover if this call
					fails, but we will report the failure. */
					prvInitialiseTaskLists();
    42e6:	0e 94 bd 26 	call	0x4d7a	; 0x4d7a <prvInitialiseTaskLists>
    42ea:	12 c0       	rjmp	.+36     	; 0x4310 <xTaskGenericCreate+0x118>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
    42ec:	80 91 32 04 	lds	r24, 0x0432
    42f0:	88 23       	and	r24, r24
    42f2:	71 f4       	brne	.+28     	; 0x4310 <xTaskGenericCreate+0x118>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
    42f4:	e0 91 2a 04 	lds	r30, 0x042A
    42f8:	f0 91 2b 04 	lds	r31, 0x042B
    42fc:	96 89       	ldd	r25, Z+22	; 0x16
    42fe:	8e 85       	ldd	r24, Y+14	; 0x0e
    4300:	89 17       	cp	r24, r25
    4302:	30 f0       	brcs	.+12     	; 0x4310 <xTaskGenericCreate+0x118>
					{
						pxCurrentTCB = pxNewTCB;
    4304:	8b 81       	ldd	r24, Y+3	; 0x03
    4306:	9c 81       	ldd	r25, Y+4	; 0x04
    4308:	90 93 2b 04 	sts	0x042B, r25
    430c:	80 93 2a 04 	sts	0x042A, r24
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
    4310:	eb 81       	ldd	r30, Y+3	; 0x03
    4312:	fc 81       	ldd	r31, Y+4	; 0x04
    4314:	96 89       	ldd	r25, Z+22	; 0x16
    4316:	80 91 30 04 	lds	r24, 0x0430
    431a:	89 17       	cp	r24, r25
    431c:	28 f4       	brcc	.+10     	; 0x4328 <xTaskGenericCreate+0x130>
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
    431e:	eb 81       	ldd	r30, Y+3	; 0x03
    4320:	fc 81       	ldd	r31, Y+4	; 0x04
    4322:	86 89       	ldd	r24, Z+22	; 0x16
    4324:	80 93 30 04 	sts	0x0430, r24
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif
			uxTaskNumber++;
    4328:	80 91 37 04 	lds	r24, 0x0437
    432c:	8f 5f       	subi	r24, 0xFF	; 255
    432e:	80 93 37 04 	sts	0x0437, r24

			prvAddTaskToReadyQueue( pxNewTCB );
    4332:	eb 81       	ldd	r30, Y+3	; 0x03
    4334:	fc 81       	ldd	r31, Y+4	; 0x04
    4336:	96 89       	ldd	r25, Z+22	; 0x16
    4338:	80 91 31 04 	lds	r24, 0x0431
    433c:	89 17       	cp	r24, r25
    433e:	28 f4       	brcc	.+10     	; 0x434a <xTaskGenericCreate+0x152>
    4340:	eb 81       	ldd	r30, Y+3	; 0x03
    4342:	fc 81       	ldd	r31, Y+4	; 0x04
    4344:	86 89       	ldd	r24, Z+22	; 0x16
    4346:	80 93 31 04 	sts	0x0431, r24
    434a:	eb 81       	ldd	r30, Y+3	; 0x03
    434c:	fc 81       	ldd	r31, Y+4	; 0x04
    434e:	86 89       	ldd	r24, Z+22	; 0x16
    4350:	28 2f       	mov	r18, r24
    4352:	30 e0       	ldi	r19, 0x00	; 0
    4354:	c9 01       	movw	r24, r18
    4356:	88 0f       	add	r24, r24
    4358:	99 1f       	adc	r25, r25
    435a:	88 0f       	add	r24, r24
    435c:	99 1f       	adc	r25, r25
    435e:	88 0f       	add	r24, r24
    4360:	99 1f       	adc	r25, r25
    4362:	82 0f       	add	r24, r18
    4364:	93 1f       	adc	r25, r19
    4366:	ac 01       	movw	r20, r24
    4368:	48 5c       	subi	r20, 0xC8	; 200
    436a:	5b 4f       	sbci	r21, 0xFB	; 251
    436c:	8b 81       	ldd	r24, Y+3	; 0x03
    436e:	9c 81       	ldd	r25, Y+4	; 0x04
    4370:	9c 01       	movw	r18, r24
    4372:	2e 5f       	subi	r18, 0xFE	; 254
    4374:	3f 4f       	sbci	r19, 0xFF	; 255
    4376:	ca 01       	movw	r24, r20
    4378:	b9 01       	movw	r22, r18
    437a:	0e 94 b7 17 	call	0x2f6e	; 0x2f6e <vListInsertEnd>

			xReturn = pdPASS;
    437e:	81 e0       	ldi	r24, 0x01	; 1
    4380:	8d 83       	std	Y+5, r24	; 0x05
			traceTASK_CREATE( pxNewTCB );
		}
		taskEXIT_CRITICAL();
    4382:	0f 90       	pop	r0
    4384:	0f be       	out	0x3f, r0	; 63
    4386:	02 c0       	rjmp	.+4      	; 0x438c <xTaskGenericCreate+0x194>
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    4388:	8f ef       	ldi	r24, 0xFF	; 255
    438a:	8d 83       	std	Y+5, r24	; 0x05
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
    438c:	8d 81       	ldd	r24, Y+5	; 0x05
    438e:	81 30       	cpi	r24, 0x01	; 1
    4390:	71 f4       	brne	.+28     	; 0x43ae <xTaskGenericCreate+0x1b6>
	{
		if( xSchedulerRunning != pdFALSE )
    4392:	80 91 32 04 	lds	r24, 0x0432
    4396:	88 23       	and	r24, r24
    4398:	51 f0       	breq	.+20     	; 0x43ae <xTaskGenericCreate+0x1b6>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
    439a:	e0 91 2a 04 	lds	r30, 0x042A
    439e:	f0 91 2b 04 	lds	r31, 0x042B
    43a2:	96 89       	ldd	r25, Z+22	; 0x16
    43a4:	8e 85       	ldd	r24, Y+14	; 0x0e
    43a6:	98 17       	cp	r25, r24
    43a8:	10 f4       	brcc	.+4      	; 0x43ae <xTaskGenericCreate+0x1b6>
			{
				portYIELD_WITHIN_API();
    43aa:	0e 94 68 1b 	call	0x36d0	; 0x36d0 <vPortYield>
			}
		}
	}

	return xReturn;
    43ae:	8d 81       	ldd	r24, Y+5	; 0x05
}
    43b0:	64 96       	adiw	r28, 0x14	; 20
    43b2:	0f b6       	in	r0, 0x3f	; 63
    43b4:	f8 94       	cli
    43b6:	de bf       	out	0x3e, r29	; 62
    43b8:	0f be       	out	0x3f, r0	; 63
    43ba:	cd bf       	out	0x3d, r28	; 61
    43bc:	cf 91       	pop	r28
    43be:	df 91       	pop	r29
    43c0:	1f 91       	pop	r17
    43c2:	0f 91       	pop	r16
    43c4:	ff 90       	pop	r15
    43c6:	ef 90       	pop	r14
    43c8:	df 90       	pop	r13
    43ca:	cf 90       	pop	r12
    43cc:	bf 90       	pop	r11
    43ce:	af 90       	pop	r10
    43d0:	08 95       	ret

000043d2 <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	void vTaskDelete( xTaskHandle pxTaskToDelete )
	{
    43d2:	df 93       	push	r29
    43d4:	cf 93       	push	r28
    43d6:	00 d0       	rcall	.+0      	; 0x43d8 <vTaskDelete+0x6>
    43d8:	00 d0       	rcall	.+0      	; 0x43da <vTaskDelete+0x8>
    43da:	00 d0       	rcall	.+0      	; 0x43dc <vTaskDelete+0xa>
    43dc:	cd b7       	in	r28, 0x3d	; 61
    43de:	de b7       	in	r29, 0x3e	; 62
    43e0:	9c 83       	std	Y+4, r25	; 0x04
    43e2:	8b 83       	std	Y+3, r24	; 0x03
	tskTCB *pxTCB;

		taskENTER_CRITICAL();
    43e4:	0f b6       	in	r0, 0x3f	; 63
    43e6:	f8 94       	cli
    43e8:	0f 92       	push	r0
		{
			/* Ensure a yield is performed if the current task is being
			deleted. */
			if( pxTaskToDelete == pxCurrentTCB )
    43ea:	20 91 2a 04 	lds	r18, 0x042A
    43ee:	30 91 2b 04 	lds	r19, 0x042B
    43f2:	8b 81       	ldd	r24, Y+3	; 0x03
    43f4:	9c 81       	ldd	r25, Y+4	; 0x04
    43f6:	82 17       	cp	r24, r18
    43f8:	93 07       	cpc	r25, r19
    43fa:	11 f4       	brne	.+4      	; 0x4400 <vTaskDelete+0x2e>
			{
				pxTaskToDelete = NULL;
    43fc:	1c 82       	std	Y+4, r1	; 0x04
    43fe:	1b 82       	std	Y+3, r1	; 0x03
			}

			/* If null is passed in here then we are deleting ourselves. */
			pxTCB = prvGetTCBFromHandle( pxTaskToDelete );
    4400:	8b 81       	ldd	r24, Y+3	; 0x03
    4402:	9c 81       	ldd	r25, Y+4	; 0x04
    4404:	00 97       	sbiw	r24, 0x00	; 0
    4406:	39 f4       	brne	.+14     	; 0x4416 <vTaskDelete+0x44>
    4408:	80 91 2a 04 	lds	r24, 0x042A
    440c:	90 91 2b 04 	lds	r25, 0x042B
    4410:	9e 83       	std	Y+6, r25	; 0x06
    4412:	8d 83       	std	Y+5, r24	; 0x05
    4414:	04 c0       	rjmp	.+8      	; 0x441e <vTaskDelete+0x4c>
    4416:	8b 81       	ldd	r24, Y+3	; 0x03
    4418:	9c 81       	ldd	r25, Y+4	; 0x04
    441a:	9e 83       	std	Y+6, r25	; 0x06
    441c:	8d 83       	std	Y+5, r24	; 0x05
    441e:	8d 81       	ldd	r24, Y+5	; 0x05
    4420:	9e 81       	ldd	r25, Y+6	; 0x06
    4422:	9a 83       	std	Y+2, r25	; 0x02
    4424:	89 83       	std	Y+1, r24	; 0x01

			/* Remove task from the ready list and place in the	termination list.
			This will stop the task from be scheduled.  The idle task will check
			the termination list and free up any memory allocated by the
			scheduler for the TCB and stack. */
			vListRemove( &( pxTCB->xGenericListItem ) );
    4426:	89 81       	ldd	r24, Y+1	; 0x01
    4428:	9a 81       	ldd	r25, Y+2	; 0x02
    442a:	02 96       	adiw	r24, 0x02	; 2
    442c:	0e 94 6f 18 	call	0x30de	; 0x30de <vListRemove>

			/* Is the task waiting on an event also? */
			if( pxTCB->xEventListItem.pvContainer != NULL )
    4430:	e9 81       	ldd	r30, Y+1	; 0x01
    4432:	fa 81       	ldd	r31, Y+2	; 0x02
    4434:	84 89       	ldd	r24, Z+20	; 0x14
    4436:	95 89       	ldd	r25, Z+21	; 0x15
    4438:	00 97       	sbiw	r24, 0x00	; 0
    443a:	29 f0       	breq	.+10     	; 0x4446 <vTaskDelete+0x74>
			{
				vListRemove( &( pxTCB->xEventListItem ) );
    443c:	89 81       	ldd	r24, Y+1	; 0x01
    443e:	9a 81       	ldd	r25, Y+2	; 0x02
    4440:	0c 96       	adiw	r24, 0x0c	; 12
    4442:	0e 94 6f 18 	call	0x30de	; 0x30de <vListRemove>
			}

			vListInsertEnd( ( xList * ) &xTasksWaitingTermination, &( pxTCB->xGenericListItem ) );
    4446:	89 81       	ldd	r24, Y+1	; 0x01
    4448:	9a 81       	ldd	r25, Y+2	; 0x02
    444a:	9c 01       	movw	r18, r24
    444c:	2e 5f       	subi	r18, 0xFE	; 254
    444e:	3f 4f       	sbci	r19, 0xFF	; 255
    4450:	84 e8       	ldi	r24, 0x84	; 132
    4452:	94 e0       	ldi	r25, 0x04	; 4
    4454:	b9 01       	movw	r22, r18
    4456:	0e 94 b7 17 	call	0x2f6e	; 0x2f6e <vListInsertEnd>

			/* Increment the ucTasksDeleted variable so the idle task knows
			there is a task that has been deleted and that it should therefore
			check the xTasksWaitingTermination list. */
			++uxTasksDeleted;
    445a:	80 91 2c 04 	lds	r24, 0x042C
    445e:	8f 5f       	subi	r24, 0xFF	; 255
    4460:	80 93 2c 04 	sts	0x042C, r24

			/* Increment the uxTaskNumberVariable also so kernel aware debuggers
			can detect that the task lists need re-generating. */
			uxTaskNumber++;
    4464:	80 91 37 04 	lds	r24, 0x0437
    4468:	8f 5f       	subi	r24, 0xFF	; 255
    446a:	80 93 37 04 	sts	0x0437, r24

			traceTASK_DELETE( pxTCB );
		}
		taskEXIT_CRITICAL();
    446e:	0f 90       	pop	r0
    4470:	0f be       	out	0x3f, r0	; 63

		/* Force a reschedule if we have just deleted the current task. */
		if( xSchedulerRunning != pdFALSE )
    4472:	80 91 32 04 	lds	r24, 0x0432
    4476:	88 23       	and	r24, r24
    4478:	31 f0       	breq	.+12     	; 0x4486 <vTaskDelete+0xb4>
		{
			if( ( void * ) pxTaskToDelete == NULL )
    447a:	8b 81       	ldd	r24, Y+3	; 0x03
    447c:	9c 81       	ldd	r25, Y+4	; 0x04
    447e:	00 97       	sbiw	r24, 0x00	; 0
    4480:	11 f4       	brne	.+4      	; 0x4486 <vTaskDelete+0xb4>
			{
				portYIELD_WITHIN_API();
    4482:	0e 94 68 1b 	call	0x36d0	; 0x36d0 <vPortYield>
			}
		}
	}
    4486:	26 96       	adiw	r28, 0x06	; 6
    4488:	0f b6       	in	r0, 0x3f	; 63
    448a:	f8 94       	cli
    448c:	de bf       	out	0x3e, r29	; 62
    448e:	0f be       	out	0x3f, r0	; 63
    4490:	cd bf       	out	0x3d, r28	; 61
    4492:	cf 91       	pop	r28
    4494:	df 91       	pop	r29
    4496:	08 95       	ret

00004498 <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
    4498:	df 93       	push	r29
    449a:	cf 93       	push	r28
    449c:	cd b7       	in	r28, 0x3d	; 61
    449e:	de b7       	in	r29, 0x3e	; 62
    44a0:	28 97       	sbiw	r28, 0x08	; 8
    44a2:	0f b6       	in	r0, 0x3f	; 63
    44a4:	f8 94       	cli
    44a6:	de bf       	out	0x3e, r29	; 62
    44a8:	0f be       	out	0x3f, r0	; 63
    44aa:	cd bf       	out	0x3d, r28	; 61
    44ac:	9e 83       	std	Y+6, r25	; 0x06
    44ae:	8d 83       	std	Y+5, r24	; 0x05
    44b0:	78 87       	std	Y+8, r23	; 0x08
    44b2:	6f 83       	std	Y+7, r22	; 0x07
	portTickType xTimeToWake;
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;
    44b4:	19 82       	std	Y+1, r1	; 0x01

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );

		vTaskSuspendAll();
    44b6:	0e 94 38 23 	call	0x4670	; 0x4670 <vTaskSuspendAll>
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    44ba:	ed 81       	ldd	r30, Y+5	; 0x05
    44bc:	fe 81       	ldd	r31, Y+6	; 0x06
    44be:	20 81       	ld	r18, Z
    44c0:	31 81       	ldd	r19, Z+1	; 0x01
    44c2:	8f 81       	ldd	r24, Y+7	; 0x07
    44c4:	98 85       	ldd	r25, Y+8	; 0x08
    44c6:	82 0f       	add	r24, r18
    44c8:	93 1f       	adc	r25, r19
    44ca:	9c 83       	std	Y+4, r25	; 0x04
    44cc:	8b 83       	std	Y+3, r24	; 0x03

			if( xTickCount < *pxPreviousWakeTime )
    44ce:	ed 81       	ldd	r30, Y+5	; 0x05
    44d0:	fe 81       	ldd	r31, Y+6	; 0x06
    44d2:	20 81       	ld	r18, Z
    44d4:	31 81       	ldd	r19, Z+1	; 0x01
    44d6:	80 91 2e 04 	lds	r24, 0x042E
    44da:	90 91 2f 04 	lds	r25, 0x042F
    44de:	82 17       	cp	r24, r18
    44e0:	93 07       	cpc	r25, r19
    44e2:	a8 f4       	brcc	.+42     	; 0x450e <vTaskDelayUntil+0x76>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
    44e4:	ed 81       	ldd	r30, Y+5	; 0x05
    44e6:	fe 81       	ldd	r31, Y+6	; 0x06
    44e8:	20 81       	ld	r18, Z
    44ea:	31 81       	ldd	r19, Z+1	; 0x01
    44ec:	8b 81       	ldd	r24, Y+3	; 0x03
    44ee:	9c 81       	ldd	r25, Y+4	; 0x04
    44f0:	82 17       	cp	r24, r18
    44f2:	93 07       	cpc	r25, r19
    44f4:	00 f5       	brcc	.+64     	; 0x4536 <vTaskDelayUntil+0x9e>
    44f6:	20 91 2e 04 	lds	r18, 0x042E
    44fa:	30 91 2f 04 	lds	r19, 0x042F
    44fe:	8b 81       	ldd	r24, Y+3	; 0x03
    4500:	9c 81       	ldd	r25, Y+4	; 0x04
    4502:	28 17       	cp	r18, r24
    4504:	39 07       	cpc	r19, r25
    4506:	b8 f4       	brcc	.+46     	; 0x4536 <vTaskDelayUntil+0x9e>
				{
					xShouldDelay = pdTRUE;
    4508:	81 e0       	ldi	r24, 0x01	; 1
    450a:	89 83       	std	Y+1, r24	; 0x01
    450c:	14 c0       	rjmp	.+40     	; 0x4536 <vTaskDelayUntil+0x9e>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
    450e:	ed 81       	ldd	r30, Y+5	; 0x05
    4510:	fe 81       	ldd	r31, Y+6	; 0x06
    4512:	20 81       	ld	r18, Z
    4514:	31 81       	ldd	r19, Z+1	; 0x01
    4516:	8b 81       	ldd	r24, Y+3	; 0x03
    4518:	9c 81       	ldd	r25, Y+4	; 0x04
    451a:	82 17       	cp	r24, r18
    451c:	93 07       	cpc	r25, r19
    451e:	48 f0       	brcs	.+18     	; 0x4532 <vTaskDelayUntil+0x9a>
    4520:	20 91 2e 04 	lds	r18, 0x042E
    4524:	30 91 2f 04 	lds	r19, 0x042F
    4528:	8b 81       	ldd	r24, Y+3	; 0x03
    452a:	9c 81       	ldd	r25, Y+4	; 0x04
    452c:	28 17       	cp	r18, r24
    452e:	39 07       	cpc	r19, r25
    4530:	10 f4       	brcc	.+4      	; 0x4536 <vTaskDelayUntil+0x9e>
				{
					xShouldDelay = pdTRUE;
    4532:	81 e0       	ldi	r24, 0x01	; 1
    4534:	89 83       	std	Y+1, r24	; 0x01
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    4536:	ed 81       	ldd	r30, Y+5	; 0x05
    4538:	fe 81       	ldd	r31, Y+6	; 0x06
    453a:	8b 81       	ldd	r24, Y+3	; 0x03
    453c:	9c 81       	ldd	r25, Y+4	; 0x04
    453e:	91 83       	std	Z+1, r25	; 0x01
    4540:	80 83       	st	Z, r24

			if( xShouldDelay != pdFALSE )
    4542:	89 81       	ldd	r24, Y+1	; 0x01
    4544:	88 23       	and	r24, r24
    4546:	59 f0       	breq	.+22     	; 0x455e <vTaskDelayUntil+0xc6>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    4548:	80 91 2a 04 	lds	r24, 0x042A
    454c:	90 91 2b 04 	lds	r25, 0x042B
    4550:	02 96       	adiw	r24, 0x02	; 2
    4552:	0e 94 6f 18 	call	0x30de	; 0x30de <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    4556:	8b 81       	ldd	r24, Y+3	; 0x03
    4558:	9c 81       	ldd	r25, Y+4	; 0x04
    455a:	0e 94 38 27 	call	0x4e70	; 0x4e70 <prvAddCurrentTaskToDelayedList>
			}
		}
		xAlreadyYielded = xTaskResumeAll();
    455e:	0e 94 44 23 	call	0x4688	; 0x4688 <xTaskResumeAll>
    4562:	8a 83       	std	Y+2, r24	; 0x02

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    4564:	8a 81       	ldd	r24, Y+2	; 0x02
    4566:	88 23       	and	r24, r24
    4568:	11 f4       	brne	.+4      	; 0x456e <vTaskDelayUntil+0xd6>
		{
			portYIELD_WITHIN_API();
    456a:	0e 94 68 1b 	call	0x36d0	; 0x36d0 <vPortYield>
		}
	}
    456e:	28 96       	adiw	r28, 0x08	; 8
    4570:	0f b6       	in	r0, 0x3f	; 63
    4572:	f8 94       	cli
    4574:	de bf       	out	0x3e, r29	; 62
    4576:	0f be       	out	0x3f, r0	; 63
    4578:	cd bf       	out	0x3d, r28	; 61
    457a:	cf 91       	pop	r28
    457c:	df 91       	pop	r29
    457e:	08 95       	ret

00004580 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
    4580:	df 93       	push	r29
    4582:	cf 93       	push	r28
    4584:	00 d0       	rcall	.+0      	; 0x4586 <vTaskDelay+0x6>
    4586:	00 d0       	rcall	.+0      	; 0x4588 <vTaskDelay+0x8>
    4588:	0f 92       	push	r0
    458a:	cd b7       	in	r28, 0x3d	; 61
    458c:	de b7       	in	r29, 0x3e	; 62
    458e:	9d 83       	std	Y+5, r25	; 0x05
    4590:	8c 83       	std	Y+4, r24	; 0x04
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;
    4592:	19 82       	std	Y+1, r1	; 0x01

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0U )
    4594:	8c 81       	ldd	r24, Y+4	; 0x04
    4596:	9d 81       	ldd	r25, Y+5	; 0x05
    4598:	00 97       	sbiw	r24, 0x00	; 0
    459a:	d1 f0       	breq	.+52     	; 0x45d0 <vTaskDelay+0x50>
		{
			vTaskSuspendAll();
    459c:	0e 94 38 23 	call	0x4670	; 0x4670 <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
    45a0:	20 91 2e 04 	lds	r18, 0x042E
    45a4:	30 91 2f 04 	lds	r19, 0x042F
    45a8:	8c 81       	ldd	r24, Y+4	; 0x04
    45aa:	9d 81       	ldd	r25, Y+5	; 0x05
    45ac:	82 0f       	add	r24, r18
    45ae:	93 1f       	adc	r25, r19
    45b0:	9b 83       	std	Y+3, r25	; 0x03
    45b2:	8a 83       	std	Y+2, r24	; 0x02

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    45b4:	80 91 2a 04 	lds	r24, 0x042A
    45b8:	90 91 2b 04 	lds	r25, 0x042B
    45bc:	02 96       	adiw	r24, 0x02	; 2
    45be:	0e 94 6f 18 	call	0x30de	; 0x30de <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    45c2:	8a 81       	ldd	r24, Y+2	; 0x02
    45c4:	9b 81       	ldd	r25, Y+3	; 0x03
    45c6:	0e 94 38 27 	call	0x4e70	; 0x4e70 <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    45ca:	0e 94 44 23 	call	0x4688	; 0x4688 <xTaskResumeAll>
    45ce:	89 83       	std	Y+1, r24	; 0x01
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    45d0:	89 81       	ldd	r24, Y+1	; 0x01
    45d2:	88 23       	and	r24, r24
    45d4:	11 f4       	brne	.+4      	; 0x45da <vTaskDelay+0x5a>
		{
			portYIELD_WITHIN_API();
    45d6:	0e 94 68 1b 	call	0x36d0	; 0x36d0 <vPortYield>
		}
	}
    45da:	0f 90       	pop	r0
    45dc:	0f 90       	pop	r0
    45de:	0f 90       	pop	r0
    45e0:	0f 90       	pop	r0
    45e2:	0f 90       	pop	r0
    45e4:	cf 91       	pop	r28
    45e6:	df 91       	pop	r29
    45e8:	08 95       	ret

000045ea <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
    45ea:	af 92       	push	r10
    45ec:	bf 92       	push	r11
    45ee:	cf 92       	push	r12
    45f0:	df 92       	push	r13
    45f2:	ef 92       	push	r14
    45f4:	ff 92       	push	r15
    45f6:	0f 93       	push	r16
    45f8:	df 93       	push	r29
    45fa:	cf 93       	push	r28
    45fc:	0f 92       	push	r0
    45fe:	cd b7       	in	r28, 0x3d	; 61
    4600:	de b7       	in	r29, 0x3e	; 62
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), &xIdleTaskHandle );
	}
	#else
	{
		/* Create the idle task without storing its handle. */
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), NULL );
    4602:	21 e8       	ldi	r18, 0x81	; 129
    4604:	30 e0       	ldi	r19, 0x00	; 0
    4606:	8c e5       	ldi	r24, 0x5C	; 92
    4608:	96 e2       	ldi	r25, 0x26	; 38
    460a:	b9 01       	movw	r22, r18
    460c:	45 e5       	ldi	r20, 0x55	; 85
    460e:	50 e0       	ldi	r21, 0x00	; 0
    4610:	20 e0       	ldi	r18, 0x00	; 0
    4612:	30 e0       	ldi	r19, 0x00	; 0
    4614:	00 e0       	ldi	r16, 0x00	; 0
    4616:	ee 24       	eor	r14, r14
    4618:	ff 24       	eor	r15, r15
    461a:	cc 24       	eor	r12, r12
    461c:	dd 24       	eor	r13, r13
    461e:	aa 24       	eor	r10, r10
    4620:	bb 24       	eor	r11, r11
    4622:	0e 94 fc 20 	call	0x41f8	; 0x41f8 <xTaskGenericCreate>
    4626:	89 83       	std	Y+1, r24	; 0x01
			xReturn = xTimerCreateTimerTask();
		}
	}
	#endif

	if( xReturn == pdPASS )
    4628:	89 81       	ldd	r24, Y+1	; 0x01
    462a:	81 30       	cpi	r24, 0x01	; 1
    462c:	51 f4       	brne	.+20     	; 0x4642 <vTaskStartScheduler+0x58>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
    462e:	f8 94       	cli

		xSchedulerRunning = pdTRUE;
    4630:	81 e0       	ldi	r24, 0x01	; 1
    4632:	80 93 32 04 	sts	0x0432, r24
		xTickCount = ( portTickType ) 0U;
    4636:	10 92 2f 04 	sts	0x042F, r1
    463a:	10 92 2e 04 	sts	0x042E, r1
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();
		
		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
    463e:	0e 94 2c 1b 	call	0x3658	; 0x3658 <xPortStartScheduler>
		}
	}

	/* This line will only be reached if the kernel could not be started. */
	configASSERT( xReturn );
}
    4642:	0f 90       	pop	r0
    4644:	cf 91       	pop	r28
    4646:	df 91       	pop	r29
    4648:	0f 91       	pop	r16
    464a:	ff 90       	pop	r15
    464c:	ef 90       	pop	r14
    464e:	df 90       	pop	r13
    4650:	cf 90       	pop	r12
    4652:	bf 90       	pop	r11
    4654:	af 90       	pop	r10
    4656:	08 95       	ret

00004658 <vTaskEndScheduler>:
/*-----------------------------------------------------------*/

void vTaskEndScheduler( void )
{
    4658:	df 93       	push	r29
    465a:	cf 93       	push	r28
    465c:	cd b7       	in	r28, 0x3d	; 61
    465e:	de b7       	in	r29, 0x3e	; 62
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
    4660:	f8 94       	cli
	xSchedulerRunning = pdFALSE;
    4662:	10 92 32 04 	sts	0x0432, r1
	vPortEndScheduler();
    4666:	0e 94 61 1b 	call	0x36c2	; 0x36c2 <vPortEndScheduler>
}
    466a:	cf 91       	pop	r28
    466c:	df 91       	pop	r29
    466e:	08 95       	ret

00004670 <vTaskSuspendAll>:
/*----------------------------------------------------------*/

void vTaskSuspendAll( void )
{
    4670:	df 93       	push	r29
    4672:	cf 93       	push	r28
    4674:	cd b7       	in	r28, 0x3d	; 61
    4676:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
    4678:	80 91 33 04 	lds	r24, 0x0433
    467c:	8f 5f       	subi	r24, 0xFF	; 255
    467e:	80 93 33 04 	sts	0x0433, r24
}
    4682:	cf 91       	pop	r28
    4684:	df 91       	pop	r29
    4686:	08 95       	ret

00004688 <xTaskResumeAll>:
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
    4688:	df 93       	push	r29
    468a:	cf 93       	push	r28
    468c:	00 d0       	rcall	.+0      	; 0x468e <xTaskResumeAll+0x6>
    468e:	00 d0       	rcall	.+0      	; 0x4690 <xTaskResumeAll+0x8>
    4690:	cd b7       	in	r28, 0x3d	; 61
    4692:	de b7       	in	r29, 0x3e	; 62
register tskTCB *pxTCB;
signed portBASE_TYPE xAlreadyYielded = pdFALSE;
    4694:	1a 82       	std	Y+2, r1	; 0x02
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
    4696:	0f b6       	in	r0, 0x3f	; 63
    4698:	f8 94       	cli
    469a:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
    469c:	80 91 33 04 	lds	r24, 0x0433
    46a0:	81 50       	subi	r24, 0x01	; 1
    46a2:	80 93 33 04 	sts	0x0433, r24

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    46a6:	80 91 33 04 	lds	r24, 0x0433
    46aa:	88 23       	and	r24, r24
    46ac:	09 f0       	breq	.+2      	; 0x46b0 <xTaskResumeAll+0x28>
    46ae:	6c c0       	rjmp	.+216    	; 0x4788 <xTaskResumeAll+0x100>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0U )
    46b0:	80 91 2d 04 	lds	r24, 0x042D
    46b4:	88 23       	and	r24, r24
    46b6:	09 f4       	brne	.+2      	; 0x46ba <xTaskResumeAll+0x32>
    46b8:	67 c0       	rjmp	.+206    	; 0x4788 <xTaskResumeAll+0x100>
			{
				portBASE_TYPE xYieldRequired = pdFALSE;
    46ba:	19 82       	std	Y+1, r1	; 0x01
    46bc:	41 c0       	rjmp	.+130    	; 0x4740 <xTaskResumeAll+0xb8>

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
    46be:	e0 91 80 04 	lds	r30, 0x0480
    46c2:	f0 91 81 04 	lds	r31, 0x0481
    46c6:	86 81       	ldd	r24, Z+6	; 0x06
    46c8:	97 81       	ldd	r25, Z+7	; 0x07
    46ca:	9c 83       	std	Y+4, r25	; 0x04
    46cc:	8b 83       	std	Y+3, r24	; 0x03
					vListRemove( &( pxTCB->xEventListItem ) );
    46ce:	8b 81       	ldd	r24, Y+3	; 0x03
    46d0:	9c 81       	ldd	r25, Y+4	; 0x04
    46d2:	0c 96       	adiw	r24, 0x0c	; 12
    46d4:	0e 94 6f 18 	call	0x30de	; 0x30de <vListRemove>
					vListRemove( &( pxTCB->xGenericListItem ) );
    46d8:	8b 81       	ldd	r24, Y+3	; 0x03
    46da:	9c 81       	ldd	r25, Y+4	; 0x04
    46dc:	02 96       	adiw	r24, 0x02	; 2
    46de:	0e 94 6f 18 	call	0x30de	; 0x30de <vListRemove>
					prvAddTaskToReadyQueue( pxTCB );
    46e2:	eb 81       	ldd	r30, Y+3	; 0x03
    46e4:	fc 81       	ldd	r31, Y+4	; 0x04
    46e6:	96 89       	ldd	r25, Z+22	; 0x16
    46e8:	80 91 31 04 	lds	r24, 0x0431
    46ec:	89 17       	cp	r24, r25
    46ee:	28 f4       	brcc	.+10     	; 0x46fa <xTaskResumeAll+0x72>
    46f0:	eb 81       	ldd	r30, Y+3	; 0x03
    46f2:	fc 81       	ldd	r31, Y+4	; 0x04
    46f4:	86 89       	ldd	r24, Z+22	; 0x16
    46f6:	80 93 31 04 	sts	0x0431, r24
    46fa:	eb 81       	ldd	r30, Y+3	; 0x03
    46fc:	fc 81       	ldd	r31, Y+4	; 0x04
    46fe:	86 89       	ldd	r24, Z+22	; 0x16
    4700:	28 2f       	mov	r18, r24
    4702:	30 e0       	ldi	r19, 0x00	; 0
    4704:	c9 01       	movw	r24, r18
    4706:	88 0f       	add	r24, r24
    4708:	99 1f       	adc	r25, r25
    470a:	88 0f       	add	r24, r24
    470c:	99 1f       	adc	r25, r25
    470e:	88 0f       	add	r24, r24
    4710:	99 1f       	adc	r25, r25
    4712:	82 0f       	add	r24, r18
    4714:	93 1f       	adc	r25, r19
    4716:	88 5c       	subi	r24, 0xC8	; 200
    4718:	9b 4f       	sbci	r25, 0xFB	; 251
    471a:	2b 81       	ldd	r18, Y+3	; 0x03
    471c:	3c 81       	ldd	r19, Y+4	; 0x04
    471e:	2e 5f       	subi	r18, 0xFE	; 254
    4720:	3f 4f       	sbci	r19, 0xFF	; 255
    4722:	b9 01       	movw	r22, r18
    4724:	0e 94 b7 17 	call	0x2f6e	; 0x2f6e <vListInsertEnd>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    4728:	eb 81       	ldd	r30, Y+3	; 0x03
    472a:	fc 81       	ldd	r31, Y+4	; 0x04
    472c:	96 89       	ldd	r25, Z+22	; 0x16
    472e:	e0 91 2a 04 	lds	r30, 0x042A
    4732:	f0 91 2b 04 	lds	r31, 0x042B
    4736:	86 89       	ldd	r24, Z+22	; 0x16
    4738:	98 17       	cp	r25, r24
    473a:	10 f0       	brcs	.+4      	; 0x4740 <xTaskResumeAll+0xb8>
					{
						xYieldRequired = pdTRUE;
    473c:	81 e0       	ldi	r24, 0x01	; 1
    473e:	89 83       	std	Y+1, r24	; 0x01
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
    4740:	80 91 7b 04 	lds	r24, 0x047B
    4744:	88 23       	and	r24, r24
    4746:	09 f0       	breq	.+2      	; 0x474a <xTaskResumeAll+0xc2>
    4748:	ba cf       	rjmp	.-140    	; 0x46be <xTaskResumeAll+0x36>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    474a:	80 91 34 04 	lds	r24, 0x0434
    474e:	88 23       	and	r24, r24
    4750:	71 f0       	breq	.+28     	; 0x476e <xTaskResumeAll+0xe6>
    4752:	07 c0       	rjmp	.+14     	; 0x4762 <xTaskResumeAll+0xda>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
					{
						vTaskIncrementTick();
    4754:	0e 94 03 24 	call	0x4806	; 0x4806 <vTaskIncrementTick>
						--uxMissedTicks;
    4758:	80 91 34 04 	lds	r24, 0x0434
    475c:	81 50       	subi	r24, 0x01	; 1
    475e:	80 93 34 04 	sts	0x0434, r24
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    4762:	80 91 34 04 	lds	r24, 0x0434
    4766:	88 23       	and	r24, r24
    4768:	a9 f7       	brne	.-22     	; 0x4754 <xTaskResumeAll+0xcc>
					/* As we have processed some ticks it is appropriate to yield
					to ensure the highest priority task that is ready to run is
					the task actually running. */
					#if configUSE_PREEMPTION == 1
					{
						xYieldRequired = pdTRUE;
    476a:	81 e0       	ldi	r24, 0x01	; 1
    476c:	89 83       	std	Y+1, r24	; 0x01
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
    476e:	89 81       	ldd	r24, Y+1	; 0x01
    4770:	81 30       	cpi	r24, 0x01	; 1
    4772:	21 f0       	breq	.+8      	; 0x477c <xTaskResumeAll+0xf4>
    4774:	80 91 35 04 	lds	r24, 0x0435
    4778:	81 30       	cpi	r24, 0x01	; 1
    477a:	31 f4       	brne	.+12     	; 0x4788 <xTaskResumeAll+0x100>
				{
					xAlreadyYielded = pdTRUE;
    477c:	81 e0       	ldi	r24, 0x01	; 1
    477e:	8a 83       	std	Y+2, r24	; 0x02
					xMissedYield = pdFALSE;
    4780:	10 92 35 04 	sts	0x0435, r1
					portYIELD_WITHIN_API();
    4784:	0e 94 68 1b 	call	0x36d0	; 0x36d0 <vPortYield>
				}
			}
		}
	}
	taskEXIT_CRITICAL();
    4788:	0f 90       	pop	r0
    478a:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
    478c:	8a 81       	ldd	r24, Y+2	; 0x02
}
    478e:	0f 90       	pop	r0
    4790:	0f 90       	pop	r0
    4792:	0f 90       	pop	r0
    4794:	0f 90       	pop	r0
    4796:	cf 91       	pop	r28
    4798:	df 91       	pop	r29
    479a:	08 95       	ret

0000479c <xTaskGetTickCount>:
 *----------------------------------------------------------*/



portTickType xTaskGetTickCount( void )
{
    479c:	df 93       	push	r29
    479e:	cf 93       	push	r28
    47a0:	00 d0       	rcall	.+0      	; 0x47a2 <xTaskGetTickCount+0x6>
    47a2:	cd b7       	in	r28, 0x3d	; 61
    47a4:	de b7       	in	r29, 0x3e	; 62
portTickType xTicks;

	/* Critical section required if running on a 16 bit processor. */
	taskENTER_CRITICAL();
    47a6:	0f b6       	in	r0, 0x3f	; 63
    47a8:	f8 94       	cli
    47aa:	0f 92       	push	r0
	{
		xTicks = xTickCount;
    47ac:	80 91 2e 04 	lds	r24, 0x042E
    47b0:	90 91 2f 04 	lds	r25, 0x042F
    47b4:	9a 83       	std	Y+2, r25	; 0x02
    47b6:	89 83       	std	Y+1, r24	; 0x01
	}
	taskEXIT_CRITICAL();
    47b8:	0f 90       	pop	r0
    47ba:	0f be       	out	0x3f, r0	; 63

	return xTicks;
    47bc:	89 81       	ldd	r24, Y+1	; 0x01
    47be:	9a 81       	ldd	r25, Y+2	; 0x02
}
    47c0:	0f 90       	pop	r0
    47c2:	0f 90       	pop	r0
    47c4:	cf 91       	pop	r28
    47c6:	df 91       	pop	r29
    47c8:	08 95       	ret

000047ca <xTaskGetTickCountFromISR>:
/*-----------------------------------------------------------*/

portTickType xTaskGetTickCountFromISR( void )
{
    47ca:	df 93       	push	r29
    47cc:	cf 93       	push	r28
    47ce:	00 d0       	rcall	.+0      	; 0x47d0 <xTaskGetTickCountFromISR+0x6>
    47d0:	0f 92       	push	r0
    47d2:	cd b7       	in	r28, 0x3d	; 61
    47d4:	de b7       	in	r29, 0x3e	; 62
portTickType xReturn;
unsigned portBASE_TYPE uxSavedInterruptStatus;

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    47d6:	19 82       	std	Y+1, r1	; 0x01
	xReturn = xTickCount;
    47d8:	80 91 2e 04 	lds	r24, 0x042E
    47dc:	90 91 2f 04 	lds	r25, 0x042F
    47e0:	9b 83       	std	Y+3, r25	; 0x03
    47e2:	8a 83       	std	Y+2, r24	; 0x02
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    47e4:	8a 81       	ldd	r24, Y+2	; 0x02
    47e6:	9b 81       	ldd	r25, Y+3	; 0x03
}
    47e8:	0f 90       	pop	r0
    47ea:	0f 90       	pop	r0
    47ec:	0f 90       	pop	r0
    47ee:	cf 91       	pop	r28
    47f0:	df 91       	pop	r29
    47f2:	08 95       	ret

000047f4 <uxTaskGetNumberOfTasks>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxTaskGetNumberOfTasks( void )
{
    47f4:	df 93       	push	r29
    47f6:	cf 93       	push	r28
    47f8:	cd b7       	in	r28, 0x3d	; 61
    47fa:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required because the variables are of type
	portBASE_TYPE. */
	return uxCurrentNumberOfTasks;
    47fc:	80 91 2d 04 	lds	r24, 0x042D
}
    4800:	cf 91       	pop	r28
    4802:	df 91       	pop	r29
    4804:	08 95       	ret

00004806 <vTaskIncrementTick>:
 * SCHEDULER INTERNALS AVAILABLE FOR PORTING PURPOSES
 * documented in task.h
 *----------------------------------------------------------*/

void vTaskIncrementTick( void )
{
    4806:	df 93       	push	r29
    4808:	cf 93       	push	r28
    480a:	00 d0       	rcall	.+0      	; 0x480c <vTaskIncrementTick+0x6>
    480c:	00 d0       	rcall	.+0      	; 0x480e <vTaskIncrementTick+0x8>
    480e:	00 d0       	rcall	.+0      	; 0x4810 <vTaskIncrementTick+0xa>
    4810:	cd b7       	in	r28, 0x3d	; 61
    4812:	de b7       	in	r29, 0x3e	; 62
tskTCB * pxTCB;

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    4814:	80 91 33 04 	lds	r24, 0x0433
    4818:	88 23       	and	r24, r24
    481a:	09 f0       	breq	.+2      	; 0x481e <vTaskIncrementTick+0x18>
    481c:	bb c0       	rjmp	.+374    	; 0x4994 <vTaskIncrementTick+0x18e>
	{
		++xTickCount;
    481e:	80 91 2e 04 	lds	r24, 0x042E
    4822:	90 91 2f 04 	lds	r25, 0x042F
    4826:	01 96       	adiw	r24, 0x01	; 1
    4828:	90 93 2f 04 	sts	0x042F, r25
    482c:	80 93 2e 04 	sts	0x042E, r24
		if( xTickCount == ( portTickType ) 0U )
    4830:	80 91 2e 04 	lds	r24, 0x042E
    4834:	90 91 2f 04 	lds	r25, 0x042F
    4838:	00 97       	sbiw	r24, 0x00	; 0
    483a:	d1 f5       	brne	.+116    	; 0x48b0 <vTaskIncrementTick+0xaa>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );
			
			pxTemp = pxDelayedTaskList;
    483c:	80 91 77 04 	lds	r24, 0x0477
    4840:	90 91 78 04 	lds	r25, 0x0478
    4844:	9c 83       	std	Y+4, r25	; 0x04
    4846:	8b 83       	std	Y+3, r24	; 0x03
			pxDelayedTaskList = pxOverflowDelayedTaskList;
    4848:	80 91 79 04 	lds	r24, 0x0479
    484c:	90 91 7a 04 	lds	r25, 0x047A
    4850:	90 93 78 04 	sts	0x0478, r25
    4854:	80 93 77 04 	sts	0x0477, r24
			pxOverflowDelayedTaskList = pxTemp;
    4858:	8b 81       	ldd	r24, Y+3	; 0x03
    485a:	9c 81       	ldd	r25, Y+4	; 0x04
    485c:	90 93 7a 04 	sts	0x047A, r25
    4860:	80 93 79 04 	sts	0x0479, r24
			xNumOfOverflows++;
    4864:	80 91 36 04 	lds	r24, 0x0436
    4868:	8f 5f       	subi	r24, 0xFF	; 255
    486a:	80 93 36 04 	sts	0x0436, r24
	
			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    486e:	e0 91 77 04 	lds	r30, 0x0477
    4872:	f0 91 78 04 	lds	r31, 0x0478
    4876:	80 81       	ld	r24, Z
    4878:	88 23       	and	r24, r24
    487a:	39 f4       	brne	.+14     	; 0x488a <vTaskIncrementTick+0x84>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the	
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
    487c:	8f ef       	ldi	r24, 0xFF	; 255
    487e:	9f ef       	ldi	r25, 0xFF	; 255
    4880:	90 93 90 01 	sts	0x0190, r25
    4884:	80 93 8f 01 	sts	0x018F, r24
    4888:	13 c0       	rjmp	.+38     	; 0x48b0 <vTaskIncrementTick+0xaa>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    488a:	e0 91 77 04 	lds	r30, 0x0477
    488e:	f0 91 78 04 	lds	r31, 0x0478
    4892:	05 80       	ldd	r0, Z+5	; 0x05
    4894:	f6 81       	ldd	r31, Z+6	; 0x06
    4896:	e0 2d       	mov	r30, r0
    4898:	86 81       	ldd	r24, Z+6	; 0x06
    489a:	97 81       	ldd	r25, Z+7	; 0x07
    489c:	9e 83       	std	Y+6, r25	; 0x06
    489e:	8d 83       	std	Y+5, r24	; 0x05
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
    48a0:	ed 81       	ldd	r30, Y+5	; 0x05
    48a2:	fe 81       	ldd	r31, Y+6	; 0x06
    48a4:	82 81       	ldd	r24, Z+2	; 0x02
    48a6:	93 81       	ldd	r25, Z+3	; 0x03
    48a8:	90 93 90 01 	sts	0x0190, r25
    48ac:	80 93 8f 01 	sts	0x018F, r24
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
    48b0:	20 91 2e 04 	lds	r18, 0x042E
    48b4:	30 91 2f 04 	lds	r19, 0x042F
    48b8:	80 91 8f 01 	lds	r24, 0x018F
    48bc:	90 91 90 01 	lds	r25, 0x0190
    48c0:	28 17       	cp	r18, r24
    48c2:	39 07       	cpc	r19, r25
    48c4:	08 f4       	brcc	.+2      	; 0x48c8 <vTaskIncrementTick+0xc2>
    48c6:	6b c0       	rjmp	.+214    	; 0x499e <vTaskIncrementTick+0x198>
    48c8:	e0 91 77 04 	lds	r30, 0x0477
    48cc:	f0 91 78 04 	lds	r31, 0x0478
    48d0:	80 81       	ld	r24, Z
    48d2:	88 23       	and	r24, r24
    48d4:	39 f4       	brne	.+14     	; 0x48e4 <vTaskIncrementTick+0xde>
    48d6:	8f ef       	ldi	r24, 0xFF	; 255
    48d8:	9f ef       	ldi	r25, 0xFF	; 255
    48da:	90 93 90 01 	sts	0x0190, r25
    48de:	80 93 8f 01 	sts	0x018F, r24
    48e2:	5d c0       	rjmp	.+186    	; 0x499e <vTaskIncrementTick+0x198>
    48e4:	e0 91 77 04 	lds	r30, 0x0477
    48e8:	f0 91 78 04 	lds	r31, 0x0478
    48ec:	05 80       	ldd	r0, Z+5	; 0x05
    48ee:	f6 81       	ldd	r31, Z+6	; 0x06
    48f0:	e0 2d       	mov	r30, r0
    48f2:	86 81       	ldd	r24, Z+6	; 0x06
    48f4:	97 81       	ldd	r25, Z+7	; 0x07
    48f6:	9e 83       	std	Y+6, r25	; 0x06
    48f8:	8d 83       	std	Y+5, r24	; 0x05
    48fa:	ed 81       	ldd	r30, Y+5	; 0x05
    48fc:	fe 81       	ldd	r31, Y+6	; 0x06
    48fe:	82 81       	ldd	r24, Z+2	; 0x02
    4900:	93 81       	ldd	r25, Z+3	; 0x03
    4902:	9a 83       	std	Y+2, r25	; 0x02
    4904:	89 83       	std	Y+1, r24	; 0x01
    4906:	20 91 2e 04 	lds	r18, 0x042E
    490a:	30 91 2f 04 	lds	r19, 0x042F
    490e:	89 81       	ldd	r24, Y+1	; 0x01
    4910:	9a 81       	ldd	r25, Y+2	; 0x02
    4912:	28 17       	cp	r18, r24
    4914:	39 07       	cpc	r19, r25
    4916:	38 f4       	brcc	.+14     	; 0x4926 <vTaskIncrementTick+0x120>
    4918:	89 81       	ldd	r24, Y+1	; 0x01
    491a:	9a 81       	ldd	r25, Y+2	; 0x02
    491c:	90 93 90 01 	sts	0x0190, r25
    4920:	80 93 8f 01 	sts	0x018F, r24
    4924:	3c c0       	rjmp	.+120    	; 0x499e <vTaskIncrementTick+0x198>
    4926:	8d 81       	ldd	r24, Y+5	; 0x05
    4928:	9e 81       	ldd	r25, Y+6	; 0x06
    492a:	02 96       	adiw	r24, 0x02	; 2
    492c:	0e 94 6f 18 	call	0x30de	; 0x30de <vListRemove>
    4930:	ed 81       	ldd	r30, Y+5	; 0x05
    4932:	fe 81       	ldd	r31, Y+6	; 0x06
    4934:	84 89       	ldd	r24, Z+20	; 0x14
    4936:	95 89       	ldd	r25, Z+21	; 0x15
    4938:	00 97       	sbiw	r24, 0x00	; 0
    493a:	29 f0       	breq	.+10     	; 0x4946 <vTaskIncrementTick+0x140>
    493c:	8d 81       	ldd	r24, Y+5	; 0x05
    493e:	9e 81       	ldd	r25, Y+6	; 0x06
    4940:	0c 96       	adiw	r24, 0x0c	; 12
    4942:	0e 94 6f 18 	call	0x30de	; 0x30de <vListRemove>
    4946:	ed 81       	ldd	r30, Y+5	; 0x05
    4948:	fe 81       	ldd	r31, Y+6	; 0x06
    494a:	96 89       	ldd	r25, Z+22	; 0x16
    494c:	80 91 31 04 	lds	r24, 0x0431
    4950:	89 17       	cp	r24, r25
    4952:	28 f4       	brcc	.+10     	; 0x495e <vTaskIncrementTick+0x158>
    4954:	ed 81       	ldd	r30, Y+5	; 0x05
    4956:	fe 81       	ldd	r31, Y+6	; 0x06
    4958:	86 89       	ldd	r24, Z+22	; 0x16
    495a:	80 93 31 04 	sts	0x0431, r24
    495e:	ed 81       	ldd	r30, Y+5	; 0x05
    4960:	fe 81       	ldd	r31, Y+6	; 0x06
    4962:	86 89       	ldd	r24, Z+22	; 0x16
    4964:	28 2f       	mov	r18, r24
    4966:	30 e0       	ldi	r19, 0x00	; 0
    4968:	c9 01       	movw	r24, r18
    496a:	88 0f       	add	r24, r24
    496c:	99 1f       	adc	r25, r25
    496e:	88 0f       	add	r24, r24
    4970:	99 1f       	adc	r25, r25
    4972:	88 0f       	add	r24, r24
    4974:	99 1f       	adc	r25, r25
    4976:	82 0f       	add	r24, r18
    4978:	93 1f       	adc	r25, r19
    497a:	ac 01       	movw	r20, r24
    497c:	48 5c       	subi	r20, 0xC8	; 200
    497e:	5b 4f       	sbci	r21, 0xFB	; 251
    4980:	8d 81       	ldd	r24, Y+5	; 0x05
    4982:	9e 81       	ldd	r25, Y+6	; 0x06
    4984:	9c 01       	movw	r18, r24
    4986:	2e 5f       	subi	r18, 0xFE	; 254
    4988:	3f 4f       	sbci	r19, 0xFF	; 255
    498a:	ca 01       	movw	r24, r20
    498c:	b9 01       	movw	r22, r18
    498e:	0e 94 b7 17 	call	0x2f6e	; 0x2f6e <vListInsertEnd>
    4992:	9a cf       	rjmp	.-204    	; 0x48c8 <vTaskIncrementTick+0xc2>
	}
	else
	{
		++uxMissedTicks;
    4994:	80 91 34 04 	lds	r24, 0x0434
    4998:	8f 5f       	subi	r24, 0xFF	; 255
    499a:	80 93 34 04 	sts	0x0434, r24
		}
	}
	#endif

	traceTASK_INCREMENT_TICK( xTickCount );
}
    499e:	26 96       	adiw	r28, 0x06	; 6
    49a0:	0f b6       	in	r0, 0x3f	; 63
    49a2:	f8 94       	cli
    49a4:	de bf       	out	0x3e, r29	; 62
    49a6:	0f be       	out	0x3f, r0	; 63
    49a8:	cd bf       	out	0x3d, r28	; 61
    49aa:	cf 91       	pop	r28
    49ac:	df 91       	pop	r29
    49ae:	08 95       	ret

000049b0 <vTaskSwitchContext>:

#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
    49b0:	df 93       	push	r29
    49b2:	cf 93       	push	r28
    49b4:	00 d0       	rcall	.+0      	; 0x49b6 <vTaskSwitchContext+0x6>
    49b6:	cd b7       	in	r28, 0x3d	; 61
    49b8:	de b7       	in	r29, 0x3e	; 62
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
    49ba:	80 91 33 04 	lds	r24, 0x0433
    49be:	88 23       	and	r24, r24
    49c0:	49 f0       	breq	.+18     	; 0x49d4 <vTaskSwitchContext+0x24>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
    49c2:	81 e0       	ldi	r24, 0x01	; 1
    49c4:	80 93 35 04 	sts	0x0435, r24
    49c8:	54 c0       	rjmp	.+168    	; 0x4a72 <vTaskSwitchContext+0xc2>
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
    49ca:	80 91 31 04 	lds	r24, 0x0431
    49ce:	81 50       	subi	r24, 0x01	; 1
    49d0:	80 93 31 04 	sts	0x0431, r24
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    49d4:	80 91 31 04 	lds	r24, 0x0431
    49d8:	28 2f       	mov	r18, r24
    49da:	30 e0       	ldi	r19, 0x00	; 0
    49dc:	c9 01       	movw	r24, r18
    49de:	88 0f       	add	r24, r24
    49e0:	99 1f       	adc	r25, r25
    49e2:	88 0f       	add	r24, r24
    49e4:	99 1f       	adc	r25, r25
    49e6:	88 0f       	add	r24, r24
    49e8:	99 1f       	adc	r25, r25
    49ea:	82 0f       	add	r24, r18
    49ec:	93 1f       	adc	r25, r19
    49ee:	fc 01       	movw	r30, r24
    49f0:	e8 5c       	subi	r30, 0xC8	; 200
    49f2:	fb 4f       	sbci	r31, 0xFB	; 251
    49f4:	80 81       	ld	r24, Z
    49f6:	88 23       	and	r24, r24
    49f8:	41 f3       	breq	.-48     	; 0x49ca <vTaskSwitchContext+0x1a>
			--uxTopReadyPriority;
		}
	
		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
    49fa:	80 91 31 04 	lds	r24, 0x0431
    49fe:	28 2f       	mov	r18, r24
    4a00:	30 e0       	ldi	r19, 0x00	; 0
    4a02:	c9 01       	movw	r24, r18
    4a04:	88 0f       	add	r24, r24
    4a06:	99 1f       	adc	r25, r25
    4a08:	88 0f       	add	r24, r24
    4a0a:	99 1f       	adc	r25, r25
    4a0c:	88 0f       	add	r24, r24
    4a0e:	99 1f       	adc	r25, r25
    4a10:	82 0f       	add	r24, r18
    4a12:	93 1f       	adc	r25, r19
    4a14:	88 5c       	subi	r24, 0xC8	; 200
    4a16:	9b 4f       	sbci	r25, 0xFB	; 251
    4a18:	9a 83       	std	Y+2, r25	; 0x02
    4a1a:	89 83       	std	Y+1, r24	; 0x01
    4a1c:	e9 81       	ldd	r30, Y+1	; 0x01
    4a1e:	fa 81       	ldd	r31, Y+2	; 0x02
    4a20:	01 80       	ldd	r0, Z+1	; 0x01
    4a22:	f2 81       	ldd	r31, Z+2	; 0x02
    4a24:	e0 2d       	mov	r30, r0
    4a26:	82 81       	ldd	r24, Z+2	; 0x02
    4a28:	93 81       	ldd	r25, Z+3	; 0x03
    4a2a:	e9 81       	ldd	r30, Y+1	; 0x01
    4a2c:	fa 81       	ldd	r31, Y+2	; 0x02
    4a2e:	92 83       	std	Z+2, r25	; 0x02
    4a30:	81 83       	std	Z+1, r24	; 0x01
    4a32:	e9 81       	ldd	r30, Y+1	; 0x01
    4a34:	fa 81       	ldd	r31, Y+2	; 0x02
    4a36:	21 81       	ldd	r18, Z+1	; 0x01
    4a38:	32 81       	ldd	r19, Z+2	; 0x02
    4a3a:	89 81       	ldd	r24, Y+1	; 0x01
    4a3c:	9a 81       	ldd	r25, Y+2	; 0x02
    4a3e:	03 96       	adiw	r24, 0x03	; 3
    4a40:	28 17       	cp	r18, r24
    4a42:	39 07       	cpc	r19, r25
    4a44:	59 f4       	brne	.+22     	; 0x4a5c <vTaskSwitchContext+0xac>
    4a46:	e9 81       	ldd	r30, Y+1	; 0x01
    4a48:	fa 81       	ldd	r31, Y+2	; 0x02
    4a4a:	01 80       	ldd	r0, Z+1	; 0x01
    4a4c:	f2 81       	ldd	r31, Z+2	; 0x02
    4a4e:	e0 2d       	mov	r30, r0
    4a50:	82 81       	ldd	r24, Z+2	; 0x02
    4a52:	93 81       	ldd	r25, Z+3	; 0x03
    4a54:	e9 81       	ldd	r30, Y+1	; 0x01
    4a56:	fa 81       	ldd	r31, Y+2	; 0x02
    4a58:	92 83       	std	Z+2, r25	; 0x02
    4a5a:	81 83       	std	Z+1, r24	; 0x01
    4a5c:	e9 81       	ldd	r30, Y+1	; 0x01
    4a5e:	fa 81       	ldd	r31, Y+2	; 0x02
    4a60:	01 80       	ldd	r0, Z+1	; 0x01
    4a62:	f2 81       	ldd	r31, Z+2	; 0x02
    4a64:	e0 2d       	mov	r30, r0
    4a66:	86 81       	ldd	r24, Z+6	; 0x06
    4a68:	97 81       	ldd	r25, Z+7	; 0x07
    4a6a:	90 93 2b 04 	sts	0x042B, r25
    4a6e:	80 93 2a 04 	sts	0x042A, r24
	
		traceTASK_SWITCHED_IN();
		vWriteTraceToBuffer();
	}
}
    4a72:	0f 90       	pop	r0
    4a74:	0f 90       	pop	r0
    4a76:	cf 91       	pop	r28
    4a78:	df 91       	pop	r29
    4a7a:	08 95       	ret

00004a7c <vTaskPlaceOnEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
    4a7c:	df 93       	push	r29
    4a7e:	cf 93       	push	r28
    4a80:	00 d0       	rcall	.+0      	; 0x4a82 <vTaskPlaceOnEventList+0x6>
    4a82:	00 d0       	rcall	.+0      	; 0x4a84 <vTaskPlaceOnEventList+0x8>
    4a84:	00 d0       	rcall	.+0      	; 0x4a86 <vTaskPlaceOnEventList+0xa>
    4a86:	cd b7       	in	r28, 0x3d	; 61
    4a88:	de b7       	in	r29, 0x3e	; 62
    4a8a:	9c 83       	std	Y+4, r25	; 0x04
    4a8c:	8b 83       	std	Y+3, r24	; 0x03
    4a8e:	7e 83       	std	Y+6, r23	; 0x06
    4a90:	6d 83       	std	Y+5, r22	; 0x05
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
    4a92:	4b 81       	ldd	r20, Y+3	; 0x03
    4a94:	5c 81       	ldd	r21, Y+4	; 0x04
    4a96:	80 91 2a 04 	lds	r24, 0x042A
    4a9a:	90 91 2b 04 	lds	r25, 0x042B
    4a9e:	9c 01       	movw	r18, r24
    4aa0:	24 5f       	subi	r18, 0xF4	; 244
    4aa2:	3f 4f       	sbci	r19, 0xFF	; 255
    4aa4:	ca 01       	movw	r24, r20
    4aa6:	b9 01       	movw	r22, r18
    4aa8:	0e 94 03 18 	call	0x3006	; 0x3006 <vListInsert>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    4aac:	80 91 2a 04 	lds	r24, 0x042A
    4ab0:	90 91 2b 04 	lds	r25, 0x042B
    4ab4:	02 96       	adiw	r24, 0x02	; 2
    4ab6:	0e 94 6f 18 	call	0x30de	; 0x30de <vListRemove>
	}
	#else
	{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
    4aba:	20 91 2e 04 	lds	r18, 0x042E
    4abe:	30 91 2f 04 	lds	r19, 0x042F
    4ac2:	8d 81       	ldd	r24, Y+5	; 0x05
    4ac4:	9e 81       	ldd	r25, Y+6	; 0x06
    4ac6:	82 0f       	add	r24, r18
    4ac8:	93 1f       	adc	r25, r19
    4aca:	9a 83       	std	Y+2, r25	; 0x02
    4acc:	89 83       	std	Y+1, r24	; 0x01
			prvAddCurrentTaskToDelayedList( xTimeToWake );
    4ace:	89 81       	ldd	r24, Y+1	; 0x01
    4ad0:	9a 81       	ldd	r25, Y+2	; 0x02
    4ad2:	0e 94 38 27 	call	0x4e70	; 0x4e70 <prvAddCurrentTaskToDelayedList>
	}
	#endif
}
    4ad6:	26 96       	adiw	r28, 0x06	; 6
    4ad8:	0f b6       	in	r0, 0x3f	; 63
    4ada:	f8 94       	cli
    4adc:	de bf       	out	0x3e, r29	; 62
    4ade:	0f be       	out	0x3f, r0	; 63
    4ae0:	cd bf       	out	0x3d, r28	; 61
    4ae2:	cf 91       	pop	r28
    4ae4:	df 91       	pop	r29
    4ae6:	08 95       	ret

00004ae8 <xTaskRemoveFromEventList>:
	
#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
    4ae8:	df 93       	push	r29
    4aea:	cf 93       	push	r28
    4aec:	00 d0       	rcall	.+0      	; 0x4aee <xTaskRemoveFromEventList+0x6>
    4aee:	00 d0       	rcall	.+0      	; 0x4af0 <xTaskRemoveFromEventList+0x8>
    4af0:	0f 92       	push	r0
    4af2:	cd b7       	in	r28, 0x3d	; 61
    4af4:	de b7       	in	r29, 0x3e	; 62
    4af6:	9d 83       	std	Y+5, r25	; 0x05
    4af8:	8c 83       	std	Y+4, r24	; 0x04
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.
	
	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    4afa:	ec 81       	ldd	r30, Y+4	; 0x04
    4afc:	fd 81       	ldd	r31, Y+5	; 0x05
    4afe:	05 80       	ldd	r0, Z+5	; 0x05
    4b00:	f6 81       	ldd	r31, Z+6	; 0x06
    4b02:	e0 2d       	mov	r30, r0
    4b04:	86 81       	ldd	r24, Z+6	; 0x06
    4b06:	97 81       	ldd	r25, Z+7	; 0x07
    4b08:	9b 83       	std	Y+3, r25	; 0x03
    4b0a:	8a 83       	std	Y+2, r24	; 0x02
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
    4b0c:	8a 81       	ldd	r24, Y+2	; 0x02
    4b0e:	9b 81       	ldd	r25, Y+3	; 0x03
    4b10:	0c 96       	adiw	r24, 0x0c	; 12
    4b12:	0e 94 6f 18 	call	0x30de	; 0x30de <vListRemove>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    4b16:	80 91 33 04 	lds	r24, 0x0433
    4b1a:	88 23       	and	r24, r24
    4b1c:	61 f5       	brne	.+88     	; 0x4b76 <xTaskRemoveFromEventList+0x8e>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    4b1e:	8a 81       	ldd	r24, Y+2	; 0x02
    4b20:	9b 81       	ldd	r25, Y+3	; 0x03
    4b22:	02 96       	adiw	r24, 0x02	; 2
    4b24:	0e 94 6f 18 	call	0x30de	; 0x30de <vListRemove>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
    4b28:	ea 81       	ldd	r30, Y+2	; 0x02
    4b2a:	fb 81       	ldd	r31, Y+3	; 0x03
    4b2c:	96 89       	ldd	r25, Z+22	; 0x16
    4b2e:	80 91 31 04 	lds	r24, 0x0431
    4b32:	89 17       	cp	r24, r25
    4b34:	28 f4       	brcc	.+10     	; 0x4b40 <xTaskRemoveFromEventList+0x58>
    4b36:	ea 81       	ldd	r30, Y+2	; 0x02
    4b38:	fb 81       	ldd	r31, Y+3	; 0x03
    4b3a:	86 89       	ldd	r24, Z+22	; 0x16
    4b3c:	80 93 31 04 	sts	0x0431, r24
    4b40:	ea 81       	ldd	r30, Y+2	; 0x02
    4b42:	fb 81       	ldd	r31, Y+3	; 0x03
    4b44:	86 89       	ldd	r24, Z+22	; 0x16
    4b46:	28 2f       	mov	r18, r24
    4b48:	30 e0       	ldi	r19, 0x00	; 0
    4b4a:	c9 01       	movw	r24, r18
    4b4c:	88 0f       	add	r24, r24
    4b4e:	99 1f       	adc	r25, r25
    4b50:	88 0f       	add	r24, r24
    4b52:	99 1f       	adc	r25, r25
    4b54:	88 0f       	add	r24, r24
    4b56:	99 1f       	adc	r25, r25
    4b58:	82 0f       	add	r24, r18
    4b5a:	93 1f       	adc	r25, r19
    4b5c:	ac 01       	movw	r20, r24
    4b5e:	48 5c       	subi	r20, 0xC8	; 200
    4b60:	5b 4f       	sbci	r21, 0xFB	; 251
    4b62:	8a 81       	ldd	r24, Y+2	; 0x02
    4b64:	9b 81       	ldd	r25, Y+3	; 0x03
    4b66:	9c 01       	movw	r18, r24
    4b68:	2e 5f       	subi	r18, 0xFE	; 254
    4b6a:	3f 4f       	sbci	r19, 0xFF	; 255
    4b6c:	ca 01       	movw	r24, r20
    4b6e:	b9 01       	movw	r22, r18
    4b70:	0e 94 b7 17 	call	0x2f6e	; 0x2f6e <vListInsertEnd>
    4b74:	0a c0       	rjmp	.+20     	; 0x4b8a <xTaskRemoveFromEventList+0xa2>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    4b76:	8a 81       	ldd	r24, Y+2	; 0x02
    4b78:	9b 81       	ldd	r25, Y+3	; 0x03
    4b7a:	9c 01       	movw	r18, r24
    4b7c:	24 5f       	subi	r18, 0xF4	; 244
    4b7e:	3f 4f       	sbci	r19, 0xFF	; 255
    4b80:	8b e7       	ldi	r24, 0x7B	; 123
    4b82:	94 e0       	ldi	r25, 0x04	; 4
    4b84:	b9 01       	movw	r22, r18
    4b86:	0e 94 b7 17 	call	0x2f6e	; 0x2f6e <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
    4b8a:	ea 81       	ldd	r30, Y+2	; 0x02
    4b8c:	fb 81       	ldd	r31, Y+3	; 0x03
    4b8e:	96 89       	ldd	r25, Z+22	; 0x16
    4b90:	e0 91 2a 04 	lds	r30, 0x042A
    4b94:	f0 91 2b 04 	lds	r31, 0x042B
    4b98:	86 89       	ldd	r24, Z+22	; 0x16
    4b9a:	98 17       	cp	r25, r24
    4b9c:	18 f0       	brcs	.+6      	; 0x4ba4 <xTaskRemoveFromEventList+0xbc>
	{
		/* Return true if the task removed from the event list has
		a higher priority than the calling task.  This allows
		the calling task to know if it should force a context
		switch now. */
		xReturn = pdTRUE;
    4b9e:	81 e0       	ldi	r24, 0x01	; 1
    4ba0:	89 83       	std	Y+1, r24	; 0x01
    4ba2:	01 c0       	rjmp	.+2      	; 0x4ba6 <xTaskRemoveFromEventList+0xbe>
	}
	else
	{
		xReturn = pdFALSE;
    4ba4:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    4ba6:	89 81       	ldd	r24, Y+1	; 0x01
}
    4ba8:	0f 90       	pop	r0
    4baa:	0f 90       	pop	r0
    4bac:	0f 90       	pop	r0
    4bae:	0f 90       	pop	r0
    4bb0:	0f 90       	pop	r0
    4bb2:	cf 91       	pop	r28
    4bb4:	df 91       	pop	r29
    4bb6:	08 95       	ret

00004bb8 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
    4bb8:	df 93       	push	r29
    4bba:	cf 93       	push	r28
    4bbc:	00 d0       	rcall	.+0      	; 0x4bbe <vTaskSetTimeOutState+0x6>
    4bbe:	cd b7       	in	r28, 0x3d	; 61
    4bc0:	de b7       	in	r29, 0x3e	; 62
    4bc2:	9a 83       	std	Y+2, r25	; 0x02
    4bc4:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    4bc6:	80 91 36 04 	lds	r24, 0x0436
    4bca:	e9 81       	ldd	r30, Y+1	; 0x01
    4bcc:	fa 81       	ldd	r31, Y+2	; 0x02
    4bce:	80 83       	st	Z, r24
	pxTimeOut->xTimeOnEntering = xTickCount;
    4bd0:	80 91 2e 04 	lds	r24, 0x042E
    4bd4:	90 91 2f 04 	lds	r25, 0x042F
    4bd8:	e9 81       	ldd	r30, Y+1	; 0x01
    4bda:	fa 81       	ldd	r31, Y+2	; 0x02
    4bdc:	92 83       	std	Z+2, r25	; 0x02
    4bde:	81 83       	std	Z+1, r24	; 0x01
}
    4be0:	0f 90       	pop	r0
    4be2:	0f 90       	pop	r0
    4be4:	cf 91       	pop	r28
    4be6:	df 91       	pop	r29
    4be8:	08 95       	ret

00004bea <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
    4bea:	df 93       	push	r29
    4bec:	cf 93       	push	r28
    4bee:	00 d0       	rcall	.+0      	; 0x4bf0 <xTaskCheckForTimeOut+0x6>
    4bf0:	00 d0       	rcall	.+0      	; 0x4bf2 <xTaskCheckForTimeOut+0x8>
    4bf2:	0f 92       	push	r0
    4bf4:	cd b7       	in	r28, 0x3d	; 61
    4bf6:	de b7       	in	r29, 0x3e	; 62
    4bf8:	9b 83       	std	Y+3, r25	; 0x03
    4bfa:	8a 83       	std	Y+2, r24	; 0x02
    4bfc:	7d 83       	std	Y+5, r23	; 0x05
    4bfe:	6c 83       	std	Y+4, r22	; 0x04
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    4c00:	0f b6       	in	r0, 0x3f	; 63
    4c02:	f8 94       	cli
    4c04:	0f 92       	push	r0
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
    4c06:	ea 81       	ldd	r30, Y+2	; 0x02
    4c08:	fb 81       	ldd	r31, Y+3	; 0x03
    4c0a:	90 81       	ld	r25, Z
    4c0c:	80 91 36 04 	lds	r24, 0x0436
    4c10:	98 17       	cp	r25, r24
    4c12:	71 f0       	breq	.+28     	; 0x4c30 <xTaskCheckForTimeOut+0x46>
    4c14:	ea 81       	ldd	r30, Y+2	; 0x02
    4c16:	fb 81       	ldd	r31, Y+3	; 0x03
    4c18:	21 81       	ldd	r18, Z+1	; 0x01
    4c1a:	32 81       	ldd	r19, Z+2	; 0x02
    4c1c:	80 91 2e 04 	lds	r24, 0x042E
    4c20:	90 91 2f 04 	lds	r25, 0x042F
    4c24:	82 17       	cp	r24, r18
    4c26:	93 07       	cpc	r25, r19
    4c28:	18 f0       	brcs	.+6      	; 0x4c30 <xTaskCheckForTimeOut+0x46>
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
    4c2a:	81 e0       	ldi	r24, 0x01	; 1
    4c2c:	89 83       	std	Y+1, r24	; 0x01
    4c2e:	2f c0       	rjmp	.+94     	; 0x4c8e <xTaskCheckForTimeOut+0xa4>
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
    4c30:	20 91 2e 04 	lds	r18, 0x042E
    4c34:	30 91 2f 04 	lds	r19, 0x042F
    4c38:	ea 81       	ldd	r30, Y+2	; 0x02
    4c3a:	fb 81       	ldd	r31, Y+3	; 0x03
    4c3c:	81 81       	ldd	r24, Z+1	; 0x01
    4c3e:	92 81       	ldd	r25, Z+2	; 0x02
    4c40:	28 1b       	sub	r18, r24
    4c42:	39 0b       	sbc	r19, r25
    4c44:	ec 81       	ldd	r30, Y+4	; 0x04
    4c46:	fd 81       	ldd	r31, Y+5	; 0x05
    4c48:	80 81       	ld	r24, Z
    4c4a:	91 81       	ldd	r25, Z+1	; 0x01
    4c4c:	28 17       	cp	r18, r24
    4c4e:	39 07       	cpc	r19, r25
    4c50:	e0 f4       	brcc	.+56     	; 0x4c8a <xTaskCheckForTimeOut+0xa0>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
    4c52:	ec 81       	ldd	r30, Y+4	; 0x04
    4c54:	fd 81       	ldd	r31, Y+5	; 0x05
    4c56:	40 81       	ld	r20, Z
    4c58:	51 81       	ldd	r21, Z+1	; 0x01
    4c5a:	ea 81       	ldd	r30, Y+2	; 0x02
    4c5c:	fb 81       	ldd	r31, Y+3	; 0x03
    4c5e:	21 81       	ldd	r18, Z+1	; 0x01
    4c60:	32 81       	ldd	r19, Z+2	; 0x02
    4c62:	80 91 2e 04 	lds	r24, 0x042E
    4c66:	90 91 2f 04 	lds	r25, 0x042F
    4c6a:	b9 01       	movw	r22, r18
    4c6c:	68 1b       	sub	r22, r24
    4c6e:	79 0b       	sbc	r23, r25
    4c70:	cb 01       	movw	r24, r22
    4c72:	84 0f       	add	r24, r20
    4c74:	95 1f       	adc	r25, r21
    4c76:	ec 81       	ldd	r30, Y+4	; 0x04
    4c78:	fd 81       	ldd	r31, Y+5	; 0x05
    4c7a:	91 83       	std	Z+1, r25	; 0x01
    4c7c:	80 83       	st	Z, r24
			vTaskSetTimeOutState( pxTimeOut );
    4c7e:	8a 81       	ldd	r24, Y+2	; 0x02
    4c80:	9b 81       	ldd	r25, Y+3	; 0x03
    4c82:	0e 94 dc 25 	call	0x4bb8	; 0x4bb8 <vTaskSetTimeOutState>
			xReturn = pdFALSE;
    4c86:	19 82       	std	Y+1, r1	; 0x01
    4c88:	02 c0       	rjmp	.+4      	; 0x4c8e <xTaskCheckForTimeOut+0xa4>
		}
		else
		{
			xReturn = pdTRUE;
    4c8a:	81 e0       	ldi	r24, 0x01	; 1
    4c8c:	89 83       	std	Y+1, r24	; 0x01
		}
	}
	taskEXIT_CRITICAL();
    4c8e:	0f 90       	pop	r0
    4c90:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    4c92:	89 81       	ldd	r24, Y+1	; 0x01
}
    4c94:	0f 90       	pop	r0
    4c96:	0f 90       	pop	r0
    4c98:	0f 90       	pop	r0
    4c9a:	0f 90       	pop	r0
    4c9c:	0f 90       	pop	r0
    4c9e:	cf 91       	pop	r28
    4ca0:	df 91       	pop	r29
    4ca2:	08 95       	ret

00004ca4 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
    4ca4:	df 93       	push	r29
    4ca6:	cf 93       	push	r28
    4ca8:	cd b7       	in	r28, 0x3d	; 61
    4caa:	de b7       	in	r29, 0x3e	; 62
	xMissedYield = pdTRUE;
    4cac:	81 e0       	ldi	r24, 0x01	; 1
    4cae:	80 93 35 04 	sts	0x0435, r24
}
    4cb2:	cf 91       	pop	r28
    4cb4:	df 91       	pop	r29
    4cb6:	08 95       	ret

00004cb8 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
    4cb8:	df 93       	push	r29
    4cba:	cf 93       	push	r28
    4cbc:	00 d0       	rcall	.+0      	; 0x4cbe <prvIdleTask+0x6>
    4cbe:	cd b7       	in	r28, 0x3d	; 61
    4cc0:	de b7       	in	r29, 0x3e	; 62
    4cc2:	9a 83       	std	Y+2, r25	; 0x02
    4cc4:	89 83       	std	Y+1, r24	; 0x01
	( void ) pvParameters;

	for( ;; )
	{
		/* See if any tasks have been deleted. */
		prvCheckTasksWaitingTermination();
    4cc6:	0e 94 fa 26 	call	0x4df4	; 0x4df4 <prvCheckTasksWaitingTermination>
    4cca:	fd cf       	rjmp	.-6      	; 0x4cc6 <prvIdleTask+0xe>

00004ccc <prvInitialiseTCBVariables>:
 *----------------------------------------------------------*/



static void prvInitialiseTCBVariables( tskTCB *pxTCB, const signed char * const pcName, unsigned portBASE_TYPE uxPriority, const xMemoryRegion * const xRegions, unsigned short usStackDepth )
{
    4ccc:	0f 93       	push	r16
    4cce:	1f 93       	push	r17
    4cd0:	df 93       	push	r29
    4cd2:	cf 93       	push	r28
    4cd4:	cd b7       	in	r28, 0x3d	; 61
    4cd6:	de b7       	in	r29, 0x3e	; 62
    4cd8:	29 97       	sbiw	r28, 0x09	; 9
    4cda:	0f b6       	in	r0, 0x3f	; 63
    4cdc:	f8 94       	cli
    4cde:	de bf       	out	0x3e, r29	; 62
    4ce0:	0f be       	out	0x3f, r0	; 63
    4ce2:	cd bf       	out	0x3d, r28	; 61
    4ce4:	9a 83       	std	Y+2, r25	; 0x02
    4ce6:	89 83       	std	Y+1, r24	; 0x01
    4ce8:	7c 83       	std	Y+4, r23	; 0x04
    4cea:	6b 83       	std	Y+3, r22	; 0x03
    4cec:	4d 83       	std	Y+5, r20	; 0x05
    4cee:	3f 83       	std	Y+7, r19	; 0x07
    4cf0:	2e 83       	std	Y+6, r18	; 0x06
    4cf2:	19 87       	std	Y+9, r17	; 0x09
    4cf4:	08 87       	std	Y+8, r16	; 0x08
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
    4cf6:	89 81       	ldd	r24, Y+1	; 0x01
    4cf8:	9a 81       	ldd	r25, Y+2	; 0x02
    4cfa:	49 96       	adiw	r24, 0x19	; 25
    4cfc:	2b 81       	ldd	r18, Y+3	; 0x03
    4cfe:	3c 81       	ldd	r19, Y+4	; 0x04
    4d00:	b9 01       	movw	r22, r18
    4d02:	48 e0       	ldi	r20, 0x08	; 8
    4d04:	50 e0       	ldi	r21, 0x00	; 0
    4d06:	0e 94 6f 28 	call	0x50de	; 0x50de <strncpy>
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed char ) '\0';
    4d0a:	e9 81       	ldd	r30, Y+1	; 0x01
    4d0c:	fa 81       	ldd	r31, Y+2	; 0x02
    4d0e:	10 a2       	std	Z+32, r1	; 0x20

	/* This is used as an array index so must ensure it's not too large.  First
	remove the privilege bit if one is present. */
	if( uxPriority >= configMAX_PRIORITIES )
    4d10:	8d 81       	ldd	r24, Y+5	; 0x05
    4d12:	85 30       	cpi	r24, 0x05	; 5
    4d14:	10 f0       	brcs	.+4      	; 0x4d1a <prvInitialiseTCBVariables+0x4e>
	{
		uxPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
    4d16:	84 e0       	ldi	r24, 0x04	; 4
    4d18:	8d 83       	std	Y+5, r24	; 0x05
	}

	pxTCB->uxPriority = uxPriority;
    4d1a:	e9 81       	ldd	r30, Y+1	; 0x01
    4d1c:	fa 81       	ldd	r31, Y+2	; 0x02
    4d1e:	8d 81       	ldd	r24, Y+5	; 0x05
    4d20:	86 8b       	std	Z+22, r24	; 0x16
	{
		pxTCB->uxBasePriority = uxPriority;
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
    4d22:	89 81       	ldd	r24, Y+1	; 0x01
    4d24:	9a 81       	ldd	r25, Y+2	; 0x02
    4d26:	02 96       	adiw	r24, 0x02	; 2
    4d28:	0e 94 a7 17 	call	0x2f4e	; 0x2f4e <vListInitialiseItem>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
    4d2c:	89 81       	ldd	r24, Y+1	; 0x01
    4d2e:	9a 81       	ldd	r25, Y+2	; 0x02
    4d30:	0c 96       	adiw	r24, 0x0c	; 12
    4d32:	0e 94 a7 17 	call	0x2f4e	; 0x2f4e <vListInitialiseItem>

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
    4d36:	e9 81       	ldd	r30, Y+1	; 0x01
    4d38:	fa 81       	ldd	r31, Y+2	; 0x02
    4d3a:	89 81       	ldd	r24, Y+1	; 0x01
    4d3c:	9a 81       	ldd	r25, Y+2	; 0x02
    4d3e:	91 87       	std	Z+9, r25	; 0x09
    4d40:	80 87       	std	Z+8, r24	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
    4d42:	8d 81       	ldd	r24, Y+5	; 0x05
    4d44:	28 2f       	mov	r18, r24
    4d46:	30 e0       	ldi	r19, 0x00	; 0
    4d48:	85 e0       	ldi	r24, 0x05	; 5
    4d4a:	90 e0       	ldi	r25, 0x00	; 0
    4d4c:	82 1b       	sub	r24, r18
    4d4e:	93 0b       	sbc	r25, r19
    4d50:	e9 81       	ldd	r30, Y+1	; 0x01
    4d52:	fa 81       	ldd	r31, Y+2	; 0x02
    4d54:	95 87       	std	Z+13, r25	; 0x0d
    4d56:	84 87       	std	Z+12, r24	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
    4d58:	e9 81       	ldd	r30, Y+1	; 0x01
    4d5a:	fa 81       	ldd	r31, Y+2	; 0x02
    4d5c:	89 81       	ldd	r24, Y+1	; 0x01
    4d5e:	9a 81       	ldd	r25, Y+2	; 0x02
    4d60:	93 8b       	std	Z+19, r25	; 0x13
    4d62:	82 8b       	std	Z+18, r24	; 0x12
	{
		( void ) xRegions;
		( void ) usStackDepth;
	}
	#endif
}
    4d64:	29 96       	adiw	r28, 0x09	; 9
    4d66:	0f b6       	in	r0, 0x3f	; 63
    4d68:	f8 94       	cli
    4d6a:	de bf       	out	0x3e, r29	; 62
    4d6c:	0f be       	out	0x3f, r0	; 63
    4d6e:	cd bf       	out	0x3d, r28	; 61
    4d70:	cf 91       	pop	r28
    4d72:	df 91       	pop	r29
    4d74:	1f 91       	pop	r17
    4d76:	0f 91       	pop	r16
    4d78:	08 95       	ret

00004d7a <prvInitialiseTaskLists>:
	}
	/*-----------------------------------------------------------*/
#endif

static void prvInitialiseTaskLists( void )
{
    4d7a:	df 93       	push	r29
    4d7c:	cf 93       	push	r28
    4d7e:	0f 92       	push	r0
    4d80:	cd b7       	in	r28, 0x3d	; 61
    4d82:	de b7       	in	r29, 0x3e	; 62
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
    4d84:	19 82       	std	Y+1, r1	; 0x01
    4d86:	13 c0       	rjmp	.+38     	; 0x4dae <prvInitialiseTaskLists+0x34>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
    4d88:	89 81       	ldd	r24, Y+1	; 0x01
    4d8a:	28 2f       	mov	r18, r24
    4d8c:	30 e0       	ldi	r19, 0x00	; 0
    4d8e:	c9 01       	movw	r24, r18
    4d90:	88 0f       	add	r24, r24
    4d92:	99 1f       	adc	r25, r25
    4d94:	88 0f       	add	r24, r24
    4d96:	99 1f       	adc	r25, r25
    4d98:	88 0f       	add	r24, r24
    4d9a:	99 1f       	adc	r25, r25
    4d9c:	82 0f       	add	r24, r18
    4d9e:	93 1f       	adc	r25, r19
    4da0:	88 5c       	subi	r24, 0xC8	; 200
    4da2:	9b 4f       	sbci	r25, 0xFB	; 251
    4da4:	0e 94 7d 17 	call	0x2efa	; 0x2efa <vListInitialise>

static void prvInitialiseTaskLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
    4da8:	89 81       	ldd	r24, Y+1	; 0x01
    4daa:	8f 5f       	subi	r24, 0xFF	; 255
    4dac:	89 83       	std	Y+1, r24	; 0x01
    4dae:	89 81       	ldd	r24, Y+1	; 0x01
    4db0:	85 30       	cpi	r24, 0x05	; 5
    4db2:	50 f3       	brcs	.-44     	; 0x4d88 <prvInitialiseTaskLists+0xe>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
    4db4:	85 e6       	ldi	r24, 0x65	; 101
    4db6:	94 e0       	ldi	r25, 0x04	; 4
    4db8:	0e 94 7d 17 	call	0x2efa	; 0x2efa <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
    4dbc:	8e e6       	ldi	r24, 0x6E	; 110
    4dbe:	94 e0       	ldi	r25, 0x04	; 4
    4dc0:	0e 94 7d 17 	call	0x2efa	; 0x2efa <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyList );
    4dc4:	8b e7       	ldi	r24, 0x7B	; 123
    4dc6:	94 e0       	ldi	r25, 0x04	; 4
    4dc8:	0e 94 7d 17 	call	0x2efa	; 0x2efa <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( ( xList * ) &xTasksWaitingTermination );
    4dcc:	84 e8       	ldi	r24, 0x84	; 132
    4dce:	94 e0       	ldi	r25, 0x04	; 4
    4dd0:	0e 94 7d 17 	call	0x2efa	; 0x2efa <vListInitialise>
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
    4dd4:	85 e6       	ldi	r24, 0x65	; 101
    4dd6:	94 e0       	ldi	r25, 0x04	; 4
    4dd8:	90 93 78 04 	sts	0x0478, r25
    4ddc:	80 93 77 04 	sts	0x0477, r24
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    4de0:	8e e6       	ldi	r24, 0x6E	; 110
    4de2:	94 e0       	ldi	r25, 0x04	; 4
    4de4:	90 93 7a 04 	sts	0x047A, r25
    4de8:	80 93 79 04 	sts	0x0479, r24
}
    4dec:	0f 90       	pop	r0
    4dee:	cf 91       	pop	r28
    4df0:	df 91       	pop	r29
    4df2:	08 95       	ret

00004df4 <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
    4df4:	df 93       	push	r29
    4df6:	cf 93       	push	r28
    4df8:	00 d0       	rcall	.+0      	; 0x4dfa <prvCheckTasksWaitingTermination+0x6>
    4dfa:	0f 92       	push	r0
    4dfc:	cd b7       	in	r28, 0x3d	; 61
    4dfe:	de b7       	in	r29, 0x3e	; 62
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0U )
    4e00:	80 91 2c 04 	lds	r24, 0x042C
    4e04:	88 23       	and	r24, r24
    4e06:	71 f1       	breq	.+92     	; 0x4e64 <prvCheckTasksWaitingTermination+0x70>
		{
			vTaskSuspendAll();
    4e08:	0e 94 38 23 	call	0x4670	; 0x4670 <vTaskSuspendAll>
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
    4e0c:	80 91 84 04 	lds	r24, 0x0484
    4e10:	1b 82       	std	Y+3, r1	; 0x03
    4e12:	88 23       	and	r24, r24
    4e14:	11 f4       	brne	.+4      	; 0x4e1a <prvCheckTasksWaitingTermination+0x26>
    4e16:	81 e0       	ldi	r24, 0x01	; 1
    4e18:	8b 83       	std	Y+3, r24	; 0x03
			xTaskResumeAll();
    4e1a:	0e 94 44 23 	call	0x4688	; 0x4688 <xTaskResumeAll>

			if( xListIsEmpty == pdFALSE )
    4e1e:	8b 81       	ldd	r24, Y+3	; 0x03
    4e20:	88 23       	and	r24, r24
    4e22:	01 f5       	brne	.+64     	; 0x4e64 <prvCheckTasksWaitingTermination+0x70>
			{
				tskTCB *pxTCB;

				taskENTER_CRITICAL();
    4e24:	0f b6       	in	r0, 0x3f	; 63
    4e26:	f8 94       	cli
    4e28:	0f 92       	push	r0
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
    4e2a:	e0 91 89 04 	lds	r30, 0x0489
    4e2e:	f0 91 8a 04 	lds	r31, 0x048A
    4e32:	86 81       	ldd	r24, Z+6	; 0x06
    4e34:	97 81       	ldd	r25, Z+7	; 0x07
    4e36:	9a 83       	std	Y+2, r25	; 0x02
    4e38:	89 83       	std	Y+1, r24	; 0x01
					vListRemove( &( pxTCB->xGenericListItem ) );
    4e3a:	89 81       	ldd	r24, Y+1	; 0x01
    4e3c:	9a 81       	ldd	r25, Y+2	; 0x02
    4e3e:	02 96       	adiw	r24, 0x02	; 2
    4e40:	0e 94 6f 18 	call	0x30de	; 0x30de <vListRemove>
					--uxCurrentNumberOfTasks;
    4e44:	80 91 2d 04 	lds	r24, 0x042D
    4e48:	81 50       	subi	r24, 0x01	; 1
    4e4a:	80 93 2d 04 	sts	0x042D, r24
					--uxTasksDeleted;
    4e4e:	80 91 2c 04 	lds	r24, 0x042C
    4e52:	81 50       	subi	r24, 0x01	; 1
    4e54:	80 93 2c 04 	sts	0x042C, r24
				}
				taskEXIT_CRITICAL();
    4e58:	0f 90       	pop	r0
    4e5a:	0f be       	out	0x3f, r0	; 63

				prvDeleteTCB( pxTCB );
    4e5c:	89 81       	ldd	r24, Y+1	; 0x01
    4e5e:	9a 81       	ldd	r25, Y+2	; 0x02
    4e60:	0e 94 d1 27 	call	0x4fa2	; 0x4fa2 <prvDeleteTCB>
			}
		}
	}
	#endif
}
    4e64:	0f 90       	pop	r0
    4e66:	0f 90       	pop	r0
    4e68:	0f 90       	pop	r0
    4e6a:	cf 91       	pop	r28
    4e6c:	df 91       	pop	r29
    4e6e:	08 95       	ret

00004e70 <prvAddCurrentTaskToDelayedList>:
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
    4e70:	df 93       	push	r29
    4e72:	cf 93       	push	r28
    4e74:	00 d0       	rcall	.+0      	; 0x4e76 <prvAddCurrentTaskToDelayedList+0x6>
    4e76:	cd b7       	in	r28, 0x3d	; 61
    4e78:	de b7       	in	r29, 0x3e	; 62
    4e7a:	9a 83       	std	Y+2, r25	; 0x02
    4e7c:	89 83       	std	Y+1, r24	; 0x01
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
    4e7e:	e0 91 2a 04 	lds	r30, 0x042A
    4e82:	f0 91 2b 04 	lds	r31, 0x042B
    4e86:	89 81       	ldd	r24, Y+1	; 0x01
    4e88:	9a 81       	ldd	r25, Y+2	; 0x02
    4e8a:	93 83       	std	Z+3, r25	; 0x03
    4e8c:	82 83       	std	Z+2, r24	; 0x02

	if( xTimeToWake < xTickCount )
    4e8e:	20 91 2e 04 	lds	r18, 0x042E
    4e92:	30 91 2f 04 	lds	r19, 0x042F
    4e96:	89 81       	ldd	r24, Y+1	; 0x01
    4e98:	9a 81       	ldd	r25, Y+2	; 0x02
    4e9a:	82 17       	cp	r24, r18
    4e9c:	93 07       	cpc	r25, r19
    4e9e:	70 f4       	brcc	.+28     	; 0x4ebc <prvAddCurrentTaskToDelayedList+0x4c>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    4ea0:	80 91 79 04 	lds	r24, 0x0479
    4ea4:	90 91 7a 04 	lds	r25, 0x047A
    4ea8:	20 91 2a 04 	lds	r18, 0x042A
    4eac:	30 91 2b 04 	lds	r19, 0x042B
    4eb0:	2e 5f       	subi	r18, 0xFE	; 254
    4eb2:	3f 4f       	sbci	r19, 0xFF	; 255
    4eb4:	b9 01       	movw	r22, r18
    4eb6:	0e 94 03 18 	call	0x3006	; 0x3006 <vListInsert>
    4eba:	1e c0       	rjmp	.+60     	; 0x4ef8 <prvAddCurrentTaskToDelayedList+0x88>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the current block list. */
		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    4ebc:	40 91 77 04 	lds	r20, 0x0477
    4ec0:	50 91 78 04 	lds	r21, 0x0478
    4ec4:	80 91 2a 04 	lds	r24, 0x042A
    4ec8:	90 91 2b 04 	lds	r25, 0x042B
    4ecc:	9c 01       	movw	r18, r24
    4ece:	2e 5f       	subi	r18, 0xFE	; 254
    4ed0:	3f 4f       	sbci	r19, 0xFF	; 255
    4ed2:	ca 01       	movw	r24, r20
    4ed4:	b9 01       	movw	r22, r18
    4ed6:	0e 94 03 18 	call	0x3006	; 0x3006 <vListInsert>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
    4eda:	20 91 8f 01 	lds	r18, 0x018F
    4ede:	30 91 90 01 	lds	r19, 0x0190
    4ee2:	89 81       	ldd	r24, Y+1	; 0x01
    4ee4:	9a 81       	ldd	r25, Y+2	; 0x02
    4ee6:	82 17       	cp	r24, r18
    4ee8:	93 07       	cpc	r25, r19
    4eea:	30 f4       	brcc	.+12     	; 0x4ef8 <prvAddCurrentTaskToDelayedList+0x88>
		{
			xNextTaskUnblockTime = xTimeToWake;
    4eec:	89 81       	ldd	r24, Y+1	; 0x01
    4eee:	9a 81       	ldd	r25, Y+2	; 0x02
    4ef0:	90 93 90 01 	sts	0x0190, r25
    4ef4:	80 93 8f 01 	sts	0x018F, r24
		}
	}
}
    4ef8:	0f 90       	pop	r0
    4efa:	0f 90       	pop	r0
    4efc:	cf 91       	pop	r28
    4efe:	df 91       	pop	r29
    4f00:	08 95       	ret

00004f02 <prvAllocateTCBAndStack>:
/*-----------------------------------------------------------*/

static tskTCB *prvAllocateTCBAndStack( unsigned short usStackDepth, portSTACK_TYPE *puxStackBuffer )
{
    4f02:	df 93       	push	r29
    4f04:	cf 93       	push	r28
    4f06:	cd b7       	in	r28, 0x3d	; 61
    4f08:	de b7       	in	r29, 0x3e	; 62
    4f0a:	28 97       	sbiw	r28, 0x08	; 8
    4f0c:	0f b6       	in	r0, 0x3f	; 63
    4f0e:	f8 94       	cli
    4f10:	de bf       	out	0x3e, r29	; 62
    4f12:	0f be       	out	0x3f, r0	; 63
    4f14:	cd bf       	out	0x3d, r28	; 61
    4f16:	9c 83       	std	Y+4, r25	; 0x04
    4f18:	8b 83       	std	Y+3, r24	; 0x03
    4f1a:	7e 83       	std	Y+6, r23	; 0x06
    4f1c:	6d 83       	std	Y+5, r22	; 0x05
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
    4f1e:	81 e2       	ldi	r24, 0x21	; 33
    4f20:	90 e0       	ldi	r25, 0x00	; 0
    4f22:	0e 94 11 17 	call	0x2e22	; 0x2e22 <pvPortMalloc>
    4f26:	9a 83       	std	Y+2, r25	; 0x02
    4f28:	89 83       	std	Y+1, r24	; 0x01

	if( pxNewTCB != NULL )
    4f2a:	89 81       	ldd	r24, Y+1	; 0x01
    4f2c:	9a 81       	ldd	r25, Y+2	; 0x02
    4f2e:	00 97       	sbiw	r24, 0x00	; 0
    4f30:	69 f1       	breq	.+90     	; 0x4f8c <prvAllocateTCBAndStack+0x8a>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
    4f32:	8d 81       	ldd	r24, Y+5	; 0x05
    4f34:	9e 81       	ldd	r25, Y+6	; 0x06
    4f36:	00 97       	sbiw	r24, 0x00	; 0
    4f38:	39 f4       	brne	.+14     	; 0x4f48 <prvAllocateTCBAndStack+0x46>
    4f3a:	8b 81       	ldd	r24, Y+3	; 0x03
    4f3c:	9c 81       	ldd	r25, Y+4	; 0x04
    4f3e:	0e 94 11 17 	call	0x2e22	; 0x2e22 <pvPortMalloc>
    4f42:	98 87       	std	Y+8, r25	; 0x08
    4f44:	8f 83       	std	Y+7, r24	; 0x07
    4f46:	04 c0       	rjmp	.+8      	; 0x4f50 <prvAllocateTCBAndStack+0x4e>
    4f48:	8d 81       	ldd	r24, Y+5	; 0x05
    4f4a:	9e 81       	ldd	r25, Y+6	; 0x06
    4f4c:	98 87       	std	Y+8, r25	; 0x08
    4f4e:	8f 83       	std	Y+7, r24	; 0x07
    4f50:	e9 81       	ldd	r30, Y+1	; 0x01
    4f52:	fa 81       	ldd	r31, Y+2	; 0x02
    4f54:	8f 81       	ldd	r24, Y+7	; 0x07
    4f56:	98 85       	ldd	r25, Y+8	; 0x08
    4f58:	90 8f       	std	Z+24, r25	; 0x18
    4f5a:	87 8b       	std	Z+23, r24	; 0x17

		if( pxNewTCB->pxStack == NULL )
    4f5c:	e9 81       	ldd	r30, Y+1	; 0x01
    4f5e:	fa 81       	ldd	r31, Y+2	; 0x02
    4f60:	87 89       	ldd	r24, Z+23	; 0x17
    4f62:	90 8d       	ldd	r25, Z+24	; 0x18
    4f64:	00 97       	sbiw	r24, 0x00	; 0
    4f66:	39 f4       	brne	.+14     	; 0x4f76 <prvAllocateTCBAndStack+0x74>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
    4f68:	89 81       	ldd	r24, Y+1	; 0x01
    4f6a:	9a 81       	ldd	r25, Y+2	; 0x02
    4f6c:	0e 94 57 17 	call	0x2eae	; 0x2eae <vPortFree>
			pxNewTCB = NULL;
    4f70:	1a 82       	std	Y+2, r1	; 0x02
    4f72:	19 82       	std	Y+1, r1	; 0x01
    4f74:	0b c0       	rjmp	.+22     	; 0x4f8c <prvAllocateTCBAndStack+0x8a>
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) usStackDepth * sizeof( portSTACK_TYPE ) );
    4f76:	e9 81       	ldd	r30, Y+1	; 0x01
    4f78:	fa 81       	ldd	r31, Y+2	; 0x02
    4f7a:	87 89       	ldd	r24, Z+23	; 0x17
    4f7c:	90 8d       	ldd	r25, Z+24	; 0x18
    4f7e:	2b 81       	ldd	r18, Y+3	; 0x03
    4f80:	3c 81       	ldd	r19, Y+4	; 0x04
    4f82:	65 ea       	ldi	r22, 0xA5	; 165
    4f84:	70 e0       	ldi	r23, 0x00	; 0
    4f86:	a9 01       	movw	r20, r18
    4f88:	0e 94 68 28 	call	0x50d0	; 0x50d0 <memset>
		}
	}

	return pxNewTCB;
    4f8c:	89 81       	ldd	r24, Y+1	; 0x01
    4f8e:	9a 81       	ldd	r25, Y+2	; 0x02
}
    4f90:	28 96       	adiw	r28, 0x08	; 8
    4f92:	0f b6       	in	r0, 0x3f	; 63
    4f94:	f8 94       	cli
    4f96:	de bf       	out	0x3e, r29	; 62
    4f98:	0f be       	out	0x3f, r0	; 63
    4f9a:	cd bf       	out	0x3d, r28	; 61
    4f9c:	cf 91       	pop	r28
    4f9e:	df 91       	pop	r29
    4fa0:	08 95       	ret

00004fa2 <prvDeleteTCB>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	static void prvDeleteTCB( tskTCB *pxTCB )
	{
    4fa2:	df 93       	push	r29
    4fa4:	cf 93       	push	r28
    4fa6:	00 d0       	rcall	.+0      	; 0x4fa8 <prvDeleteTCB+0x6>
    4fa8:	cd b7       	in	r28, 0x3d	; 61
    4faa:	de b7       	in	r29, 0x3e	; 62
    4fac:	9a 83       	std	Y+2, r25	; 0x02
    4fae:	89 83       	std	Y+1, r24	; 0x01
		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
    4fb0:	e9 81       	ldd	r30, Y+1	; 0x01
    4fb2:	fa 81       	ldd	r31, Y+2	; 0x02
    4fb4:	87 89       	ldd	r24, Z+23	; 0x17
    4fb6:	90 8d       	ldd	r25, Z+24	; 0x18
    4fb8:	0e 94 57 17 	call	0x2eae	; 0x2eae <vPortFree>
		vPortFree( pxTCB );
    4fbc:	89 81       	ldd	r24, Y+1	; 0x01
    4fbe:	9a 81       	ldd	r25, Y+2	; 0x02
    4fc0:	0e 94 57 17 	call	0x2eae	; 0x2eae <vPortFree>
	}
    4fc4:	0f 90       	pop	r0
    4fc6:	0f 90       	pop	r0
    4fc8:	cf 91       	pop	r28
    4fca:	df 91       	pop	r29
    4fcc:	08 95       	ret

00004fce <__mulsi3>:
    4fce:	62 9f       	mul	r22, r18
    4fd0:	d0 01       	movw	r26, r0
    4fd2:	73 9f       	mul	r23, r19
    4fd4:	f0 01       	movw	r30, r0
    4fd6:	82 9f       	mul	r24, r18
    4fd8:	e0 0d       	add	r30, r0
    4fda:	f1 1d       	adc	r31, r1
    4fdc:	64 9f       	mul	r22, r20
    4fde:	e0 0d       	add	r30, r0
    4fe0:	f1 1d       	adc	r31, r1
    4fe2:	92 9f       	mul	r25, r18
    4fe4:	f0 0d       	add	r31, r0
    4fe6:	83 9f       	mul	r24, r19
    4fe8:	f0 0d       	add	r31, r0
    4fea:	74 9f       	mul	r23, r20
    4fec:	f0 0d       	add	r31, r0
    4fee:	65 9f       	mul	r22, r21
    4ff0:	f0 0d       	add	r31, r0
    4ff2:	99 27       	eor	r25, r25
    4ff4:	72 9f       	mul	r23, r18
    4ff6:	b0 0d       	add	r27, r0
    4ff8:	e1 1d       	adc	r30, r1
    4ffa:	f9 1f       	adc	r31, r25
    4ffc:	63 9f       	mul	r22, r19
    4ffe:	b0 0d       	add	r27, r0
    5000:	e1 1d       	adc	r30, r1
    5002:	f9 1f       	adc	r31, r25
    5004:	bd 01       	movw	r22, r26
    5006:	cf 01       	movw	r24, r30
    5008:	11 24       	eor	r1, r1
    500a:	08 95       	ret

0000500c <__udivmodsi4>:
    500c:	a1 e2       	ldi	r26, 0x21	; 33
    500e:	1a 2e       	mov	r1, r26
    5010:	aa 1b       	sub	r26, r26
    5012:	bb 1b       	sub	r27, r27
    5014:	fd 01       	movw	r30, r26
    5016:	0d c0       	rjmp	.+26     	; 0x5032 <__udivmodsi4_ep>

00005018 <__udivmodsi4_loop>:
    5018:	aa 1f       	adc	r26, r26
    501a:	bb 1f       	adc	r27, r27
    501c:	ee 1f       	adc	r30, r30
    501e:	ff 1f       	adc	r31, r31
    5020:	a2 17       	cp	r26, r18
    5022:	b3 07       	cpc	r27, r19
    5024:	e4 07       	cpc	r30, r20
    5026:	f5 07       	cpc	r31, r21
    5028:	20 f0       	brcs	.+8      	; 0x5032 <__udivmodsi4_ep>
    502a:	a2 1b       	sub	r26, r18
    502c:	b3 0b       	sbc	r27, r19
    502e:	e4 0b       	sbc	r30, r20
    5030:	f5 0b       	sbc	r31, r21

00005032 <__udivmodsi4_ep>:
    5032:	66 1f       	adc	r22, r22
    5034:	77 1f       	adc	r23, r23
    5036:	88 1f       	adc	r24, r24
    5038:	99 1f       	adc	r25, r25
    503a:	1a 94       	dec	r1
    503c:	69 f7       	brne	.-38     	; 0x5018 <__udivmodsi4_loop>
    503e:	60 95       	com	r22
    5040:	70 95       	com	r23
    5042:	80 95       	com	r24
    5044:	90 95       	com	r25
    5046:	9b 01       	movw	r18, r22
    5048:	ac 01       	movw	r20, r24
    504a:	bd 01       	movw	r22, r26
    504c:	cf 01       	movw	r24, r30
    504e:	08 95       	ret

00005050 <__prologue_saves__>:
    5050:	2f 92       	push	r2
    5052:	3f 92       	push	r3
    5054:	4f 92       	push	r4
    5056:	5f 92       	push	r5
    5058:	6f 92       	push	r6
    505a:	7f 92       	push	r7
    505c:	8f 92       	push	r8
    505e:	9f 92       	push	r9
    5060:	af 92       	push	r10
    5062:	bf 92       	push	r11
    5064:	cf 92       	push	r12
    5066:	df 92       	push	r13
    5068:	ef 92       	push	r14
    506a:	ff 92       	push	r15
    506c:	0f 93       	push	r16
    506e:	1f 93       	push	r17
    5070:	cf 93       	push	r28
    5072:	df 93       	push	r29
    5074:	cd b7       	in	r28, 0x3d	; 61
    5076:	de b7       	in	r29, 0x3e	; 62
    5078:	ca 1b       	sub	r28, r26
    507a:	db 0b       	sbc	r29, r27
    507c:	0f b6       	in	r0, 0x3f	; 63
    507e:	f8 94       	cli
    5080:	de bf       	out	0x3e, r29	; 62
    5082:	0f be       	out	0x3f, r0	; 63
    5084:	cd bf       	out	0x3d, r28	; 61
    5086:	09 94       	ijmp

00005088 <__epilogue_restores__>:
    5088:	2a 88       	ldd	r2, Y+18	; 0x12
    508a:	39 88       	ldd	r3, Y+17	; 0x11
    508c:	48 88       	ldd	r4, Y+16	; 0x10
    508e:	5f 84       	ldd	r5, Y+15	; 0x0f
    5090:	6e 84       	ldd	r6, Y+14	; 0x0e
    5092:	7d 84       	ldd	r7, Y+13	; 0x0d
    5094:	8c 84       	ldd	r8, Y+12	; 0x0c
    5096:	9b 84       	ldd	r9, Y+11	; 0x0b
    5098:	aa 84       	ldd	r10, Y+10	; 0x0a
    509a:	b9 84       	ldd	r11, Y+9	; 0x09
    509c:	c8 84       	ldd	r12, Y+8	; 0x08
    509e:	df 80       	ldd	r13, Y+7	; 0x07
    50a0:	ee 80       	ldd	r14, Y+6	; 0x06
    50a2:	fd 80       	ldd	r15, Y+5	; 0x05
    50a4:	0c 81       	ldd	r16, Y+4	; 0x04
    50a6:	1b 81       	ldd	r17, Y+3	; 0x03
    50a8:	aa 81       	ldd	r26, Y+2	; 0x02
    50aa:	b9 81       	ldd	r27, Y+1	; 0x01
    50ac:	ce 0f       	add	r28, r30
    50ae:	d1 1d       	adc	r29, r1
    50b0:	0f b6       	in	r0, 0x3f	; 63
    50b2:	f8 94       	cli
    50b4:	de bf       	out	0x3e, r29	; 62
    50b6:	0f be       	out	0x3f, r0	; 63
    50b8:	cd bf       	out	0x3d, r28	; 61
    50ba:	ed 01       	movw	r28, r26
    50bc:	08 95       	ret

000050be <memcpy>:
    50be:	fb 01       	movw	r30, r22
    50c0:	dc 01       	movw	r26, r24
    50c2:	02 c0       	rjmp	.+4      	; 0x50c8 <memcpy+0xa>
    50c4:	01 90       	ld	r0, Z+
    50c6:	0d 92       	st	X+, r0
    50c8:	41 50       	subi	r20, 0x01	; 1
    50ca:	50 40       	sbci	r21, 0x00	; 0
    50cc:	d8 f7       	brcc	.-10     	; 0x50c4 <memcpy+0x6>
    50ce:	08 95       	ret

000050d0 <memset>:
    50d0:	dc 01       	movw	r26, r24
    50d2:	01 c0       	rjmp	.+2      	; 0x50d6 <memset+0x6>
    50d4:	6d 93       	st	X+, r22
    50d6:	41 50       	subi	r20, 0x01	; 1
    50d8:	50 40       	sbci	r21, 0x00	; 0
    50da:	e0 f7       	brcc	.-8      	; 0x50d4 <memset+0x4>
    50dc:	08 95       	ret

000050de <strncpy>:
    50de:	fb 01       	movw	r30, r22
    50e0:	dc 01       	movw	r26, r24
    50e2:	41 50       	subi	r20, 0x01	; 1
    50e4:	50 40       	sbci	r21, 0x00	; 0
    50e6:	48 f0       	brcs	.+18     	; 0x50fa <strncpy+0x1c>
    50e8:	01 90       	ld	r0, Z+
    50ea:	0d 92       	st	X+, r0
    50ec:	00 20       	and	r0, r0
    50ee:	c9 f7       	brne	.-14     	; 0x50e2 <strncpy+0x4>
    50f0:	01 c0       	rjmp	.+2      	; 0x50f4 <strncpy+0x16>
    50f2:	1d 92       	st	X+, r1
    50f4:	41 50       	subi	r20, 0x01	; 1
    50f6:	50 40       	sbci	r21, 0x00	; 0
    50f8:	e0 f7       	brcc	.-8      	; 0x50f2 <strncpy+0x14>
    50fa:	08 95       	ret

000050fc <_exit>:
    50fc:	f8 94       	cli

000050fe <__stop_program>:
    50fe:	ff cf       	rjmp	.-2      	; 0x50fe <__stop_program>
